
<html>

<head>
<title>MuqcsCraft</title>
<meta charset="utf-8"/>
<style type="text/css">
   label:hover, button:hover, a:link:hover, a:visited:hover { background-color: #bbeeff; }
   blockquote { margin-bottom: 0; margin-top: 0; }
</style>


<script language="JavaScript">
   function toggleDisplay(stuffToToggle,elementThatExpandsStuff,elementThatCollapsesStuff) {
      if ( stuffToToggle.style.display == 'none' ) {
         stuffToToggle.style.display = '';
         elementThatExpandsStuff.style.display = 'none';
         elementThatCollapsesStuff.style.display = '';
      }
      else {
         stuffToToggle.style.display = 'none';
         elementThatExpandsStuff.style.display = '';
         elementThatCollapsesStuff.style.display = 'none';
      }
   }
</script>



</head>

<body>

<table>
  <tr>
    <td>
        <label><input id="displayOptionsOverlayCheckbox" type='checkbox' onclick='let div = document.getElementById("displayOptions"); if (this.checked) { let canvas_rect = document.getElementById("myCanvas").getBoundingClientRect(); div.style.backgroundColor = "rgba(192,224,255,0.75)"; div.style.position = "fixed"; div.style.top = canvas_rect.top; div.style.left = canvas_rect.left; } else { div.style.backgroundColor = div.style.position = div.style.top = div.style.left = ""; }'>Overlay<br/>Display Options</label>
    <td>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
    <td>
        Welcome to <b>MuqcsCraft</b> [<a href="https://github.com/MJMcGuffin/MuqcsCraft">source code</a>] [<a href="https://youtu.be/BCunU_gCXT4">video explainer</a>] [<a href="https://arxiv.org/abs/2510.00895">paper</a>], an open-source graphical simulator and visualizer for quantum circuits,
        built on top of the <a href="https://github.com/MJMcGuffin/muqcs.js">Muqcs</a> library.
</table>






<!-- canvas id="myCanvas" width="900" height="750" style="border:2px solid #000000;" -->
<canvas id="myCanvas" width="1200" height="800" style="border:2px solid #000000;">
</canvas>

<p>
Use <b>Left mouse button</b> to drag-and-drop a gate.
To add a new qubit to the circuit, drag-and-drop any gate below the bottom qubit.

<p>
Some gates have parameters. To change a parameter, use Ctrl+left mouse button and drag left-right,
or use Shift+left mouse button and drag left-right to snap the parameter to nice values.
You can also click on a parameter to select it, and then use
Ctrl+left arrow, Ctrl+right arrow keys to adjust,
Shift+left arrow, Shift+right arrow keys to snap.

<p>
To <b>delete a gate</b>, you can
(1) left-click on the gate to select it, and then hit the Delete key;
or (2) drag the gate off the circuit and drop it outside;
or (3) press+release over the gate with the <b>Middle mouse button</b>  (like in <a href="https://algassert.com/quirk">Quirk</a>).

<p>
To <b>UNDO</b>, hit the Back button in your web browser.
The state of the circuit is encoded in the query string of the browser's URL (like in Quirk),
hence circuits can be bookmarked and shared as hyperlinks in plain text.

<p>
Additional options:
<span id='g1e'>[<a href="javascript:toggleDisplay(g1,g1e,g1c)">Show...</a>]</span>
<span id='g1c' style="display:none">[<a href="javascript:toggleDisplay(g1,g1e,g1c)">Hide</a>]</span>

<blockquote>
    <span id='g1' style="display:none">
    <p>
    Camera controls: <b>Shift+Right mouse button</b> drag to translate; <b>Ctrl+Right mouse button</b> drag left-right to zoom.
    <br/>
    <button onclick="frameButtonHandler()">Frame</button>
    <button onclick="animatedFrameButtonHandler()">Animated Frame</button>

    <p>
    <button onclick="clearCircuitButtonHandler()">Clear Circuit</button>
    Hit the Back button in your browser to Undo.

    <p>
    <button onclick="expandCircuitButtonHandler()">Expand Circuit</button>
    Replaces certain gates with equivalent sequences of other gates so that their effects can be visualized on the state vector more easily, at the cost of making the circuit deeper.
    If generalized gates are used, then fewer layers need to be added in the expansion.
    See our paper for details.
    Hit the Back button in your browser to Undo.
    <br>
    <label><input type='checkbox' id='useGeneralizedGatesCheckbox'>Use generalized gates in the expansion</label> to produce a shorter expansion.

    <p>
    <button onclick="printMagicButtonHandler()">Print Magic</button> Prints <a href="https://scholar.google.com/scholar?q=leone+Stabilizer+Renyi+Entropy">Second Stabilizer Rényi Entropy</a> of the output state to the console.

    </span>
</blockquote>

<div id="displayOptions">
<p>
Display options:

<blockquote>

Local State
<blockquote>
   <!--
   <label><input type='checkbox' datavar="showFinalLocalState">▶Show final local state</label> <br/>
   <label><input type='checkbox' datavar="showLocalStatePerLayer">▶Show local state per layer</label>
   <br/>
   -->
   For each local state... <br/>
   <label><input type='checkbox' datavar="LS_showPurity">Show Purity</label>
   <label><input type='checkbox' datavar="LS_showLinearEntropy">Show Linear Entropy (= 1-Purity)</label>
   <label><input type='checkbox' datavar="LS_showVonNeumannEntropy">Show Von Neumann Entropy</label>
   <label><input type='checkbox' datavar="LS_showProbability">Show Probability</label>
   <label><input type='checkbox' datavar="LS_showPhase">Show Phase</label>
</blockquote>

Half Matrix
<blockquote>
   <!-- <label><input type='checkbox' datavar="showFinalHalfMatrix">▶Show Final Half Matrix</label> <br/> -->
   In each cell of the Half Matrix, show... <br/>
   <blockquote>
       <label><input type='radio' name="radioGroup4" datavar="HM_cellContents" datavarvalue="HM_BARCHART">barchart</label><br/>
       <blockquote>
           For each pair of qubits... <br/>
           <label><input type='checkbox' datavar="HM_showPurity">Show Purity</label>
           <label><input type='checkbox' datavar="HM_showLinearEntropy">Show Linear Entropy (= 1-Purity)</label>
           <label><input type='checkbox' datavar="HM_showVonNeumannEntropy">Show von Neumann Entropy</label>
           <label><input type='checkbox' datavar="HM_showConcurrence">Show Concurrence</label>
           <label><input type='checkbox' datavar="HM_showCorrelation">Show Correlation</label>
       </blockquote>
       <label><input type='radio' name="radioGroup4" datavar="HM_cellContents" datavarvalue="HM_RECT_GLYPHS">rectangle glyphs</label>
   </blockquote>
</blockquote>

State Vectors
<blockquote>
   <!-- <label><input type='checkbox' datavar="showStateVectorsPerLayer">▶Show state vectors per layer</label> <br/> -->
   <label><input type='checkbox' datavar="allowMultipleColumns">Enable wrapping (multiple columns) within each state vector</label>
   <label><input type='checkbox' datavar="displayOutsideBitstring">Show bitstrings outside cells</label>
   <br/>
   Show cells as ...
   <blockquote>
       <label><input type='radio' name="radioGroup2" datavar="cell_aspectRatio" datavarvalue="CELL_ASPECTRATIO_SQUARE">squares</label><br/>
       <label><input type='radio' name="radioGroup2" datavar="cell_aspectRatio" datavarvalue="CELL_ASPECTRATIO_RECTANGULAR">rectangles</label>
       <blockquote>
           <label><input type='checkbox' datavar="displayInsideBitstring">Show bitstrings inside cells</label>
           <label><input type='checkbox' datavar="displayInsideProbability">Show probabilities inside cells</label>
       </blockquote>
   </blockquote>
   The length of the bar in each cell is<br/>
   <blockquote>
       <label><input type='radio' name="radioGroup3" datavar="barFunction" datavarvalue="BARFUNCTION_PROBABILITY">proportional to probability</label><br/>
       <label><input type='radio' name="radioGroup3" datavar="barFunction" datavarvalue="BARFUNCTION_MAGNITUDE">proportional to magnitude of amplitude</label><br/>
       <label><input type='radio' name="radioGroup3" datavar="barFunction" datavarvalue="BARFUNCTION_LOG_PROBABILITY">linear function of log<sub>2</sub> of probability</label><br/>
   </blockquote>
</blockquote>

Visualizations Per Layer
<span id='g2e'>[<a href="javascript:toggleDisplay(g2,g2e,g2c)">Show...</a>]</span>
<span id='g2c' style="display:none">[<a href="javascript:toggleDisplay(g2,g2e,g2c)">Hide</a>]</span>
<blockquote>
   <span id='g2' style="display:none">
   <label><input type='checkbox' datavar="showVisOfAllLayers">Show all layers</label> <br/>
   <label><input type='checkbox' datavar="scrollPerLayerVisHorizontally">Scroll horizontally when mouse hovers over circuit</label> <br/>
   Show difference visualization on<br/>
   <blockquote>
       <label><input type='radio' name="radioGroup1" datavar="show_diffvis" datavarvalue="DIFFVIS_NONE">no layers</label><br/>
       <label><input type='radio' name="radioGroup1" datavar="show_diffvis" datavarvalue="DIFFVIS_ONE">one layer</label><br/>
       <label><input type='radio' name="radioGroup1" datavar="show_diffvis" datavarvalue="DIFFVIS_ALL">all layers</label><br/>
   </blockquote>
   </span>
</blockquote>

</blockquote>

<br/>

</div> <!-- displayOptions -->


Export options:
<span id='g3e'>[<a href="javascript:toggleDisplay(g3,g3e,g3c)">Show...</a>]</span>
<span id='g3c' style="display:none">[<a href="javascript:toggleDisplay(g3,g3e,g3c)">Hide</a>]</span>

<blockquote>
    <span id='g3' style="display:none">
    Export to Quirk:
    <blockquote>
    <a id="quirkLink" href="">View this circuit in Quirk</a>
    (some gates may be omitted or not work)
    </blockquote>

    Export to IBM:

    <blockquote>

    <a href="https://quantum.cloud.ibm.com/composer">Open IBM Quantum Composer</a> <!-- previously https://quantum.ibm.com/composer/ -->
    <br/>
    OpenQASM code that you can paste into IBM Quantum Composer to get the same circuit (note that not all gates are supported by IBM Quantum Composer):
    <br/>
    <pre id="qasmText"></pre>
    <button id="copyQASMButton">Copy OpenQASM code</button>
    (some gates may be omitted or not work)

    </blockquote>

    </span>
</blockquote>




<p>
Predefined circuits:
<span id='g4e'>[<a href="javascript:toggleDisplay(g4,g4e,g4c)">Show...</a>]</span>
<span id='g4c' style="display:none">[<a href="javascript:toggleDisplay(g4,g4e,g4c)">Hide</a>]</span>

<blockquote>
    <span id='g4' style="display:none">
    Bell states [<a href="https://en.wikipedia.org/wiki/Bell_state">reference</a>] <br/>
        <blockquote>
            There are four Bell states: Φ+, Φ-, Ψ+, Ψ-.
            The first three are called triplet states.
            Consider <a href='?circuit={"cols":[["H"],["•","X"]]}'>this circuit</a> that generates a Φ+ state
            whose qubits are maximally correlated.
            How does the correlation between the qubits change if we
            <a href='?circuit={"cols":[["H"],["•","X"],["X^¼","X^¼"]]}'>add X<sup>0.25</sup></a> gates at the end of both qubits?
            And what if we
            <a href='?circuit={"cols":[["H"],["•","X"],["X^¼","X^¼"],["X^¼","X^¼"]]}'>do that again</a>?
            <br/>
            Now try <a href='?circuit={"cols":[["H","X"],["•","X"],[1,"Z"]]}'>this circuit</a> that generates a Ψ- state, also called a singlet state.
            How does the correlation between the qubits change if we
            add X<sup>0.25</sup> gates at the end of both qubits?
        </blockquote>
    <a href='?circuit={"cols":[["H"],["•","X"],[1,"•","X"]]}'>GHZ state</a> [<a href="https://en.wikipedia.org/wiki/Greenberger%E2%80%93Horne%E2%80%93Zeilinger_state">reference</a>] <br/>
    <a href='?circuit={"cols":[["H"],["•","X"],[1,"•","X"],[1,1,"•","X"]]}'>GHZ-4 state</a> <br/>
    <a href='?circuit={"cols":[["H",1,"Y^¼","X"],["•","X"],[1,"•","X"],[1,1,"•","X"]]}'>Variant of GHZ-4</a> <br/>
    <a href='?circuit={%22cols%22:[[{%22id%22:%22Ryft%22,%22arg%22:%221.9106332362490184%22}],[%22%E2%80%A2%22,%22H%22],[1,%22%E2%80%A2%22,%22X%22],[%22%E2%80%A2%22,%22X%22],[%22X%22]]}'>W state</a> [<a href="https://en.wikipedia.org/wiki/W_state">reference</a>] <br/>
    <a href='?circuit={"cols":[["H",1,1,"H"],["•","X",1,"•"],["X",1,1,"X"],["•",1,"X","•"],["X",1,"•"],[1,1,"•","X"]]}'>W-4 state</a> adapted from <a href="https://quantumcomputing.stackexchange.com/questions/4350/general-construction-of-w-n-state">here</a>  <br/>
    <a href='?circuit={"cols":[["H","Y^¼"],["•","X"],["Y^¼"],["•","X"]]}'>partial entanglement followed by partial disentanglement (1)</a> <br/>
    <a href='?circuit={"cols":[["H",1,"Y^¼"],["•","X"],[1,"•","X"],[1,1,"•","X"],[1,"•","X"]]}'>partial entanglement followed by partial disentanglement (2)</a> <br/>
    <a href='?circuit={"cols":[["Y^¼"],["•",1,"X"],["H"],[1,"X","•"],[1,1,"X"],[1,"H","•"],[1,1,"X"],["•","X","•"],[1,1,"X"],["•",1,"•","X"],[1,"•","•",1,"X"]]}'>variant of Werner state</a> based on Figure A1 in <a href="https://scholar.google.com/scholar?q=Bell+Diagonal+and+Werner+State+Generation+Entanglement+Non-Locality+Steering+and+Discord+on+the+IBM+Quantum+Computer">Riedel Garding et al. 2021</a><br/>
    <a href='?circuit={"cols":[["Y^¼","Y^¼","Y^¼","Y^¼","Y^¼","Y^¼"]]}'>circuit generating |H>^(⊗6) magic state</a> with SSRE magic 2.490<br/>
    <a href='?circuit={%22cols%22:[[{%22id%22:%22Y^ft%22,%22arg%22:%220.3040867239846964%22},{%22id%22:%22Y^ft%22,%22arg%22:%220.3040867239846964%22},{%22id%22:%22Y^ft%22,%22arg%22:%220.3040867239846964%22},{%22id%22:%22Y^ft%22,%22arg%22:%220.3040867239846964%22},{%22id%22:%22Y^ft%22,%22arg%22:%220.3040867239846964%22},{%22id%22:%22Y^ft%22,%22arg%22:%220.3040867239846964%22}],[{%22id%22:%22Z^ft%22,%22arg%22:%220.25%22},{%22id%22:%22Z^ft%22,%22arg%22:%220.25%22},{%22id%22:%22Z^ft%22,%22arg%22:%220.25%22},{%22id%22:%22Z^ft%22,%22arg%22:%220.25%22},{%22id%22:%22Z^ft%22,%22arg%22:%220.25%22},{%22id%22:%22Z^ft%22,%22arg%22:%220.25%22}]]}'>circuit generating |T>^(⊗6) magic state</a> with SSRE 3.510<br/>
    <a href='?circuit={%22cols%22:[[{%22id%22:%22Ryft%22,%22arg%22:%220.9553166181245093%22},{%22id%22:%22Ryft%22,%22arg%22:%220.9553166181245093%22},{%22id%22:%22Ryft%22,%22arg%22:%220.9553166181245093%22},{%22id%22:%22Ryft%22,%22arg%22:%220.9553166181245093%22},{%22id%22:%22Ryft%22,%22arg%22:%220.9553166181245093%22},{%22id%22:%22Ryft%22,%22arg%22:%220.9553166181245093%22}],[{%22id%22:%22Rzft%22,%22arg%22:%220.7853981633974483%22},{%22id%22:%22Rzft%22,%22arg%22:%220.7853981633974483%22},{%22id%22:%22Rzft%22,%22arg%22:%220.7853981633974483%22},{%22id%22:%22Rzft%22,%22arg%22:%220.7853981633974483%22},{%22id%22:%22Rzft%22,%22arg%22:%220.7853981633974483%22},{%22id%22:%22Rzft%22,%22arg%22:%220.7853981633974483%22}]]}'>alternative circuit generating |T>^(⊗6) magic state</a> with SSRE 3.510<br/>

    <a href='?circuit={"cols":[["H","H","H","H","H","H"],["•","Z^¼"],[1,"•","Z^¼"],[1,1,"•","Z^¼"],[1,1,1,"•","Z^¼"],[1,1,1,1,"•","Z^¼"]]}'>circuit with cascading CT gates</a> with SSRE magic 2.848<br/>
    <a href='?circuit={"cols":[["H","H","H","H","H","H"],["•","•","Z"],[1,1,1,"•","•","Z"],[1,"•","•","Z"],["Z",1,1,1,"•","•"],[1,1,"•","•","Z"],["•","Z",1,1,1,"•"]]}'>circuit with cyclic CCZ gates</a> with SSRE magic 3.696<br/>
    <a href='?circuit={"cols":[["H","H","H","H","H","H"],["•","•","Z^¼"],[1,1,1,"•","•","Z^¼"],[1,"•","•","Z^¼"],["Z^¼",1,1,1,"•","•"],[1,1,"•","•","Z^¼"],["•","Z^¼",1,1,1,"•"],["•","•","Z^¼"],[1,1,1,"•","•","Z^¼"],[1,"•","•","Z^¼"],["Z^¼",1,1,1,"•","•"],[1,1,"•","•","Z^¼"],["•","Z^¼",1,1,1,"•"],["•","•","Z^¼"],[1,1,1,"•","•","Z^¼"],[1,"•","•","Z^¼"],["Z^¼",1,1,1,"•","•"],[1,1,"•","•","Z^¼"],["•","Z^¼",1,1,1,"•"]]}'>circuit with cyclic CCT gates</a> with SSRE magic 3.920<br/>

    Different ways to implement Grover's algorithm. Each one shows 1 or 2 layers that initialize, then the oracle, then the diffusion operator. Challenge: show that these are all equivalent.
        <blockquote>
        <a href='?circuit={"cols":[["H","H","H","H"],["•","◦","•","Z"],["H","H","H","H"],[1,1,1,"X"],["◦","◦","◦","Z"],[1,1,1,"X"],["H","H","H","H"]]}'>Grover example 1</a><br/>
        <a href='?circuit={"cols":[["H","H","H","H"],["•","◦","•","Z"],["H","H","H","H"],["X","X","X","X"],["•","•","•","Z"],["X","X","X","X"],["H","H","H","H"]]}'>Grover example 2</a><br/>
        <a href='?circuit={"cols":[["H","H","H","H"],["•","◦","•","Z"],["H","H","H","H"],["X","X","X","X"],[1,1,1,"H"],["•","•","•","X"],[1,1,1,"H"],["X","X","X","X"],["H","H","H","H"]]}'>Grover example 3</a><br/>
        <a href='?circuit={"cols":[["X","X","X","X"],["H"],[1,"H"],[1,1,"H"],[1,1,1,"H"],["•","◦","•","Z"],["H"],[1,"H"],[1,1,"H"],["•","•","•","X"],[1,1,"H"],[1,"H"],["H"]]}'>Grover example 4</a><br/>
        </blockquote>

    Puzzles:
        <blockquote>
        Design a circuit that entangles, and then disentangles, two qubits.
            <blockquote>
            <a href='?circuit={"cols":[["H"],["•","X"],["•","X"]]}'>example 1</a> <br/>
            <a href='?circuit={"cols":[["H"],["•","X"],["X","•"]]}'>example 2</a> <br/>
            </blockquote>
        Design a circuit that only <em>partially</em> entangles two qubits.
            <blockquote>
            <a href='?circuit={"cols":[["H","Y^¼"],["•","X"]]}'>example 1</a> <br/>
            <a href='?circuit={"cols":[["H"],["•","Y^¼"]]}'>example 2</a> <br/>
            <a href='?circuit={"cols":[["X^½","X^½"],["•","Z^½"]]}'>example 3</a> <br/>
            </blockquote>
        Design a circuit on 2 qubits, using as few gates as possible, that results in the 4 base states (00, 01, 10, 11) having 4 distinct probabilities. <br/>
            <blockquote>
            <a href='?circuit={"cols":[["X^¼","X^¼"],["Y^¼"]]}'>candidate solution 1</a> <br/>
            <a href='?circuit={"cols":[["H"],["•","Y^¼"]]}'>candidate solution 2</a> <br/>
            </blockquote>
        Design a circuit that results in some of the base states having probabilities that follow a geometric sequence, for example,
            a base state with probability 50%, another with a probability of 25%, another with 12.5%, etc.
            <blockquote>
            <a href='?circuit={"cols":[["H"],["•","H"],[1,"•","H"],[1,1,"•","H"]]}'>candidate solution</a><br/>
            </blockquote>
        Design a circuit on 4 qubits that results in the same amplitude on all 16 base states,
        except for one base state whose phase is opposite to the others.
        This opposing phase, in effect, "tags" the base state as different from the others, and can simulate an oracle in Grover's algorithm.
            <blockquote>
            First, do this for the state 1111, so its phase is opposite all the others,
            but all amplitudes have the same magnitude.
                <a href='?circuit={"cols":[["H","H","H","H"],["•","•","•","Z"]]}'>candidate solution 1</a>,
                <a href='?circuit={"cols":[["H","H","H","H"],["•","Z","•","•"]]}'>candidate solution 2</a>,
                <a href='?circuit={"cols":[["H","H","H","H"],[1,1,1,"H"],["•","•","•","X"],[1,1,1,"H"]]}'>candidate solution 3</a>
                <br/>
            Then modify the circuit so that state 1011 has its phase opposite all the others.
                <a href='?circuit={"cols":[["H","H","H","H"],["•","•","◦","Z"]]}'>candidate solution 1</a>,
                <a href='?circuit={"cols":[["H","H","H","H"],["•","Z","◦","•"]]}'>candidate solution 2</a>,
                <a href='?circuit={"cols":[["H","H","H","H"],[1,1,"X"],["•","•","•","Z"],[1,1,"X"]]}'>candidate solution 3</a>
                <br/>
            Then try to do it for 0100.
                <a href='?circuit={"cols":[["H","H","H","H"],["◦","◦","Z","◦"]]}'>candidate solution 1</a>
                <br/>
            Then try for 0000.
                <a href='?circuit={"cols":[["H","H","H","H"],["Z","◦","◦","◦"],["X"]]}'>candidate solution 1</a>
                <br/>
            </blockquote>
        Design circuits to produce examples of each of the states in the set {pure, partially mixed, maximally mixed}×{product state, separable, partially entangled, maximally entangled}<br/>
        </blockquote>
    </span>
</blockquote>

<p>
<a href="https://github.com/MJMcGuffin/muqcs.js?tab=readme-ov-file#matrix-definitions">List of definitions of matrices</a> for quantum gates








<br/>

<br/>



SIMPLE_INCLUDE muqcs.js



<!----- START: web analytics via https://www.goatcounter.com/ , to log visits, without tracking personal info ----->

<script>
    window.goatcounter = {
        path: function(p) {
            // remove everything after the substring
            let substring = "?circuit=";
            let index = p.indexOf(substring);
            if (index !== -1) {
                p = p.slice(0, index + substring.length);
            }
            // prepend with the domain name
            return location.host + p;
        }
    }
</script>
<script data-goatcounter="https://mjmcguffin.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>

<!----- END: web analytics ----->



<script language="JavaScript">


// ============================================================
// Vec2 objects are for storing 2D points and 2D vectors.
// To create a new instance, use the new keyword:
//    let vector_a = new Vec2();
//    let vector_b = new Vec2(x,y);
// These objects are mutable. After an instance has been created,
// its coordinates can be changed by writing directly to data members:
//    vector_a.x = 10;
//    vector_a.y = -2;
// ============================================================
class Vec2 {
    constructor(x=0,y=0) {
        this.x = x;
        this.y = y;
    }

    // Performs a deep copy.
    copy(other) {
        this.x = other.x; this.y = other.y;
    }

    // Returns the negation of the vector.
    negate() { return new Vec2(-this.x,-this.y); }

    // Returns the Euclidean length (also called magnitude or L2-norm) of the vector.
    norm() { return Math.sqrt( this.x*this.x + this.y*this.y ); }

    // Returns the squared length.
    // This is useful when the caller needs to compare
    // the length of a vector to a pre-defined threshold,
    // or compare the lengths of two vectors:
    // in such cases, comparing the squared length is sufficient,
    // and saves a square root operation.
    normSquared() { return this.x*this.x + this.y*this.y; }

    // Returns a normalized vector of unit length.
    normalize() {
        let n = this.norm();
        if ( n > 0 ) {
            let k = 1.0/n;
            return new Vec2( k*this.x, k*this.y );
        }
        return new Vec2();
    }

    angle() {
        let lengthSquared = this.x*this.x + this.y*this.y;
        if ( lengthSquared === 0 ) return 0;
        let sine = Math.abs( this.y/Math.sqrt( lengthSquared ) );
        let theta = ( sine >= 1 ) ? Math.PI/2 : Math.asin( sine );
        if ( this.x < 0 ) theta = Math.PI - theta;
        if ( this.y < 0 ) theta = - theta;
        return theta;
    }
    setAngle( theta ) {
        let delta_theta = theta - this.angle();
        let sine = Math.sin( delta_theta );
        let cosine = Math.cos( delta_theta );
        let rotatedX = this.x * cosine - this.y * sine;
        let rotatedY = this.x * sine + this.y * cosine;
        this.x = rotatedX;
        this.y = rotatedY;
    }

    // A static method that returns the sum of two vectors.
    static sum( v1, v2 ) {
        return new Vec2( v1.x+v2.x, v1.y+v2.y );
    }

    // A static method that returns the difference of two vectors.
    static diff( v1, v2 ) {
        return new Vec2( v1.x-v2.x, v1.y-v2.y );
    }
    // A static method that returns the product of a vector with a scalar.
    static mult( v, k ) {
        return new Vec2( k*v.x, k*v.y );
    }
    // A static method that returns the dot product of two vectors
    static dot( v1, v2 ) {
        return v1.x*v2.x + v1.y*v2.y;
    }
    // A static method that returns the centroid of two vectors
    static average( v1, v2 ) {
        return new Vec2( (v1.x+v2.x)*0.5, (v1.y+v2.y)*0.5 );
    }
    // Returns the centroid of an array of vectors
    static centroid( listOfPoints ) {
        let x = 0;
        let y = 0;
        let N = listOfPoints.length;
        for ( let i = 0; i < N; i ++ ) {
            x += listOfPoints[i].x;
            y += listOfPoints[i].y;
        }
        return new Vec2( x/N, y/N );
    }

    static distance( v1, v2 ) {
        let dx = v1.x - v2.x;
        let dy = v1.y - v2.y;
        return Math.sqrt( dx*dx + dy*dy );
    }
    static distanceSquared( v1, v2 ) {
        let dx = v1.x - v2.x;
        let dy = v1.y - v2.y;
        return dx*dx + dy*dy;
    }
}

// ============================================================
// Box2 objects are for storing 2D axis-aligned rectangles.
// To create a new instance, use the new keyword:
//    let box_a = new Box2();
//    let box_b = new Box2(new Vec2(-10,-10),new Vec2(10,10));
// ============================================================

class Box2 {
    constructor( vec2_min = null, vec2_max = null ) {
        // Internally, the min and max points are diagonally opposite,
        // and are only valid if isEmpty===false.
        // Below, we initialize things based on what the client passed in.

        this.isEmpty = true;
        this.min = new Vec2();
        this.max = new Vec2();
        if ( vec2_min !== null && vec2_max !== null ) {
            this.boundPoint( vec2_min );
            this.boundPoint( vec2_max );
        }
    }
    clear() { this.isEmpty = true; this.min = new Vec2(); this.max = new Vec2(); }
    center() { return Vec2.average(this.min,this.max); }
    diagonal() { return Vec2.diff(this.max,this.min); }
    width() { return this.max.x - this.min.x; }
    height() { return this.max.y - this.min.y; }

    containsPoint( q ) {
        return !( this.isEmpty || q.x < this.min.x || q.x > this.max.x || q.y < this.min.y || q.y > this.max.y );
    }
    containsBox( b ) {
        if ( this.isEmpty ) return false;
        if ( b.isEmpty ) return true;
        return this.min.x <= b.min.x && b.max.x <= this.max.x && this.min.y <= b.min.y && b.max.y <= this.max.y;
    }

    // Returns true if there is any overlap with the given rectangle
    overlapsBox( b ) {
        if ( this.isEmpty || b.isEmpty ) return false;
        return ! (
            b.max.x < this.min.x
            || b.min.x > this.max.x
            || b.max.y < this.min.y
            || b.min.y > this.max.y
        );
    }

    // Enlarges the box enough to contain the given point
    boundPoint( vec2 ) {
        if ( this.isEmpty ) {
            this.isEmpty = false;
            this.min.copy( vec2 );
            this.max.copy( vec2 );
        }
        else {
            if ( vec2.x < this.min.x ) this.min.x = vec2.x;
            else if ( vec2.x > this.max.x ) this.max.x = vec2.x;

            if ( vec2.y < this.min.y ) this.min.y = vec2.y;
            else if ( vec2.y > this.max.y ) this.max.y = vec2.y;
        }
    }
    boundPoints( points ) {
        for ( let i = 0; i < points.length; ++i ) {
            this.boundPoint( points[i] );
        }
    }

    // Enlarges the box enough to contain the given box
    boundBox( box ) {
        if ( ! box.isEmpty ) {
            this.boundPoint( box.min );
            this.boundPoint( box.max );
        }
    }

    // Find the intersection with the given box and save the result.
    intersectBox( b ) {
        if ( this.isEmpty ) return;
        if ( b.isEmpty ) {
            clear();
            return;
        }
        this.min.x = Math.max( this.min.x, b.min.x );
        this.min.y = Math.max( this.min.y, b.min.y );
        this.max.x = Math.min( this.max.x, b.max.x );
        this.max.y = Math.min( this.max.y, b.max.y );
        if ( this.min.x > this.max.x || this.min.y > this.max.y ) {
            this.clear();
        }
    }
}


// ============================================================
// Draw2 objects are for managing the transformation between
// pixel space and a 2D world space, allowing a client to pan and zoom.
// The objects also manage the drawing of simple shapes on a canvas,
// allowing a client to pass in coordinates in either space
// (pixel space or world space).
// To create a new instance, use the new keyword:
//    let draw2 = new Draw2(canvas);
// ============================================================


// TD_ prefix means Text Direction
const TD_HORIZONTALLY_RIGHT = 0;
const TD_VERTICALLY_DOWN = 1;


class Draw2 {
    static PIXELS = "pixels";
    static WORLD = "world";


    constructor(canvas) {
        this.canvas = canvas;
        this.canvas_context = canvas.getContext("2d");
        this.canvasWidth_pixels = canvas.width;
        this.canvasHeight_pixels = canvas.height;
        this.offsetX_pixels = 0;
        this.offsetY_pixels = 0;
        this.scaleFactorInWorldSpaceUnitsPerPixel = 1.0; // greater if user is more zoomed out
        this.setFont(this.canvas_context.font);
        this.coordinateSystem = Draw2.PIXELS;
        this.resetWorldTransformation();
    }
    setFont(fontName/*Example: 'italic 27px Calibri'*/) {
        this.canvas_context.font = fontName;
        this.fontHeight = parseInt(this.canvas_context.font.match(/\d+/)[0],10);
    }
    setFontHeight( fontHeight /*in pixels*/ ) {
        this.canvas_context.font = fontHeight.toString() + "px sans-serif";
        this.fontHeight = parseInt(this.canvas_context.font.match(/\d+/)[0],10);
    }
    convertPixelsToWorldSpaceUnitsX( x_pixels ) {
        return ( x_pixels - this.offsetX_pixels )*this.scaleFactorInWorldSpaceUnitsPerPixel;
    }
    convertPixelsToWorldSpaceUnitsY( y_pixels ) {
        return ( y_pixels - this.offsetY_pixels )*this.scaleFactorInWorldSpaceUnitsPerPixel;
    }
    convertPixelsToWorldSpaceUnits( p_pixels ) {
        return new Vec2(
            ( p_pixels.x - this.offsetX_pixels )*this.scaleFactorInWorldSpaceUnitsPerPixel,
            ( p_pixels.y - this.offsetY_pixels )*this.scaleFactorInWorldSpaceUnitsPerPixel
        );
    }

    convertWorldSpaceUnitsToPixelsX( x_world ) {
        return x_world / this.scaleFactorInWorldSpaceUnitsPerPixel + this.offsetX_pixels;
    }
    convertWorldSpaceUnitsToPixelsY( y_world ) {
        return y_world / this.scaleFactorInWorldSpaceUnitsPerPixel + this.offsetY_pixels;
    }
    convertWorldSpaceUnitsToPixels( p_world ) {
        return new Vec2(
            p_world.x / this.scaleFactorInWorldSpaceUnitsPerPixel + this.offsetX_pixels,
            p_world.y / this.scaleFactorInWorldSpaceUnitsPerPixel + this.offsetY_pixels
        );
    }


    translate( deltaX_pixels, deltaY_pixels ) {
        this.offsetX_pixels += deltaX_pixels;
        this.offsetY_pixels += deltaY_pixels;
    }
    zoomIn(
        zoomFactor // greater than 1 to zoom in, between 0 and 1 to zoom out
    ) {
        let centerX_pixels = this.canvasWidth_pixels * 0.5;
        let centerY_pixels = this.canvasHeight_pixels * 0.5;
        this.scaleFactorInWorldSpaceUnitsPerPixel /= zoomFactor;
        this.offsetX_pixels = centerX_pixels - (centerX_pixels - this.offsetX_pixels) * zoomFactor;
        this.offsetY_pixels = centerY_pixels - (centerY_pixels - this.offsetY_pixels) * zoomFactor;
    }




    // Causes the zoom and translation to be adjusted to fit the given rectangle within the canvas
    frameWithinCanvasRegion(
        rect, // an instance of Box2; the rectangle (in world space) to frame
        expand, // true if caller wants a margin of whitespace added around the rect
        region_x,region_y, // pixel coordinates of upper left corner of region within the canvas
        region_w, region_h // dimensions in pixels
    ) {
        if ( rect.isEmpty || rect.diagonal().x === 0 || rect.diagonal().y === 0 ) {
            return;
        }
        if ( expand ) {
            let diagonal = rect.diagonal().norm() / 50;
            let v = new Vec2( diagonal, diagonal );
            rect = new Box2( Vec2.diff(rect.min,v), Vec2.sum(rect.max,v) );
        }
        if ( rect.width() / rect.height() >= region_w / region_h ) {
            // The rectangle to frame is wider (or shorter) than the region of the canvas,
            // so the limiting factor is the width of the rectangle.
            this.offsetX_pixels = - rect.min.x * region_w / rect.width() + region_x;
            this.scaleFactorInWorldSpaceUnitsPerPixel = rect.width() / region_w;
            this.offsetY_pixels = region_h/2 - rect.center().y / this.scaleFactorInWorldSpaceUnitsPerPixel + region_y;
        }
        else {
            // The limiting factor is the height of the rectangle.
            this.offsetY_pixels = - rect.min.y * region_h / rect.height() + region_y;
            this.scaleFactorInWorldSpaceUnitsPerPixel = rect.height() / region_h;
            this.offsetX_pixels = region_w/2 - rect.center().x / this.scaleFactorInWorldSpaceUnitsPerPixel + region_x;
        }
    }
    frameWithinEntireCanvas(
        rect, // an instance of Box2; the rectangle (in world space) to frame
        expand // true if caller wants a margin of whitespace added around the rect
    ) {
        this.frameWithinCanvasRegion(rect,expand,0,0,this.canvasWidth_pixels,this.canvasHeight_pixels);
    }

    translateToEnclose( targetRect ) {
        let canvasRect_world = new Box2(
            this.convertPixelsToWorldSpaceUnits(
                new Vec2( 0, 0 )
            ),
            this.convertPixelsToWorldSpaceUnits(
                new Vec2( this.canvasWidth_pixels, this.canvasHeight_pixels )
            )
        );
        if (canvasRect_world.containsBox(targetRect)) {
            // The target is already within the canvas
            return;
        }
        let canvasCenter_world = canvasRect_world.center();
        let targetCenter_world = targetRect.center();
        let d1 = Vec2.diff( targetCenter_world, canvasCenter_world );
        let d1_length = d1.norm();
        let canvas_halfDiagonal = Vec2.mult( canvasRect_world.diagonal(), 0.5 );
        let target_halfDiagonal = Vec2.mult( targetRect.diagonal(), 0.5 );
        if (
            target_halfDiagonal.x > canvas_halfDiagonal.x
            || target_halfDiagonal.y > canvas_halfDiagonal.y
        ) {
            // The target is too big to fit in the canvas without zooming out,
            // so just center the target in the canvas
            // by applying the d1 translation.
            this.offsetX_pixels -= d1.x / this.scaleFactorInWorldSpaceUnitsPerPixel;
            this.offsetY_pixels -= d1.y / this.scaleFactorInWorldSpaceUnitsPerPixel;
            return;
        }
        let distanceToTranslate = 0;
        let candidateDistance = 0;
        if ( d1.x < 0 ) {
            // Find distance to translate toward -x, using similar triangles.
            // Larger triangle's hypotenuse / base = smaller triangle's hypotenuse / base
            // d1_length / (-d1.x) = candidateDistance / (-d1.x-(canvas_halfDiagonal.x - target_halfDiagonal.x))
            candidateDistance = d1_length / (-d1.x) * (-d1.x-(canvas_halfDiagonal.x - target_halfDiagonal.x));
            if ( candidateDistance > distanceToTranslate ) {
                distanceToTranslate = candidateDistance;
            }
        }
        else if ( d1.x > 0 ) {
            // Find distance to translate toward +x, using similar triangles.
            // Larger triangle's hypotenuse / base = smaller triangle's hypotenuse / base
            // d1_length / (d1.x) = candidateDistance / (d1.x-(canvas_halfDiagonal.x - target_halfDiagonal.x))
            candidateDistance = d1_length / (d1.x) * (d1.x-(canvas_halfDiagonal.x - target_halfDiagonal.x));
            if ( candidateDistance > distanceToTranslate ) {
                distanceToTranslate = candidateDistance;
            }
        }
        if ( d1.y < 0 ) {
            // Find distance to translate toward -y, using similar triangles.
            // Larger triangle's hypotenuse / base = smaller triangle's hypotenuse / base
            // d1_length / (-d1.y) = candidateDistance / (-d1.y-(canvas_halfDiagonal.y - target_halfDiagonal.y))
            candidateDistance = d1_length / (-d1.y) * (-d1.y-(canvas_halfDiagonal.y - target_halfDiagonal.y));
            if ( candidateDistance > distanceToTranslate ) {
                distanceToTranslate = candidateDistance;
            }
        }
        else if ( d1.y > 0 ) {
            // Find distance to translate toward +y, using similar triangles.
            // Larger triangle's hypotenuse / base = smaller triangle's hypotenuse / base
            // d1_length / (d1.y) = candidateDistance / (d1.y-(canvas_halfDiagonal.y - target_halfDiagonal.y))
            candidateDistance = d1_length / (d1.y) * (d1.y-(canvas_halfDiagonal.y - target_halfDiagonal.y));
            if ( candidateDistance > distanceToTranslate ) {
                distanceToTranslate = candidateDistance;
            }
        }

        // Scale d1 to have length distanceToTranslate
        d1 = Vec2.mult( d1.normalize(), distanceToTranslate );

        // Apply the d1 translation.
        this.offsetX_pixels -= d1.x / this.scaleFactorInWorldSpaceUnitsPerPixel;
        this.offsetY_pixels -= d1.y / this.scaleFactorInWorldSpaceUnitsPerPixel;
    }


    resize(
        w, h // the new canvas dimensions, in pixels
    ) {
        let oldCenter = this.convertPixelsToWorldSpaceUnits( new Vec2(
            this.canvasWidth_pixels * 0.5, this.canvasHeight_pixels * 0.5
        ) );
        let radius = Math.min( this.canvasWidth_pixels, this.canvasHeight_pixels ) * 0.5 * this.scaleFactorInWorldSpaceUnitsPerPixel;

        this.canvasWidth_pixels = w;
        this.canvasHeight_pixels = h;

        if ( radius > 0 ) {
            this.frameWithinEntireCanvas(
                new Box2(
                    new Vec2( oldCenter.x - radius, oldCenter.y - radius ),
                    new Vec2( oldCenter.x + radius, oldCenter.y + radius )
                ),
                false
            );
        }
    }

    setCoordinateSystemToPixels() {
        this.coordinateSystem = Draw2.PIXELS;
    }
    setCoordinateSystemToWorldSpaceUnits() {
        this.coordinateSystem = Draw2.WORLD;
    }

    setWorldTransformation( /* Vec2 */ translation, scale, angle /*in radians*/ ) {
        this.hasWorldTransform = true;
        this.worldTransform_translation.copy( translation );
        this.worldTransform_scale = scale;
        this.worldTransform_angle = angle;
        this.worldTransform_sine = Math.sin( angle );
        this.worldTransform_cosine = Math.cos( angle );
        //console.log( "transforming with " + scale + "," + angle + ", " + this.worldTransform_sine );
    }
    resetWorldTransformation() {
        this.hasWorldTransform = false;
        this.worldTransform_translation = new Vec2();
        this.worldTransform_scale = 1.0;
        this.worldTransform_angle = 0;
    }
    applyTransformation( x, y ) {
        let rotatedX = x * this.worldTransform_cosine - y * this.worldTransform_sine;
        let rotatedY = x * this.worldTransform_sine + y * this.worldTransform_cosine;
        let p = Vec2.sum( Vec2.mult( new Vec2( rotatedX, rotatedY ), this.worldTransform_scale ), this.worldTransform_translation );
        //console.log("apply " + x + "," + y + "; ; " + p.x + ", " + p.y + ", " + this.worldTransform_sine + ", " + this.worldTransform_cosine + " , " + this.worldTransform_scale + ", " + this.worldTransform_translation.x + ", " + this.worldTransform_translation.y );
        return p;
    }


    setStrokeColor_array( array ) {
        this.setStrokeColor(array[0],array[1],array[2],array[3]);
    }
    setStrokeColor(
        red, green, blue, // between 0 and 255
        alpha=1.0 // between 0.0 and 1.0
    ) {
        if ( alpha === 1.0 )
            this.canvas_context.strokeStyle = "rgb("+red+","+green+","+blue+")";
        else
            this.canvas_context.strokeStyle = "rgba("+red+","+green+","+blue+","+alpha+")";
    }
    setFillColor_array( array ) {
        this.setFillColor(array[0],array[1],array[2],array[3]);
    }
    setFillColor(
        red, green, blue, // between 0 and 255
        alpha=1.0 // between 0.0 and 1.0
    ) {
        if ( alpha === 1.0 )
            this.canvas_context.fillStyle = "rgb("+red+","+green+","+blue+")";
        else
            this.canvas_context.fillStyle = "rgba("+red+","+green+","+blue+","+alpha+")";
    }
    setLineWidth( lw ) {
        this.canvas_context.lineWidth = lw;
    }
    clear(
        red, green, blue // between 0 and 255
    ) {
        this.setFillColor(red,green,blue);
        this.canvas_context.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
    drawLine( x1, y1, x2, y2 ) {
        if ( this.coordinateSystem === Draw2.WORLD ) {
            //console.log("drawLine " + x1 + "," + y1 + ",  " + x2 + "," + y2 );
            if ( this.hasWorldTransform ) {
                // console.log("drawLine " + x1 + "," + y1 + ",  " + x2 + "," + y2 );
                let p = this.applyTransformation(x1,y1);
                x1 = p.x;
                y1 = p.y;
                p = this.applyTransformation(x2,y2);
                x2 = p.x;
                y2 = p.y;
            }
            //console.log("drawLine " + x1 + "," + y1 + ",  " + x2 + "," + y2 );
            x1 = this.convertWorldSpaceUnitsToPixelsX( x1 );
            y1 = this.convertWorldSpaceUnitsToPixelsY( y1 );
            x2 = this.convertWorldSpaceUnitsToPixelsX( x2 );
            y2 = this.convertWorldSpaceUnitsToPixelsY( y2 );
        }

        this.canvas_context.beginPath();
        this.canvas_context.moveTo(x1,y1);
        this.canvas_context.lineTo(x2,y2);
        this.canvas_context.stroke();
    }
    drawRect( x, y, w, h, isFilled=false ) {
        if ( w < 0 ) {
            w = -w;
            x -= w;
        }
        if ( h < 0 ) {
            h = -h;
            y -= h;
        }
        if ( this.coordinateSystem === Draw2.WORLD ) {
            if ( this.hasWorldTransform ) {
                let p = this.applyTransformation(x,y);
                x = p.x;
                y = p.y;
            }
            x = this.convertWorldSpaceUnitsToPixelsX( x );
            y = this.convertWorldSpaceUnitsToPixelsY( y );
            w /= this.scaleFactorInWorldSpaceUnitsPerPixel;
            h /= this.scaleFactorInWorldSpaceUnitsPerPixel;
        }
        if ( isFilled ) this.canvas_context.fillRect( x, y, w, h );
        else this.canvas_context.strokeRect( x, y, w, h );
    }
    fillRect( x, y, w, h ) {
        this.drawRect(x,y,w,h,true);
    }
    drawCircle( x_center, y_center, radius, isFilled=false ) {
        if ( this.coordinateSystem === Draw2.WORLD ) {
            x_center = this.convertWorldSpaceUnitsToPixelsX( x_center );
            y_center = this.convertWorldSpaceUnitsToPixelsY( y_center );
            radius /= this.scaleFactorInWorldSpaceUnitsPerPixel;
        }
        this.canvas_context.beginPath();
        this.canvas_context.arc(x_center, y_center, radius, 0, 2 * Math.PI, false);
        if ( isFilled ) this.canvas_context.fill();
        else this.canvas_context.stroke();
    }
    drawArc( x_center, y_center, radius, startAngle /*radians*/, endAngle /*radians*/, isFilled=false ) {
        if ( this.coordinateSystem === Draw2.WORLD ) {
            x_center = this.convertWorldSpaceUnitsToPixelsX( x_center );
            y_center = this.convertWorldSpaceUnitsToPixelsY( y_center );
            radius /= this.scaleFactorInWorldSpaceUnitsPerPixel;
        }
        this.canvas_context.beginPath();
        if ( isFilled ) this.canvas_context.moveTo(x_center,y_center);
        this.canvas_context.arc(x_center, y_center, radius, startAngle, endAngle, startAngle > endAngle /*counterclockwise*/);
        if ( isFilled ) this.canvas_context.fill();
        else this.canvas_context.stroke();
    }
    fillCircle( x_center, y_center, radius ) {
        this.drawCircle( x_center, y_center, radius, true );
    }
    drawPolyline( points, isFilled=false, isClosed=false ) {
        if ( points.length <= 1 )
            return;
        let x;
        let y;
        this.canvas_context.beginPath();
        x = points[0].x;
        y = points[0].y;
        if ( this.coordinateSystem === Draw2.WORLD ) {
            x = this.convertWorldSpaceUnitsToPixelsX( x );
            y = this.convertWorldSpaceUnitsToPixelsY( y );
        }
        this.canvas_context.moveTo(x,y);
        for ( let i = 1; i < points.length; ++i ) {
            x = points[i].x;
            y = points[i].y;
            if ( this.coordinateSystem === Draw2.WORLD ) {
                x = this.convertWorldSpaceUnitsToPixelsX( x );
                y = this.convertWorldSpaceUnitsToPixelsY( y );
            }
            this.canvas_context.lineTo(x,y);
        }
        if ( isClosed ) this.canvas_context.closePath();
        if ( isFilled ) this.canvas_context.fill();
        else this.canvas_context.stroke();
    }
    drawPolygon( points, isFilled=false ) {
        this.drawPolyline( points, isFilled, true );
    }
    fillPolygon( points ) {
        this.drawPolyline( points, true, true );
    }

    drawArrowHead(
        x, y, // the tip of the arrow
        direction_x,direction_y, // a vector; its length doesn't matter
        arrowHeadLength,
        isFilled = true,
        isStroked = true
    ) {
        // scale the direction vector to have the appropriate length
        let forwardVector = Vec2.mult( new Vec2(direction_x,direction_y).normalize(), arrowHeadLength );

        let tip = new Vec2( x, y );
        let back = Vec2.diff( tip, forwardVector );
        let lateralVector = new Vec2( forwardVector.y / 2, - forwardVector.x / 2 );
        let side1 = Vec2.diff( back, lateralVector );
        let side2 = Vec2.sum( back, lateralVector );
        if ( isFilled )
            this.drawPolygon( [ tip, side1, side2 ], true );
        if ( isStroked )
            this.drawPolygon( [ tip, side1, side2 ], false );
    }
    drawArithmeticOperator(
        x, y, // center
        diameter,
        symbol,
        isFilled = true,
        isStroked = true
    ) {
        let radius = diameter/2;
        let r2 = radius * 0.65;
        if ( isFilled )
            this.fillCircle( x, y, radius );
        if ( isStroked )
            this.drawCircle( x, y, radius );
        if ( symbol === "+" || symbol === "-" ) {
            this.drawLine( x-r2, y, x+r2, y );
        }
        if ( symbol === "+" ) {
            this.drawLine( x, y-r2, x, y+r2 );
        }
    }

    // TODO warning: I haven't bothered to make this handle rotations in the worldTransform
    // properly.  This would require rotating, but not translating, the tangent vectors,
    // and this could be done by transforming the control points.
    drawSpline(
        x1,y1, x2,y2, // endpoints
        tangent1x,tangent1y, tangent2x,tangent2y, // vectors; their length doesn't matter
        weight1, weight2, // determine how strongly the curve is influenced, after scaling by distance between the endpoints
        maxLateralExtent
    ) {
        let endpoint1 = new Vec2(x1,y1);
        let endpoint2 = new Vec2(x2,y2);
        let distanceBetweenEndpoints = Vec2.distance( endpoint1, endpoint2 );
        let t1 = Vec2.mult( new Vec2(tangent1x,tangent1y).normalize(), distanceBetweenEndpoints*weight1 );
        let t2 = Vec2.mult( new Vec2(tangent2x,tangent2y).normalize(), distanceBetweenEndpoints*weight2 );
        // control points
        let cp1x = x1 + t1.x;
        let cp1y = y1 + t1.y;
        let cp2x = x2 + t2.x;
        let cp2y = y2 + t2.y;

        if ( maxLateralExtent !== undefined ) {
            /*
                A point P(t) on a cubic bezier curve, where t is in [0,1], is given by
                    P(t) = (1-t)^3 (x1,y1) + 3(1-t)^2 t (cp1x,cp1y) + 3(1-t)t^2 (cp2x,cp2y) + t^3 (x2,y2)
                Setting t=0.5 yields
                    P(0.5) = (1/8) (x1,y1) + (3/8) (cp1x,cp1y) + (3/8) (cp2x,cp2y) + (1/8) (x2,y2)
            */
            let midpoint = Vec2.average( endpoint1, endpoint2 );
            let midcurve = new Vec2(
                ( x1 + 3*cp1x + 3*cp2x + x2 ) / 8,
                ( y1 + 3*cp1y + 3*cp2y + y2 ) / 8
            );
            let lateralExtent = Vec2.distance( midpoint, midcurve );
            if ( lateralExtent > maxLateralExtent ) {
                // The curve will extend laterally too far, so break it up into two smaller curves

                // Move the control points closer to the endpoints
                weight1 *= maxLateralExtent/lateralExtent;
                weight2 *= maxLateralExtent/lateralExtent;
                t1 = Vec2.mult( new Vec2(tangent1x,tangent1y).normalize(), distanceBetweenEndpoints*weight1 );
                t2 = Vec2.mult( new Vec2(tangent2x,tangent2y).normalize(), distanceBetweenEndpoints*weight2 );
                // recomputing the control points for the original endpoints
                cp1x = x1 + t1.x;
                cp1y = y1 + t1.y;
                cp2x = x2 + t2.x;
                cp2y = y2 + t2.y;
            }
        }

        if ( this.coordinateSystem === Draw2.WORLD ) {
            /*
            if ( this.hasWorldTransform ) {
                let p = this.applyTransformation(x1,y1);
                x1 = p.x;
                y1 = p.y;
                p = this.applyTransformation(x2,y2);
                x2 = p.x;
                y2 = p.y;
                ... need to also transform the control points
            }
            */
            endpoint1 = this.convertWorldSpaceUnitsToPixels( endpoint1 );
            endpoint2 = this.convertWorldSpaceUnitsToPixels( endpoint2 );
            cp1x = this.convertWorldSpaceUnitsToPixelsX( cp1x );
            cp1y = this.convertWorldSpaceUnitsToPixelsY( cp1y );
            cp2x = this.convertWorldSpaceUnitsToPixelsX( cp2x );
            cp2y = this.convertWorldSpaceUnitsToPixelsY( cp2y );
        }
        this.canvas_context.beginPath();
        this.canvas_context.moveTo( endpoint1.x,endpoint1.y );
        this.canvas_context.bezierCurveTo( cp1x,cp1y,cp2x,cp2y, endpoint2.x,endpoint2.y );
        this.canvas_context.stroke();
    }

    // returns the width of a string, in pixels
    stringWidth( s ) {
        if ( s.length === 0 ) return 0;
        return this.canvas_context.measureText(s).width;
    }

    // draws the given string using the current fill color
    drawString(
        x, y,  // left extremity of the baseline of the string (near the lower-left corner of the string)
        s,     // the string
        height, // the desired height
        direction // TD_HORIZONTALLY_RIGHT or TD_VERTICALLY_DOWN
    ) {
        if ( s.length === 0 ) return;
        //this.canvas_context.textBaseline = 'alphabetic';
        this.canvas_context.textBaseline = 'bottom';
        this.canvas_context.textAlign = 'start';
        if ( this.coordinateSystem === Draw2.WORLD ) {
            x = this.convertWorldSpaceUnitsToPixelsX( x );
            y = this.convertWorldSpaceUnitsToPixelsY( y );
            height /= this.scaleFactorInWorldSpaceUnitsPerPixel;
        }
        this.canvas_context.save();
        this.canvas_context.translate( x, y );
        let scaleFactor = height / this.fontHeight;
        this.canvas_context.scale( scaleFactor, scaleFactor );
        if ( direction === TD_VERTICALLY_DOWN ) {
            this.canvas_context.rotate(Math.PI/2);
        }
        this.canvas_context.fillText( s, 0, 0 );
        this.canvas_context.restore();
    }
    drawStringCenteredInRectangle(
        rect, // the bounding rect; the text is scaled to fit in this
        s,  // the string
        margin, // a fraction of the width or height; 0.0 for none
        direction, // TD_HORIZONTALLY_RIGHT or TD_VERTICALLY_DOWN

        // highlighting is done using a rectangle drawn in the current stroke color
        indexOfStartOfSubstringToHighlight = 0, // 0 for first char
        lengthOfSubstringToHighlight = 0 // 0 for none
    ) {
        if ( s.length === 0 ) return;
        if ( indexOfStartOfSubstringToHighlight < 0 || indexOfStartOfSubstringToHighlight >= s.length )
            lengthOfSubstringToHighlight = 0;

        let rect2 = rect;
        if ( this.coordinateSystem === Draw2.WORLD ) {
            rect2 = new Box2(
                this.convertWorldSpaceUnitsToPixels( rect.min ),
                this.convertWorldSpaceUnitsToPixels( rect.max )
            );
        }
        let textW = this.stringWidth( s );
        let textW_beforeSubstring = 0;
        let textW_untilEndOfSubstring = 0;
        if ( lengthOfSubstringToHighlight > 0 ) {
            textW_beforeSubstring = this.stringWidth( s.substring( 0, indexOfStartOfSubstringToHighlight ) );
            textW_untilEndOfSubstring = this.stringWidth( s.substring( 0, indexOfStartOfSubstringToHighlight + lengthOfSubstringToHighlight ) );
        }
        let textH = this.fontHeight;
        let textAspectRatio = textW / textH;
        let rectW = rect2.width();
        let rectH = rect2.height();
        let rectAspectRatio = rectW / rectH;
        this.canvas_context.textBaseline = 'middle';
        this.canvas_context.textAlign = 'center';
        let scaleFactor = 1;
        if ( direction === TD_HORIZONTALLY_RIGHT ) {
            if ( rectAspectRatio < textAspectRatio ) { // bounding rect is more tall and skinny than text
                scaleFactor = rectW / textW * (1-margin);
            }
            else { // bounding rect is more wide and short than text
                scaleFactor = rectH / textH * (1-margin);
            }
        }
        else if ( direction === TD_VERTICALLY_DOWN ) {
            textAspectRatio = 1 / textAspectRatio;
            if ( rectAspectRatio < textAspectRatio ) { // bounding rect is more tall and skinny than text
                scaleFactor = rectW / textH * (1-margin);
            }
            else { // bounding rect is more wide and short than text
                scaleFactor = rectH / textW * (1-margin);
            }
        }
        this.canvas_context.save();
        let center = rect2.center();
        this.canvas_context.translate( center.x, center.y );
        this.canvas_context.scale( scaleFactor, scaleFactor );
        if ( direction === TD_VERTICALLY_DOWN ) {
            this.canvas_context.rotate(Math.PI/2);
        }
        this.canvas_context.fillText( s, 0, 0 );
        if ( lengthOfSubstringToHighlight > 0 ) {
            this.canvas_context.strokeRect( -textW/2+textW_beforeSubstring, -textH/2, textW_untilEndOfSubstring-textW_beforeSubstring, textH );
        }
        this.canvas_context.restore();
    }

    drawImage( image, x, y, w, h ) {
        if ( this.coordinateSystem === Draw2.WORLD ) {
            if ( this.hasWorldTransform ) {
                let p = this.applyTransformation(x,y);
                x = p.x;
                y = p.y;
            }
            x = this.convertWorldSpaceUnitsToPixelsX( x );
            y = this.convertWorldSpaceUnitsToPixelsY( y );
            w /= this.scaleFactorInWorldSpaceUnitsPerPixel;
            h /= this.scaleFactorInWorldSpaceUnitsPerPixel;
        }
        this.canvas_context.drawImage(image, x, y, w, h );
    }
}



// ============================================================

// Creates an array filled with the given initialValue
let create1DArray = function( numElements, initialValue ) {
    let array = [];
    if ( initialValue === null ) {
        for ( let i = 0; i < numElements; i++ ) {
            array.push(null);
        }
    }
    else if ( typeof(initialValue) === 'object' ) {
        if ( initialValue instanceof Array ) {
            for ( let i = 0; i < numElements; i++ ) {
                array.push([...initialValue]);
            }
        }
        else {
            for ( let i = 0; i < numElements; i++ ) {
                array.push({...initialValue});
            }
        }
    }
    else {
        for ( let i = 0; i < numElements; i++ ) {
            array.push(initialValue);
        }
    }
    return array;
}

// Creates a 2D array filled with the given initialValue
let create2DArray = function( numColumns, numRows, initialValue ) {
    let array = [];
    if ( initialValue === null ) {
        for ( let c = 0; c < numColumns; c++ ) {
            array.push([]);
            for ( let r = 0; r < numRows; r++ ) {
                array[c].push(null);
            }
        }
    }
    else if ( typeof(initialValue) === 'object' ) {
        if ( initialValue instanceof Array ) {
            for ( let c = 0; c < numColumns; c++ ) {
                array.push([]); // adds an empty 1D array at the end of "array"
                for ( let r = 0; r < numRows; r++ ) {
                    array[c].push([...initialValue]); // added at end of the 1D array "array[c]"
                }
            }
        }
        else {
            for ( let c = 0; c < numColumns; c++ ) {
                array.push([]); // adds an empty 1D array at the end of "array"
                for ( let r = 0; r < numRows; r++ ) {
                    array[c].push({...initialValue}); // added at end of the 1D array "array[c]"
                }
            }
        }
    }
    else {
        for ( let c = 0; c < numColumns; c++ ) {
            array.push([]); // adds an empty 1D array at the end of "array"
            for ( let r = 0; r < numRows; r++ ) {
                array[c].push(initialValue); // added at end of the 1D array "array[c]"
            }
        }
    }


    return array;
}

// ============================================================


// ================================ FRONTEND

const SUPPRESS_GATES_THAT_DONT_WORK = false;

// The prefix CP means CircuitPart, which could be a gate, or part of a gate (like half a swap), or a control bit.
const CP_EMPTY = -1;
const CP_I = 0; // identity
const CP_CB = 1; // control bit
const CP_ACB = 2; // anticontrol bit
const CP_H = 3; // hadamard
const CP_X = 4; // NOT
const CP_Y = 5;
const CP_Z = 6;
const CP_SX = 7; // "SX" means "Square root of X"
const CP_SY = 8; // "SY" means "Square root of Y"
const CP_SZ = 9; // "SZ" means "Square root of Z"
const CP_SSX = 10; // "SSX" means "Square root of Square root of X", or in other words, fourth root of X
const CP_SSY = 11; // "SSY" means "Square root of Square root of Y", or in other words, fourth root of Y
const CP_SSZ = 12; // "SSZ" means "Square root of Square root of Z", or in other words, fourth root of Z
const CP_invSX = 13; // "inv" means inverse
const CP_invSY = 14;
const CP_invSZ = 15;
const CP_invSSX = 16;
const CP_invSSY = 17;
const CP_invSSZ = 18;
const CP_SWAP = 19;
const CP_XE = 20;
const CP_YE = 21;
const CP_ZE = 22;
const CP_RX = 23;
const CP_RY = 24;
const CP_RZ = 25;
const CP_GP = 26;
const CP_PH = 27;
const CP_ZG = 28;
const CP_YG = 29;
const CP_HG = 30;
const CP_NUM = SUPPRESS_GATES_THAT_DONT_WORK ? 20 : 31;

class Icon {
    constructor(
        circuitPart_id,
        name, // string
        tooltip, // string
        isParametric, // boolean
        parametersAreInDegrees, // boolean
        matrix, // a 2x2 complex matrix; only for gates that *are* parametric, and hence have a fixed matrix

        // A function that takes one or more parameters and returns a 2x2 complex matrix; only for parametric gates.
        parametricFunctionToGenerateMatrix,

        // Only for parametric gates.
        // An array of objects of the form {
        //    name: ...,
        //    defaultValue: ...,
        //    minValue: ...,
        //    maxValue: ...,
        //    dragIncrement: ...,
        //    snapIncrement: ...
        // }
        paramInfo,

        // This is not provided to the constructor
        // ,imageSource
    ) {
        this.circuitPart_id = circuitPart_id;
        this.name = name;
        this.tooltip = tooltip;
        this.isParametric = isParametric;
        this.parametersAreInDegrees = parametersAreInDegrees;
        this.matrix = matrix;
        this.parametricFunctionToGenerateMatrix = parametricFunctionToGenerateMatrix;
        this.paramInfo = paramInfo;
        this.numParameters = paramInfo.length;

        this.image = new Image();

        // We don't do this in the constructor, because it would cause
        // the image to load asynchronously in a different thread,
        // so it's better for the client to do this using a Promise
        // so the client can be informed when the image is loaded and ready.
        // this.image.src = imageSource;
    }
    circuitPartFactory() {
        let cp = new CircuitPart();
        cp.parentIcon = this;
        cp.paramValues = [ ];
        for ( let i = 0; i < this.numParameters; ++i ) {
            cp.paramValues[ i ] = this.paramInfo[ i ].defaultValue;
        }
        return cp;
    }
};

let icons = [];
let icon_promises = [];

function appendToIcons(
    circuitPart_id,
    name,
    tooltip,
    isParametric,
    parametersAreInDegrees,
    matrix,
    parametricFunctionToGenerateMatrix,
    paramInfo,
    imageSource
) {
    let icon = new Icon( circuitPart_id, name, tooltip, isParametric, parametersAreInDegrees, matrix, parametricFunctionToGenerateMatrix, paramInfo );
    icons.push( icon );
    Util.assert( icons.length-1 === circuitPart_id, "appendToIcons(): invalid index" );
    icon_promises.push( new Promise( function(resolve,reject) {
        icon.image.onload = resolve;
        icon.image.onerror = reject;
        icon.image.src = imageSource;
    } ) );
}

const imageSourcePrefix = "data:image/png;base64,";

appendToIcons(
    CP_I, "I", "Identity", false, false, Sim.I, null, [],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-I.txt
);
appendToIcons(
    CP_CB, "Control bit", "Control bit", false, false, null, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-controlbit.txt
);
appendToIcons(
    CP_ACB, "Anticontrol bit", "Anticontrol bit", false, false, null, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-anticontrolbit.txt
);
appendToIcons(
    CP_H, "H", "Hadamard", false, false, Sim.H, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-H.txt
);
appendToIcons(
    CP_X, "X", "Pauli X; also called NOT", false, false, Sim.X, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-X.txt
);
appendToIcons(
    CP_Y, "Y", "Pauli Y", false, false, Sim.Y, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-Y.txt
);
appendToIcons(
    CP_Z, "Z", "Pauli Z = Phase(pi)", false, false, Sim.Z, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-Z.txt
);
appendToIcons(
    CP_SX, "X^0.5", "X^0.5; also called V", false, false, Sim.SX, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-SX.txt
);
appendToIcons(
    CP_SY, "Y^0.5", "Y^0.5", false, false, Sim.SY, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-SY.txt
);
appendToIcons(
    CP_SZ, "Z^0.5", "Z^0.5; also called S = Phase(pi/2)", false, false, Sim.SZ, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-SZ.txt
);
appendToIcons(
    CP_SSX, "X^0.25", "X^0.25", false, false, Sim.SSX, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-SSX.txt
);
appendToIcons(
    CP_SSY, "Y^0.25", "Y^0.25", false, false, Sim.SSY, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-SSY.txt
);
appendToIcons(
    CP_SSZ, "Z^0.25", "Z^0.25; also called T = Phase(pi/4)", false, false, Sim.SSZ, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-SSZ.txt
);
appendToIcons(
    CP_invSX, "X^-0.5", "X^-0.5; also called V^-1", false, false, Sim.invSX, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-invSX.txt
);
appendToIcons(
    CP_invSY, "Y^-0.5", "Y^-0.5", false, false, Sim.invSY, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-invSY.txt
);
appendToIcons(
    CP_invSZ, "Z^-0.5", "Z^-0.5; also called S^-1 = Phase(-pi/2)", false, false, Sim.invSZ, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-invSZ.txt
);
appendToIcons(
    CP_invSSX, "X^-0.25", "X^-0.25", false, false, Sim.invSSX, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-invSSX.txt
);
appendToIcons(
    CP_invSSY, "Y^-0.25", "Y^-0.25", false, false, Sim.invSSY, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-invSSY.txt
);
appendToIcons(
    CP_invSSZ, "Z^-0.25", "Z^-0.25; also called T^-1 = Phase(-pi/4)", false, false, Sim.invSSZ, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-invSSZ.txt
);
appendToIcons(
    CP_SWAP, "Swap", "Swap", false, false, null, null, [ ],
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-SWAP.txt
);

if ( ! SUPPRESS_GATES_THAT_DONT_WORK ) {

const exponentParamInfo = [{name:"k", defaultValue:0, minValue:-2, maxValue:2, dragIncrement:0.01, snapIncrement:0.125}];
const singleAngleParamInfo = [{name:"angle", defaultValue:0, minValue:-360, maxValue:360, dragIncrement:1, snapIncrement:22.5}];
const twoAngleParamInfo = [{name:"angle1", defaultValue:0, minValue:-360, maxValue:360, dragIncrement:1, snapIncrement:22.5},  {name:"angle2", defaultValue:0, minValue:-360, maxValue:360, dragIncrement:1, snapIncrement:22.5}];

appendToIcons(
    CP_XE, "X^k", "Pauli X exponential", true, false, null, Sim.XE, exponentParamInfo,
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-XE.txt
);
appendToIcons(
    CP_YE, "Y^k", "Pauli Y exponential", true, false, null, Sim.YE, exponentParamInfo,
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-YE.txt
);
appendToIcons(
    CP_ZE, "Z^k", "Pauli Z exponential; Z^k = Phase(k pi)", true, false, null, Sim.ZE, exponentParamInfo,
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-ZE.txt
);
appendToIcons(
    CP_RX, "Rx", "Rotation around X", true, true, null, Sim.RX, singleAngleParamInfo,
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-RX.txt
);
appendToIcons(
    CP_RY, "Ry", "Rotation around Y", true, true, null, Sim.RY, singleAngleParamInfo,
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-RY.txt
);
appendToIcons(
    CP_RZ, "Rz", "Rotation around Z", true, true, null, Sim.RZ, singleAngleParamInfo,
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-RZ.txt
);
appendToIcons(
    CP_GP, "GP", "Global Phase", true, true, null, Sim.GlobalPhase, singleAngleParamInfo,
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-GP.txt
);
appendToIcons(
    CP_PH, "Ph", "Phase(theta) = Z^(theta/pi)", true, true, null, Sim.Phase, singleAngleParamInfo,
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-Ph.txt
);
appendToIcons(
    CP_ZG, "Z_G", "Generalized Z", true, true, null, Sim.Z_G, twoAngleParamInfo,
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-ZG.txt
);
appendToIcons(
    CP_YG, "Y_G", "Generalized Y", true, true, null, Sim.Y_G, twoAngleParamInfo,
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-YG.txt
);
appendToIcons(
    CP_HG, "H_G", "Generalized Hadamard", true, true, null, Sim.H_G, twoAngleParamInfo,
    imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-HG.txt
);

}

let empty_icon_image = new Image();
icon_promises.push( new Promise( function(resolve,reject) {
    empty_icon_image.onload = resolve;
    empty_icon_image.onerror = reject;
    empty_icon_image.src = imageSourcePrefix+
SIMPLE_INCLUDE icons/icon-empty.txt
;
} ) );

let areAllImagesLoaded = false;

Promise.all( icon_promises ).then(
    function() {
        allImagesLoadedCallback();
    }
).catch(
    function( error ) { console.error("Error loading images:", error); }
);



const PARAMETRIC_GATE_MARGIN = 0.13;



// These are instantiated inside Icon.circuitPartFactory()
// They contain these data members:
//     parentIcon // a reference to an instance of Icon
//     paramValues // an array of values
class CircuitPart {
    getCircuitPartID() {
        return this.parentIcon.circuitPart_id;
    }
    getName() {
        //if ( this.parentIcon.isParametric ) {
        //    let s = "";
        //    for ( let i = 0; i < this.paramValues.length; ++i ) {
        //        if ( i > 0 )
        //            s += ",";
        //        s += StringUtil.numToString( this.paramValues[i] );
        //    }
        //    return this.parentIcon.name + '(' + s + ')';
        //}
        return this.parentIcon.name;
    }
    getTooltip() {
        return this.parentIcon.tooltip;
    }
    getImage() {
        return this.parentIcon.image;
    }
    isParametric() {
        return this.parentIcon.isParametric;
    }
    getMatrix() {
        if ( this.parentIcon.isParametric ) {
            return this.parentIcon.parametricFunctionToGenerateMatrix.apply( null, this.paramValues );
        }
        return this.parentIcon.matrix;
    }
    getNumParameters() {
        return this.parentIcon.numParameters;
    }
    getMargin() { // used for drawing the gate
        return PARAMETRIC_GATE_MARGIN;
    }
    getHeightOfParameterString() { // used for drawing the gate
        let numLinesOfText = this.parentIcon.numParameters + 1;
        if ( numLinesOfText < 3 ) numLinesOfText = 3;
        return (1-2*PARAMETRIC_GATE_MARGIN) / numLinesOfText;
    }
    // returns rectangle in the world space
    getBoundingRectOfParameterString( i /* index of parameter */, origin /* of gate, in world space */) {
        let h = this.getHeightOfParameterString();
        let x0 = origin.x + PARAMETRIC_GATE_MARGIN;
        let y0 = origin.y + PARAMETRIC_GATE_MARGIN+(1+i)*h;
        return new Box2(
            new Vec2( x0, y0 ),
            new Vec2( origin.x + 1 - PARAMETRIC_GATE_MARGIN, y0 + h )
        );
    }
    getParameterAsString( i ) {
        let s = StringUtil.numToString( this.paramValues[i], 3 );
        if ( this.parentIcon.parametersAreInDegrees )
            s += "°";
        return s;
    }
    getParamInfo( i ) {
        return this.parentIcon.paramInfo[ i ];
    }
}



class Circuit {
    constructor() {
        this.MIN_WIRES = 1;
        this.MAX_WIRES = 16;
        this.MIN_STAGES = 1;
        this.MAX_STAGES = 32;

        this.initializeToEmpty();
        //this.cells = [];
        //for ( let w = 0; w < this.numWires; ++w ) {
        //    this.cells[ w ] = [];
        //    for ( let s = 0; s < this.numStages; ++s ) {
        //        this.cells[w][s] = null;
        //    }
        //}
    }
    initializeToEmpty( desiredNumWires = this.MIN_WIRES, desiredNumStages = this.MIN_STAGES ) {
        this.numWires = desiredNumWires;
        this.numStages = desiredNumStages;
        this.cells = create2DArray( this.numWires, this.numStages, null );
        this.stateVectors = [];
        this.stateVectorsAndStatsAreDirty = true;
    }
    clear() {
        this.initializeToEmpty();
    }
    isCellEmpty(w,s) {
        if ( w === this.numWires ) return true;
        Util.assert( 0 <= w && w < this.numWires && 0 <= s && s < this.numStages, "isCellEmpty(): invalid index" );
        if ( w < 0 || w >= this.numWires || s < 0 || s >= this.numStages ) return true;
        if ( this.cells[w][s] !== null ) return false;
        return true;
    }
    isWireEmpty(w) {
        Util.assert( 0 <= w && w < this.numWires, "isWireEmpty(): invalid index" );
        if ( w < 0 || w >= this.numWires ) return true;
        for ( let s = 0; s < this.numStages; ++s ) {
            if ( this.cells[w][s] !== null ) return false;
        }
        return true;
    }
    isStageEmpty(s) {
        Util.assert( 0 <= s && s < this.numStages, "isStageEmpty(): invalid index" );
        if ( s < 0 || s >= this.numStages ) return true;
        for ( let w = 0; w < this.numWires; ++w ) {
            if ( this.cells[w][s] !== null ) return false;
        }
        return true;
    }
    numSwapPartsInStage(s) {
        Util.assert( 0 <= s && s < this.numStages, "numSwapPartsInStage(): invalid index" );
        if ( s < 0 || s >= this.numStages ) return 0;
        let returnValue = 0;
        for ( let w = 0; w < this.numWires; ++w ) {
            if ( this.getCircuitPartIDOfCell(w,s) === CP_SWAP ) returnValue ++;
        }
        return returnValue;
    }
    addWireAtEnd() {
        if ( this.numWires >= this.MAX_WIRES ) return;
        this.cells.push( create1DArray(this.numStages,null) );
        this.numWires ++;
        this.stateVectorsAndStatsAreDirty = true;
    }
    // inserts a stage before the given stage which can be in the range [0,numStages]
    insertStage(s) {
        Util.assert( 0 <= s && s <= this.numStages, "insertStage() invalid args" );
        if ( this.numStages >= this.MAX_STAGES ) return;
        for ( let w = 0; w < this.numWires; ++w ) {
            this.cells[w].splice( s, 0/*number of items to delete*/, null/*item to insert*/ );
        }
        this.numStages ++;
        this.stateVectorsAndStatsAreDirty = true;
    }
    addStageAtEnd() {
        this.insertStage( this.numStages );
    }
    removeWiresFromEnd( numWiresToRemove ) {
        let maxWiresThatCouldBeRemoved = this.numWires - this.MIN_WIRES;
        if ( numWiresToRemove > maxWiresThatCouldBeRemoved )
            numWiresToRemove = maxWiresThatCouldBeRemoved;
        if ( numWiresToRemove <= 0 ) return;
        this.cells.splice( this.numWires - numWiresToRemove, numWiresToRemove );
        this.numWires -= numWiresToRemove;
        this.stateVectorsAndStatsAreDirty = true;
    }
    removeStagesFromEnd( numStagesToRemove ) {
        let maxStagesThatCouldBeRemoved = this.numStages - this.MIN_STAGES;
        if ( numStagesToRemove > maxStagesThatCouldBeRemoved )
            numStagesToRemove = maxStagesThatCouldBeRemoved;
        if ( numStagesToRemove <= 0 ) return;
        for ( let w = 0; w < this.numWires; ++w ) {
            this.cells[w].splice( this.numStages - numStagesToRemove, numStagesToRemove );
        }
        this.numStages -= numStagesToRemove;
        this.stateVectorsAndStatsAreDirty = true;
    }
    removeAllEmptyWiresAtEnd() {
        let numWiresToRemove = 0;
        let w = this.numWires - 1;
        while ( w >= this.MIN_WIRES && this.isWireEmpty(w) ) {
            numWiresToRemove ++;
            w --;
        }
        this.removeWiresFromEnd( numWiresToRemove );
        this.stateVectorsAndStatsAreDirty = true;
    }
    copyStage(sourceStage,targetStage) {
        Util.assert(
            sourceStage !== targetStage
            && 0 <= sourceStage && sourceStage < this.numStages
            && 0 <= targetStage && targetStage < this.numStages,
            "copyStage(): invalid args"
        );
        if (
            sourceStage === targetStage
            || sourceStage < 0 || sourceStage >= this.numStages
            || targetStage < 0 || targetStage >= this.numStages
        )
            return;
        for ( let w = 0; w < this.numWires; ++w ) {
            this.cells[w][targetStage] = this.cells[w][sourceStage];
        }
        this.stateVectorsAndStatsAreDirty = true;
    }
    removeAllEmptyStages() {
        // find the first non-empty stage
        let targetStage = 0;
        let sourceStage = 0;
        while ( sourceStage < this.numStages && this.isStageEmpty( sourceStage ) ) {
            sourceStage ++;
        }
        while ( sourceStage < this.numStages ) {
            if ( targetStage < sourceStage ) {
                this.copyStage( sourceStage, targetStage );
                targetStage = sourceStage;
            }
            else {
                targetStage ++;
            }
            sourceStage ++;
            while ( sourceStage < this.numStages && this.isStageEmpty( sourceStage ) ) {
                sourceStage ++;
            }
        }
        this.removeStagesFromEnd( this.numStages - targetStage );
        this.stateVectorsAndStatsAreDirty = true;
    }
    compactify() {
        this.removeAllEmptyWiresAtEnd();
        this.removeAllEmptyStages();
        this.stateVectorsAndStatsAreDirty = true;
    }
    // Adds the given part at the given wire and stage, or before the given stage by inserting a new stage.
    // If the boolean flag is false, the part is added *at* the given stage,
    // overwriting whatever part may already be there.
    addCircuitPart(circuitPart,wire,stage,/*boolean*/insertBeforeTheGivenStage) {
        Util.assert(
            0 <= wire && wire < this.MAX_WIRES && 0 <= stage && stage <= this.numStages,
            "addCircuitPart() invalid args"
        );
        if ( wire < 0 || wire >= this.MAX_WIRES || stage < 0 || stage > this.numStages )
            return;
        if ( stage === this.numStages ) {
            this.addStageAtEnd();
        }
        else if ( insertBeforeTheGivenStage ) {
            this.insertStage( stage );
        }
        while ( wire >= this.numWires ) {
            this.addWireAtEnd();
        }
        this.cells[ wire ][ stage ] = circuitPart;
        this.stateVectorsAndStatsAreDirty = true;
    }
    getCellContents(wire,stage) {
        if ( wire < 0 || wire >= this.numWires || stage < 0 || stage >= this.numStages )
            return null;
        return this.cells[ wire ][ stage ];
    }
    getCircuitPartIDOfCell(wire,stage) {
        if ( wire < 0 || wire >= this.numWires || stage < 0 || stage >= this.numStages )
            return CP_EMPTY;
        if ( this.cells[ wire ][ stage ] === null )
            return CP_EMPTY;
        return this.cells[ wire ][ stage ].getCircuitPartID();
    }
    clearCell(wire,stage) {
        Util.assert(
            0 <= wire && 0 <= stage, "clearCell() invalid args"
        );
        if ( wire < 0 || wire >= this.numWires || stage < 0 || stage >= this.numStages )
            return;
        this.cells[ wire ][ stage ] = null;
        this.stateVectorsAndStatsAreDirty = true;
    }
    findFirstEmptyStageFollowedByOnlyEmptyStages() {
        let s = this.numStages;
        while ( s >= 1 && this.isStageEmpty(s-1) )
            s --;
        return s;
    }
    addGate(
        wire,
        circuitPart_id,
        listOfControlBits = [] // a list of pairs of the form [wire_index, flag] where 0<=wire_index<n and flag is true for a control bit and false for an anti-control bit
    ) {
        Util.assert( 0 <= wire, "addGate() invalid args" );
        if ( wire < 0 )
            return;
        let s = this.findFirstEmptyStageFollowedByOnlyEmptyStages();
        this.addCircuitPart( icons[ circuitPart_id ].circuitPartFactory(), wire, s, false );
        for ( let i=0; i < listOfControlBits.length; ++i ) {
            this.addCircuitPart( icons[ listOfControlBits[i][1] ? CP_CB : CP_ACB ].circuitPartFactory(), listOfControlBits[i][0], s, false );
        }
        this.stateVectorsAndStatsAreDirty = true;
    }
    addSwapGate( wire1, wire2 ) {
        Util.assert(
            0 <= wire1 && wire1 !== wire2 && 0 <= wire2,
            "addSwapGate() invalid args"
        );
        if ( wire1 < 0 || wire1 === wire2 || wire2 < 0 )
            return;
        let s = this.findFirstEmptyStageFollowedByOnlyEmptyStages();
        this.addCircuitPart( icons[ CP_SWAP ].circuitPartFactory(), wire1, s, false );
        this.addCircuitPart( icons[ CP_SWAP ].circuitPartFactory(), wire2, s, false );
        this.stateVectorsAndStatsAreDirty = true;
    }
    expandCircuit( useGeneralizedGates ) {

        let expandedListOfGatesForCircuit = [ ]; // array of {part:CircuitPart,stage:int,wire:int,listOfControlBits:[int],listOfAntiControlBits:[int]}
        let numStagesAfterExpansion = 0;
        // ---------- We need to construct expandedListOfGatesForCircuit and then convert it to a Circuit
        // ---------- for each layer in the circuit...
        for ( let s = 0; s < this.numStages; ++s ) {
            let listOfControlBits = [ ]; // ints of the wires
            let listOfAntiControlBits = [ ]; // ints of the wires
            let listOfSwapParts = [ ]; // ints of wires
            let listOfOtherParts = [ ]; // array of { part:CircuitPart, wire:int }

            // ---------- Make lists of things in this layer: control bits, swap gate parts, other parts
            for ( let w = 0; w < this.numWires; ++w ) {
                let circuitPart = this.cells[w][s];
                switch( this.getCircuitPartIDOfCell(w,s) ) {
                case CP_EMPTY:
                case CP_I:
                    break;
                case CP_CB:
                    listOfControlBits.push( w );
                    break;
                case CP_ACB:
                    listOfAntiControlBits.push( w );
                    break;
                case CP_SWAP:
                    listOfSwapParts.push( w );
                    break;
                default:
                    listOfOtherParts.push( { part:circuitPart, wire:w } );
                    break;
                }
            }
            // ---------- Add swap gate parts to the expanded list
            if ( listOfSwapParts.length > 0 ) {
                // add all the swap parts to the same stage of the expanded circuit
                for ( let j = 0; j < listOfSwapParts.length; ++j ) {
                    let w = listOfSwapParts[j];
                    expandedListOfGatesForCircuit.push( {
                        part: this.cells[w][s],
                        stage: numStagesAfterExpansion,
                        wire: w,
                        listOfControlBits: listOfControlBits.slice(),
                        listOfAntiControlBits: listOfAntiControlBits.slice()
                    } );
                }
                numStagesAfterExpansion ++;
            }
            // ---------- For each of the remaining parts in the layer, expand them as necessary
            for ( let j = 0; j < listOfOtherParts.length; ++j ) {
                let circuitPart = listOfOtherParts[j].part;
                let w = listOfOtherParts[j].wire;
                let expandedListOfPartsForOneGate = [ ]; // array of CircuitPart
                let circuitPartID = circuitPart.getCircuitPartID();
                let exponentParameter = 0;
                switch ( circuitPartID ) {
                // ---------- These ones don't need expanding:
                case CP_H:
                case CP_X:  case CP_Y:  case CP_Z:
                case CP_SZ:  case CP_invSZ:
                case CP_SSZ:  case CP_invSSZ:
                case CP_PH:  case CP_ZE:
                case CP_GP:
                case CP_ZG:  case CP_YG:  case CP_HG:
                    expandedListOfPartsForOneGate.push( circuitPart );
                    break;
                // ---------- These ones need expanding:
                case CP_SX:
                    if ( useGeneralizedGates ) {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                        let cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 1 ] = 90;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    else {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_SZ ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                    }
                    break;
                case CP_invSX:
                    if ( useGeneralizedGates ) {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                        let cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 1 ] = -90;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    else {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_invSZ ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                    }
                    break;
                case CP_SY:
                    if ( useGeneralizedGates ) {
                        let cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 45;
                        cp.paramValues[ 1 ] = (180+45);
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    else {
                        expandedListOfPartsForOneGate.push( icons[ CP_Z ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        let cp = icons[ CP_GP ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 45;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    break;
                case CP_invSY:
                    if ( useGeneralizedGates ) {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        let cp = icons[ CP_ZG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = -45;
                        cp.paramValues[ 1 ] = -(180+45);
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    else {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_Z ].circuitPartFactory() );

                        let cp = icons[ CP_GP ].circuitPartFactory();
                        cp.paramValues[ 0 ] = - 45;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    break;
                case CP_SSX:
                case CP_invSSX:
                case CP_XE:
                    if ( circuitPartID === CP_SSX )
                        exponentParameter = 0.25;
                    else if ( circuitPartID === CP_invSSX )
                        exponentParameter = -0.25;
                    else // circuitPartID === CP_XE
                        exponentParameter = circuitPart.paramValues[ 0 ];
                    if ( useGeneralizedGates ) {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        let cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 0;
                        cp.paramValues[ 1 ] = exponentParameter * 180;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    else {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        let cp = icons[ CP_ZE ].circuitPartFactory();
                        cp.paramValues[ 0 ] = exponentParameter;
                        expandedListOfPartsForOneGate.push( cp );

                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                    }
                    break;
                case CP_SSY:
                case CP_invSSY:
                case CP_YE:
                    if ( circuitPartID === CP_SSY )
                        exponentParameter = 0.25;
                    else if ( circuitPartID === CP_invSSY )
                        exponentParameter = -0.25;
                    else // circuitPartID === CP_YE
                        exponentParameter = circuitPart.paramValues[ 0 ];
                    if ( useGeneralizedGates ) {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        let cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 0;
                        cp.paramValues[ 1 ] = 90;
                        expandedListOfPartsForOneGate.push( cp );
                        cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 0;
                        cp.paramValues[ 1 ] = exponentParameter * 180;
                        expandedListOfPartsForOneGate.push( cp );
                        cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 0;
                        cp.paramValues[ 1 ] = - 90;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    else {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_SZ ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        let cp = icons[ CP_ZE ].circuitPartFactory();
                        cp.paramValues[ 0 ] = exponentParameter;
                        expandedListOfPartsForOneGate.push( cp );

                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_invSZ ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                    }
                    break;
                case CP_RX:
                    if ( useGeneralizedGates ) {
                        let cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = - circuitPart.paramValues[ 0 ] /2;
                        cp.paramValues[ 1 ] = - circuitPart.paramValues[ 0 ] /2;
                        expandedListOfPartsForOneGate.push( cp );
                        cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 0;
                        cp.paramValues[ 1 ] = circuitPart.paramValues[ 0 ];
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    else {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        let cp = icons[ CP_ZE ].circuitPartFactory();
                        cp.paramValues[ 0 ] = circuitPart.paramValues[ 0 ] / 180;
                        expandedListOfPartsForOneGate.push( cp );

                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        cp = icons[ CP_GP ].circuitPartFactory();
                        cp.paramValues[ 0 ] = - circuitPart.paramValues[ 0 ] /2;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    break;
                case CP_RY:
                    if ( useGeneralizedGates ) {
                        let cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = - circuitPart.paramValues[ 0 ] /2;
                        cp.paramValues[ 1 ] = - circuitPart.paramValues[ 0 ] /2;
                        expandedListOfPartsForOneGate.push( cp );
                        cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 0;
                        cp.paramValues[ 1 ] = 90;
                        expandedListOfPartsForOneGate.push( cp );
                        cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 0;
                        cp.paramValues[ 1 ] = circuitPart.paramValues[ 0 ];
                        expandedListOfPartsForOneGate.push( cp );
                        cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 0;
                        cp.paramValues[ 1 ] = - 90;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    else {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_SZ ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        let cp = icons[ CP_ZE ].circuitPartFactory();
                        cp.paramValues[ 0 ] = circuitPart.paramValues[ 0 ] / 180;
                        expandedListOfPartsForOneGate.push( cp );

                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_invSZ ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        cp = icons[ CP_GP ].circuitPartFactory();
                        cp.paramValues[ 0 ] = - circuitPart.paramValues[ 0 ] /2;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    break;
                case CP_RZ:
                    if ( useGeneralizedGates ) {
                        let cp = icons[ CP_ZG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = - circuitPart.paramValues[ 0 ] /2;
                        cp.paramValues[ 1 ] = circuitPart.paramValues[ 0 ] /2;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    else {
                        let cp = icons[ CP_ZE ].circuitPartFactory();
                        cp.paramValues[ 0 ] = circuitPart.paramValues[ 0 ] / 180;
                        expandedListOfPartsForOneGate.push( cp );
                        cp = icons[ CP_GP ].circuitPartFactory();
                        cp.paramValues[ 0 ] = - circuitPart.paramValues[ 0 ] /2;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    break;
                // ---------- We should not encounter these:
                case CP_SWAP:
                case CP_EMPTY:  case CP_I:
                case CP_CB:  case CP_ACB:
                default:
                    Util.assert( false, "unexpected condition in expandCircuit()" );
                    break;
                } // switch

                for ( let jj = 0; jj < expandedListOfPartsForOneGate.length; ++jj ) {
                    expandedListOfGatesForCircuit.push( {
                        part: expandedListOfPartsForOneGate[ jj ],
                        stage: numStagesAfterExpansion,
                        wire: w,
                        listOfControlBits: listOfControlBits.slice(),
                        listOfAntiControlBits: listOfAntiControlBits.slice()
                    } );
                    numStagesAfterExpansion ++;
                }
            } // for each other part

        } // for each layer

        // ---------- Now, expandedListOfGatesForCircuit is complete. Convert it to a Circuit.

        if ( numStagesAfterExpansion <= this.MAX_STAGES ) {
            this.initializeToEmpty( this.numWires, numStagesAfterExpansion );
            for ( let j = 0; j < expandedListOfGatesForCircuit.length; ++j ) {
                let x = expandedListOfGatesForCircuit[ j ];
                // x is an object with form {
                //     part:CircuitPart,
                //     stage:int,
                //     wire:int,
                //     listOfControlBits:[int], listOfAntiControlBits:[int]
                // }
                this.cells[ x.wire ][ x.stage ] = x.part;
                for ( let jj = 0; jj < x.listOfControlBits.length; ++jj ) {
                    this.cells[ x.listOfControlBits[ jj ] ][ x.stage ] = icons[ CP_CB ].circuitPartFactory();
                }
                for ( let jj = 0; jj < x.listOfAntiControlBits.length; ++jj ) {
                    this.cells[ x.listOfAntiControlBits[ jj ] ][ x.stage ] = icons[ CP_ACB ].circuitPartFactory();
                }
            }
        }
        else {
            Util.assert( false, `expandCircuit(): Expanded circuit would have ${numStagesAfterExpansion} layers, but the max is ${this.MAX_STAGES}` );
        }

        this.stateVectorsAndStatsAreDirty = true;
    }
    // Can be used to simulate forward or backward or both
    //     To simulate forward from the first state vector, the caller could do
    //         this.computeStateVectorsLayerByLayer( this.stateVectors, 0, this.numStages );
    //     To simulate back, and forward, from layer i, and store in alternative state vectors,
    //     the caller could do
    //         this.computeStateVectorsLayerByLayer( this.altStateVectors, i, 0 );
    //         this.computeStateVectorsLayerByLayer( this.altStateVectors, i, this.numStages );
    computeStateVectorsLayerByLayer(
        arrayOfStateVectors,
        startLayer, // between 0 and numStages; we assume the state vector for this layer is already computed
        endLayer  // between 0 and numStages; this is the last layer whose state vector is computed
    ) {
        Util.assert(
            0 <= startLayer && startLayer <= this.numStages && 0 <= endLayer && endLayer <= this.numStages,
            `unexpected condition in computeStateVectorsLayerByLayer(): ${startLayer},${endLayer},${this.numStages}`
        );
        let increment = ( endLayer >= startLayer ) ? +1 : -1;
        let s = startLayer; // index of state vector that is already known
        while ( true ) {
            let s2 = s + increment; // index of next state vector to compute
            let s3 = increment > 0 ? s : s2; // index of layer of circuit containing the gates that relate state vectors s and s2

            // From state vector s, we compute state vector s2, using the gates in layer s3 of the circuit
            if ( s === endLayer || s2 < 0 || s2 > this.numStages )
                break;

            arrayOfStateVectors[s2] = arrayOfStateVectors[s].copy();

            // Collect info about control bits and swap gate

            let listOfControlBits = []; // a list of pairs of the form [wire_index, flag] where 0<=wire_index<n and flag is true for a control bit and false for an anti-control bit
            let numSwapParts = 0;
            let min_w_of_swap_part = -1;
            let max_w_of_swap_part = -1;

            for ( let w = 0; w < this.numWires; ++w ) {
                let circuitPart_id = this.getCircuitPartIDOfCell(w,s3);
                if ( circuitPart_id >= 0 ) {
                    if ( circuitPart_id === CP_CB || circuitPart_id === CP_ACB ) {
                        listOfControlBits.push( circuitPart_id === CP_CB ? [w,true] : [w,false] );
                    }
                    else if ( circuitPart_id === CP_SWAP ) {
                        numSwapParts ++;
                        if ( numSwapParts === 1 )
                            min_w_of_swap_part = w;
                        max_w_of_swap_part = w;
                    }
                }
            }

            // Implement each gate, except for the swap gate
            for ( let w = 0; w < this.numWires; ++w ) {
                let circuitPart = this.cells[w][s3];
                let circuitPart_id = this.getCircuitPartIDOfCell(w,s3);
                if ( circuitPart_id >= 0 && circuitPart_id < CP_NUM ) {
                    if (
                        circuitPart_id !== CP_I
                        && circuitPart_id !== CP_CB
                        && circuitPart_id !== CP_ACB
                        && circuitPart_id !== CP_SWAP
                    ) {
                        let U = circuitPart.getMatrix();
                        if ( increment < 0 ) {
                            U = U.conjugateTranspose();
                        }
                        arrayOfStateVectors[s2] = Sim.qubitWiseMultiply(
                            U, w, this.numWires, arrayOfStateVectors[s2], listOfControlBits
                        );
                    }
                }
            }

            // Implement swap gate
            if ( numSwapParts === 2 ) {
                arrayOfStateVectors[s2] = Sim.applySwap(
                    min_w_of_swap_part, max_w_of_swap_part, this.numWires, arrayOfStateVectors[s2], listOfControlBits
                );
            }

            s = s2;
        } // while
    }
    // recomputes the state vectors for each stage
    run() {
        this.stateVectors = []; // delete contents of array
        this.perQubitStats = []; // delete contents of array
        this.stateVectors[0] = CMatrix.kronPower( Sim.ketZero, this.numWires );

        this.computeStateVectorsLayerByLayer( this.stateVectors, 0, this.numStages );

        let n = this.numWires;
        for ( let s = 0; s <= this.numStages; ++s ) {
            let SV = this.stateVectors[ s ];
            let arrayOfAll2x2ReducedDensityMatrices = Sim.computeAll2x2ReducedDensityMatrices( n, SV );
            let arrayOfAll4x4ReducedDensityMatrices = Sim.computeAll4x4ReducedDensityMatrices( n, SV );
            this.perQubitStats[s] = Sim.analyzeEachQubit(n,arrayOfAll2x2ReducedDensityMatrices);
            if ( s == this.numStages ) { // only compute these things for the last stage ...
                this.pairwiseCorrelations = Sim.computePairwiseQubitCorrelations(n,SV);
                this.pairwiseConcurrences = Sim.computePairwiseQubitConcurrences(n,arrayOfAll4x4ReducedDensityMatrices);
                this.pairwisePurities = Sim.computePairwiseQubitPurity(n,arrayOfAll4x4ReducedDensityMatrices);
                this.pairwiseEntropies = Sim.computePairwiseQubitVonNeumannEntropy(n,arrayOfAll4x4ReducedDensityMatrices);

                // This is a hack to make it easier to display tooltips with arrows that point at appropriate edges of rectangular glyphs.
                // The matrix is a convenient way to store a bit of information for each pair of wires,
                // and the 4-element array contains values normalized to be between 0 and 1.0 indicating where
                // the edges of the rectangular glyphs are for 4 different metrics.
                this.normalizedPositionsOfGlyphs = create2DArray(n,n,[0,0,0,0]);
            }
        }
        this.stateVectorsAndStatsAreDirty = false;
    }
    runIfNecessary() {
        if ( this.stateVectorsAndStatsAreDirty )
            this.run();
    }
    generateString() {
        let obj = {cols:[]};
        for ( let s = 0; s < this.numStages; ++s ) {
            let thisColumn = [];

            let lastNonEmptyWireInThisLayer = this.numWires - 1;
            while ( this.isCellEmpty(lastNonEmptyWireInThisLayer,s) && lastNonEmptyWireInThisLayer > 0 )
                lastNonEmptyWireInThisLayer --;

            for ( let w = 0; w <= lastNonEmptyWireInThisLayer; ++w ) {
                let circuitPart = this.cells[w][s];
                switch( this.getCircuitPartIDOfCell(w,s) ) {
                case CP_EMPTY: thisColumn.push(1); break; // a 1 without quotes means a blank
                case CP_I:     thisColumn.push("1"); break; // a 1 in quotes means an explicit identity gate
                case CP_CB:    thisColumn.push("•"); break;
                case CP_ACB:   thisColumn.push("◦"); break;
                case CP_X:     thisColumn.push("X"); break;
                case CP_Y:     thisColumn.push("Y"); break;
                case CP_Z:     thisColumn.push("Z"); break;
                case CP_H:     thisColumn.push("H"); break;
                case CP_SWAP:  thisColumn.push("Swap"); break;

                case CP_SSX:   thisColumn.push("X^¼"); break;
                case CP_SX:    thisColumn.push("X^½"); break;
                case CP_SSY:   thisColumn.push("Y^¼"); break;
                case CP_SY:    thisColumn.push("Y^½"); break;
                case CP_SSZ:   thisColumn.push("Z^¼"); break;
                case CP_SZ:    thisColumn.push("Z^½"); break;
                case CP_invSSX:   thisColumn.push("X^-¼"); break;
                case CP_invSX:    thisColumn.push("X^-½"); break;
                case CP_invSSY:   thisColumn.push("Y^-¼"); break;
                case CP_invSY:    thisColumn.push("Y^-½"); break;
                case CP_invSSZ:   thisColumn.push("Z^-¼"); break;
                case CP_invSZ:    thisColumn.push("Z^-½"); break;

                /*
                case CP_SSX:   thisColumn.push({id:'X^ft',arg:'0.25'}); break;
                case CP_SX:    thisColumn.push({id:'X^ft',arg:'0.5'}); break;
                case CP_SSY:   thisColumn.push({id:'Y^ft',arg:'0.25'}); break;
                case CP_SY:    thisColumn.push({id:'Y^ft',arg:'0.5'}); break;
                case CP_SSZ:   thisColumn.push({id:'Z^ft',arg:'0.25'}); break;
                case CP_SZ:    thisColumn.push({id:'Z^ft',arg:'0.5'}); break;
                */
                case CP_XE:    thisColumn.push({id:'X^ft', arg: (circuitPart.paramValues[0]).toString() }); break;
                case CP_YE:    thisColumn.push({id:'Y^ft', arg: (circuitPart.paramValues[0]).toString() }); break;
                case CP_ZE:    thisColumn.push({id:'Z^ft', arg: (circuitPart.paramValues[0]).toString() }); break;
                case CP_RX:    thisColumn.push({id:'Rxft', arg: (circuitPart.paramValues[0]/180*Math.PI).toString() }); break;
                case CP_RY:    thisColumn.push({id:'Ryft', arg: (circuitPart.paramValues[0]/180*Math.PI).toString() }); break;
                case CP_RZ:    thisColumn.push({id:'Rzft', arg: (circuitPart.paramValues[0]/180*Math.PI).toString() }); break;
                case CP_PH:    thisColumn.push({id:'Phft', arg: (circuitPart.paramValues[0]/180*Math.PI).toString() }); break; // note that, if we wanted this to work in Quirk, we could convert it to a Z^... gate, but maybe it's better to keep it as a phase gate since that might be more meaningful to the user
                case CP_GP:    thisColumn.push({id:'GPft', arg: (circuitPart.paramValues[0]/180*Math.PI).toString() }); break;
                case CP_ZG:    thisColumn.push({id:'Zgft', arg1: (circuitPart.paramValues[0]/180*Math.PI).toString(), arg2: (circuitPart.paramValues[1]/180*Math.PI).toString() }); break;
                case CP_YG:    thisColumn.push({id:'Ygft', arg1: (circuitPart.paramValues[0]/180*Math.PI).toString(), arg2: (circuitPart.paramValues[1]/180*Math.PI).toString() }); break;
                case CP_HG:    thisColumn.push({id:'Hgft', arg1: (circuitPart.paramValues[0]/180*Math.PI).toString(), arg2: (circuitPart.paramValues[1]/180*Math.PI).toString() }); break;
                }
            }
            obj.cols.push( thisColumn );
        }
        return JSON.stringify( obj );
    }
    generateQASMString( withHTMLLineBreaks ) {
        let result = "";
        const lineBreak = withHTMLLineBreaks ? "<br/>\n" : "\n";
        result += "qreg q[" + this.numWires + "];" + lineBreak;
        for ( let s = 0; s < this.numStages; ++s ) {
            let arrayOfControlBits = [];
            let gateNameControlBitsPrefix = "";
            let controlBitArguments = "";
            for ( let w = 0; w < this.numWires; ++w ) {
                if ( this.getCircuitPartIDOfCell(w,s) === CP_CB ) {
                    arrayOfControlBits.push( w );
                    gateNameControlBitsPrefix += "c";
                    controlBitArguments += "q[" + w + "],";
                }
            }

            for ( let w = 0; w < this.numWires; ++w ) {
                let gateNameSuffix = "";
                let circuitPart = this.cells[w][s];
                switch ( this.getCircuitPartIDOfCell(w,s) ) {
                    case CP_X: gateNameSuffix = "x"; break;
                    case CP_SX: gateNameSuffix = "sx"; break;
                    case CP_invSX: gateNameSuffix = "sxdg"; break;
                    case CP_Y: gateNameSuffix = "y"; break;
                    case CP_Z: gateNameSuffix = "z"; break;
                    case CP_SZ: gateNameSuffix = "s"; break;
                    case CP_invSZ: gateNameSuffix = "sdg"; break;
                    case CP_SSZ: gateNameSuffix = "t"; break;
                    case CP_invSSZ: gateNameSuffix = "tdg"; break;
                    case CP_H: gateNameSuffix = "h"; break;
                    case CP_I: gateNameSuffix = "id"; break;
                    case CP_RX: gateNameSuffix = "rx("+(circuitPart.paramValues[0])/180*Math.PI+")"; break;
                    case CP_RY: gateNameSuffix = "ry("+(circuitPart.paramValues[0])/180*Math.PI+")"; break;
                    case CP_RZ: gateNameSuffix = "rz("+(circuitPart.paramValues[0])/180*Math.PI+")"; break;
                    case CP_PH: gateNameSuffix = "p("+(circuitPart.paramValues[0])/180*Math.PI+")"; break;
                }
                if ( gateNameSuffix.length > 0 ) {
                    let instruction = gateNameControlBitsPrefix + gateNameSuffix + " " + controlBitArguments;
                    instruction += "q[" + w + "];"
                    result += instruction + lineBreak;
                }
            }
            let swapBit1 = -1;
            let swapBit2 = -1;
            for ( let w = 0; w < this.numWires; ++w ) {
                if ( this.getCircuitPartIDOfCell(w,s)===CP_SWAP ) {
                    if ( swapBit1 < 0 )
                        swapBit1 = w;
                    else {
                        swapBit2 = w;
                        let instruction = gateNameControlBitsPrefix + "swap " + controlBitArguments;
                        instruction += "q[" + swapBit1 + "],q[" + swapBit2 + "];"
                        result += instruction + lineBreak;
                        break;
                    }
                }
            }
        }
        return result;
    }
    constructFromString( circuitString ) {
        this.clear();
        let obj = JSON.parse( circuitString );
        if ( obj.cols !== null ) {
            for ( let l = 0; l < obj.cols.length; ++l ) {
                for ( let w = 0; w < obj.cols[l].length; ++w ) {
                    let gatePartInString = obj.cols[l][w];
                    let circuitPart_id = CP_I;
                    if ( typeof(gatePartInString)==='number' ) {
                    }
                    else if ( typeof(gatePartInString)==='string' ) {
                        switch(gatePartInString) {
                        case '1': circuitPart_id=CP_I; break;
                        case '•': circuitPart_id=CP_CB; break;
                        case '◦': circuitPart_id=CP_ACB; break;
                        case 'X': circuitPart_id=CP_X; break;
                        case 'Y': circuitPart_id=CP_Y; break;
                        case 'Z': circuitPart_id=CP_Z; break;
                        case 'H': circuitPart_id=CP_H; break;
                        case 'Swap': circuitPart_id=CP_SWAP; break;
                        case 'X^¼': circuitPart_id=CP_SSX; break;
                        case 'Y^¼': circuitPart_id=CP_SSY; break;
                        case 'Z^¼': circuitPart_id=CP_SSZ; break;
                        case 'X^½': circuitPart_id=CP_SX; break;
                        case 'Y^½': circuitPart_id=CP_SY; break;
                        case 'Z^½': circuitPart_id=CP_SZ; break;
                        case 'X^-¼': circuitPart_id=CP_invSSX; break;
                        case 'Y^-¼': circuitPart_id=CP_invSSY; break;
                        case 'Z^-¼': circuitPart_id=CP_invSSZ; break;
                        case 'X^-½': circuitPart_id=CP_invSX; break;
                        case 'Y^-½': circuitPart_id=CP_invSY; break;
                        case 'Z^-½': circuitPart_id=CP_invSZ; break;
                        }
                        this.addCircuitPart( icons[ circuitPart_id ].circuitPartFactory(), w, l, false );
                    }
                    else if ( typeof(gatePartInString)==='object' ) {
                        let argument = parseFloat( gatePartInString.arg );
                        let argument1 = parseFloat( gatePartInString.arg1 );
                        let argument2 = parseFloat( gatePartInString.arg2 );
                        let tempParamValues = [ ];
                        switch(gatePartInString.id) {
                        case 'X^ft':
                            tempParamValues[0] = argument;
                            circuitPart_id = CP_XE;
                            break;
                        case 'Y^ft':
                            tempParamValues[0] = argument;
                            circuitPart_id = CP_YE;
                            break;
                        case 'Z^ft':
                            tempParamValues[0] = argument;
                            circuitPart_id = CP_ZE;
                            break;
                        case 'Rxft':
                            tempParamValues[0] = argument / Math.PI * 180;
                            circuitPart_id = CP_RX;
                            break;
                        case 'Ryft':
                            tempParamValues[0] = argument / Math.PI * 180;
                            circuitPart_id = CP_RY;
                            break;
                        case 'Rzft':
                            tempParamValues[0] = argument / Math.PI * 180;
                            circuitPart_id = CP_RZ;
                            break;
                        case 'Phft':
                            tempParamValues[0] = argument / Math.PI * 180;
                            circuitPart_id = CP_PH;
                            break;
                        case 'GPft':
                            tempParamValues[0] = argument / Math.PI * 180;
                            circuitPart_id = CP_GP;
                            break;
                        case 'Zgft':
                            tempParamValues[0] = argument1 / Math.PI * 180;
                            tempParamValues[1] = argument2 / Math.PI * 180;
                            circuitPart_id = CP_ZG;
                            break;
                        case 'Ygft':
                            tempParamValues[0] = argument1 / Math.PI * 180;
                            tempParamValues[1] = argument2 / Math.PI * 180;
                            circuitPart_id = CP_YG;
                            break;
                        case 'Hgft':
                            tempParamValues[0] = argument1 / Math.PI * 180;
                            tempParamValues[1] = argument2 / Math.PI * 180;
                            circuitPart_id = CP_HG;
                            break;
                        }
                        let circuitPart = icons[ circuitPart_id ].circuitPartFactory();
                        circuitPart.paramValues = tempParamValues;
                        this.addCircuitPart(circuitPart,w,l,false);
                    }
                }
            }
        }
    }
}

function drawTextLabelWithOutline(
    x_pixels, y_pixels, // lower left corner, or lower right if isLeftWard===true
    s, isLeftWard,
    withBackground,
    withBorder,
    rectangleHeight
) {
    let margin = rectangleHeight/8;
    let textHeight = rectangleHeight - 2*margin;
    let textWidth = ( textHeight / draw2.fontHeight ) * draw2.stringWidth( s );

    let rectangleWidth = textWidth + 2*margin;
    let x0 = x_pixels + ( isLeftWard ? (- rectangleWidth) : 0 );
    if ( x0 + rectangleWidth > canvas.width ) x0 = canvas.width - rectangleWidth;
    if ( x0 < 0 ) x0 = 0;
    let y0 = y_pixels - rectangleHeight;

    if ( withBackground ) {
        draw2.setFillColor_array(DC_label_background);
        draw2.fillRect( x0, y0, rectangleWidth, rectangleHeight );
    }
    if ( withBorder ) {
        draw2.setStrokeColor_array(DC_foreground);
        draw2.drawRect( x0, y0, rectangleWidth, rectangleHeight );
    }
    draw2.setFillColor_array(DC_foreground);
    draw2.drawString( x0+margin, y_pixels-margin, s, textHeight, TD_HORIZONTALLY_RIGHT );
}

function drawMultilineTextLabelWithOutlineAndArrows(
    x_right, y_top, // world space coordinates of upper right corner of the label
    heightPerRowOfText, // in world space units
    strings, // array
    endpoints, // array of Vec2. If an element is null, no arrow is drawn.
    distanceBetweenAdjacentEndpoints, // determines size of arrowheads

    // For the following parameters, the caller can pass in an array with one element for each arrow,
    // or pass an array of a single element in which case that element is used for all arrows.
    endpoint_tangents, // array of Vec2
    arrow_colors, // array of arrays of the form [r,g,b,alpha] where r,g,b are in the range 0 to 255 and alpha is in the range 0.0 to 1.0
    arrow_background_colors // array of arrays of the form [r,g,b,alpha] where r,g,b are in the range 0 to 255 and alpha is in the range 0.0 to 1.0; if undefined, no background color is used
) {
    let margin = heightPerRowOfText/8;
    let textHeight = heightPerRowOfText - 2*margin;
    let maxStringWidth = 0;
    for ( let i = 0; i < strings.length; ++i ) {
        let w = draw2.stringWidth( strings[i] );
        if ( w > maxStringWidth ) maxStringWidth = w;
    }
    let maxTextWidth = ( textHeight / draw2.fontHeight ) * maxStringWidth;

    let rectangleWidth = maxTextWidth + 2*margin;
    let rectangleHeight = heightPerRowOfText * strings.length;
    let x0 = x_right - rectangleWidth;
    let y0 = y_top;

    // draw background
    draw2.setFillColor_array(DC_label_background);
    draw2.fillRect( x0, y0, rectangleWidth, rectangleHeight );

    // draw arrows
    for ( let i = 0; i < strings.length; ++i ) {
        if ( strings[i].length > 0 && endpoints[i] !== null ) {
            draw2.setStrokeColor_array( arrow_colors[i % arrow_colors.length] );
            if ( arrow_background_colors !== undefined )
                draw2.setFillColor_array( arrow_background_colors[i % arrow_background_colors.length] );
            let startpoint = new Vec2( x_right, y0 + (i+0.5)*heightPerRowOfText );
            let endpoint_tangent = endpoint_tangents[i % endpoint_tangents.length];
            draw2.drawSpline(
                startpoint.x, startpoint.y, endpoints[i].x, endpoints[i].y,
                1,0, endpoint_tangent.x, endpoint_tangent.y,
                SV_splineTangentWeight, SV_splineTangentWeight
            );
            draw2.drawArrowHead(
                endpoints[i].x, endpoints[i].y,
                - endpoint_tangent.x, - endpoint_tangent.y,
                distanceBetweenAdjacentEndpoints,
                arrow_background_colors !== undefined,
                true
            );
        }
    }

    // draw border
    draw2.setStrokeColor_array(DC_foreground);
    draw2.drawRect( x0, y0, rectangleWidth, rectangleHeight );

    // draw strings
    draw2.setFillColor_array(DC_foreground);
    for ( let i = 0; i < strings.length; ++i ) {
        draw2.drawString( x0+margin, y0 + (i+1)*heightPerRowOfText - margin, strings[i], textHeight, TD_HORIZONTALLY_RIGHT );
    }
}


// --------------------------

/*
    We want to allow for multiple widgets (e.g., Toolbar, CircuitViewer, FloatingCheckbox)
    that live on a large, zoomable 2D canvas,
    and allow for drag-and-drop actions between the widgets.
    Assume there is some framework that receives mouse events and forwards them
    to the widgets.
    A widget may decide that a drag-and-drop action begins when the user presses down
    on some part of it, or may decide that drag-and-drop begins during the first drag event
    (because the initial press only served to select something within the widget).
    The initiatesDragAndDrop return value is used to indicate this to the framework.
    (For example, the Toolbar might return a true value for initiatesDragAndDrop
    as soon as the user presses on a gate inside the Toolbar,
    but the CircuitViewer might use the initial press to select a gate and wait
    for a subsequent drag event before returning a true value for initiatesDragAndDrop.)
    Once a drag-and-drop action begins, the framework takes over managing subsequent events,
    but still informs the widget of drag (and drag leave, and release) events, to allow the widget to update
    visual feedback or highlighting, e.g., to indicate to the user information about
    drop sites.
    If the widget never returns a true value for initiatesDragAndDrop during a press+drag sequence,
    then the framework allows the widget to do what it wants with the drag events,
    and the widget will never receive a 'drag leave' event, but will receive a release event.

    So, logic for camera pan and zoom, and for drag-and-drop, is managed mostly by the framework,
    whereas logic for dragging gate parameters or rectangle selection within a circuit would be
    managed by the CircuitViewer widget.
*/


const ABSTRACT_METHOD = 'Abstract method';


// The MW_ prefix means MyWidget
// These must be distinct bits, so they can be logically 'OR'ed together.
const MW_BUTTON_LEFT = 1;
const MW_BUTTON_MIDDLE = 2;
const MW_BUTTON_RIGHT = 4;
const MW_KEY_CONTROL = 8;
const MW_KEY_SHIFT = 16;



class MyWidget { // abstract base class

    // Returns an object of the form { redraw:boolean, initiatesDragAndDrop:boolean, objectBeingDragged:reference (in practice, an instance of CircuitPart) }
    widget_mousePress(
        x_pixels, y_pixels, x_world, y_world,
        mouseButton, // one of MW_BUTTON_...
        buttonAndKeyState // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
    ) { throw new Error(ABSTRACT_METHOD); }

    // Returns an object of the form { redraw:boolean, acceptsDragAndDrop:boolean }
    widget_mouseRelease(
        x_pixels, y_pixels, x_world, y_world,
        mouseButton, // one of MW_BUTTON_...
        buttonAndKeyState, // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
        isPartOfDragAndDrop, // if true, the caller is managing events; if false, the widget is managing events
        infoAboutObjectBeingDragged // an object of the form {obj:reference} (in practice, obj is an instance of CircuitPart)
    ) { throw new Error(ABSTRACT_METHOD); }

    // Returns an object of the form {redraw:boolean}
    widget_mouseHover(
        x_pixels, y_pixels, x_world, y_world
    ) { throw new Error(ABSTRACT_METHOD); }

    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_mouseHoverLeave() { throw new Error(ABSTRACT_METHOD); }

    // Returns an object of the form {redraw:boolean, initiatesDragAndDrop:boolean, objectBeingDragged:reference }
    widget_mouseDrag(
        x_pixels, y_pixels, x_world, y_world,
        buttonAndKeyState, // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
        isPartOfDragAndDrop, // if true, the caller is managing events; if false, the widget is managing events
        infoAboutObjectBeingDragged // null for none, otherwise an object of the form { obj:reference, source:reference }
    ) { throw new Error(ABSTRACT_METHOD); }

    // Only invoked during drag-and-drop.
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_mouseDragLeave() { throw new Error(ABSTRACT_METHOD); }

    // Called if this object was the source and/or sink of a drag-and-drop.
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_cleanUpAfterDragAndDrop(wasSource,wasDestination) { throw new Error(ABSTRACT_METHOD); }
}


// --------------------------

// The prefix FC_ means FloatingCheckbox
const FC_SIZE = 25; // width and height, in pixels
// The prefix FCS_ means FloatingCheckboxStyle
const FCS_CHECKMARK = 0;
const FCS_PLUS_MINUS = 1;

class FloatingCheckbox extends MyWidget {
    constructor(
        initial_state,
        off_tooltip,
        on_tooltip,
        client_callback_function, // a function taking (boolean state,client_data) as parameters
        client_data
    ) {
        super();
        this.style = FCS_PLUS_MINUS;
        this.isOn = initial_state;
        this.offTooltip = off_tooltip;
        this.onTooltip = on_tooltip;
        this.client_callback_function = client_callback_function;
        this.client_data = client_data;
        this.isCursorHoveringOver = false;
    }
    getSize() {
        return FC_SIZE;
    }
    setPosition(x,y) { // of upper-left corner; in pixels
        this.x = x;
        this.y = y;
    }
    // returns rectangle in pixel space
    getBoundingRect() {
        return new Box2(
            new Vec2( this.x, this.y ),
            new Vec2( this.x+FC_SIZE, this.y+FC_SIZE )
        );
    }
    draw( draw2 ) {
        //draw2.setCoordinateSystemToPixels();
        let rect = this.getBoundingRect();
        draw2.setFillColor_array( this.isCursorHoveringOver ? DC_highlight_icon : DC_background2 );
        draw2.fillRect(rect.min.x,rect.min.y,rect.width(),rect.height());
        draw2.setStrokeColor_array( DC_foreground );
        draw2.setLineWidth( 1 ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
        draw2.drawRect(rect.min.x,rect.min.y,rect.width(),rect.height());
        if ( this.style === FCS_PLUS_MINUS ) {
            let center = rect.center();
            let radius = 0.75 * FC_SIZE / 2;
            // draw horizontal stroke, for minus or plus sign
            draw2.drawLine( center.x-radius, center.y, center.x+radius, center.y );
            if ( ! this.isOn ) {
                // draw vertical stroke, for plus sign
                draw2.drawLine( center.x, center.y-radius, center.x, center.y+radius );
            }
        }
    }
    // Only called if nothing is being dragged.
    drawTooltip( draw2, x_pixels, y_pixels ) {
        if ( ! this.isCursorHoveringOver )
            return;
        let s = this.isOn ? this.onTooltip : this.offTooltip;
        drawTextLabelWithOutline( x_pixels, y_pixels, s, true, true, true, TOOLTIP_SIZE );
    }
    // Returns a boolean
    isUnder( x_pixels, y_pixels, x_world, y_world ) {
        return this.getBoundingRect().containsPoint( new Vec2( x_pixels, y_pixels ) );
    }
    // Returns an object of the form { redraw:boolean, initiatesDragAndDrop:boolean, objectBeingDragged:reference }
    widget_mousePress(
        x_pixels, y_pixels, x_world, y_world, mouseButton, buttonAndKeyState
    ) {
        this.isCursorHoveringOver = true;
        return { redraw: true, initiatesDragAndDrop: false, objectBeingDragged: null };
    }
    // Returns an object of the form { redraw:boolean, acceptsDragAndDrop:boolean }
    widget_mouseRelease(
        x_pixels, y_pixels, x_world, y_world,
        mouseButton, // one of MW_BUTTON_...
        buttonAndKeyState, // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
        isPartOfDragAndDrop, // if true, the caller is managing events; if false, the widget is managing events
        infoAboutObjectBeingDragged // an object of the form {obj:reference}
    ) {
        this.isOn = ! this.isOn;
        this.client_callback_function( this.isOn, this.client_data );
        return { redraw:true, acceptsDragAndDrop:false };
    }
    // Returns an object of the form {redraw:boolean}
    widget_mouseHover(
        x_pixels, y_pixels, x_world, y_world
    ) {
        this.isCursorHoveringOver = true;
        return {redraw:false};
    }
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_mouseHoverLeave() {
        this.isCursorHoveringOver = false;
        return {redraw:false};
    }
    // Returns an object of the form {redraw:boolean, initiatesDragAndDrop:boolean, objectBeingDragged:reference}
    widget_mouseDrag(
        x_pixels, y_pixels, x_world, y_world,
        buttonAndKeyState, // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
        isPartOfDragAndDrop, // if true, the caller is managing events; if false, the widget is managing events
        infoAboutObjectBeingDragged // null for none, otherwise an object of the form { obj:reference, source:reference }
    ) {
        return { redraw:false, initiatesDragAndDrop:false, objectBeingDragged:null };
    }
    // Only invoked during drag-and-drop.
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_mouseDragLeave() {
        return {redraw:false};
    }
}



// --------------------------


// I won't make this a static member of the Toolbar class, because then I would need to prefix every mention of it with "Toolbar."

// The TB_ prefix means ToolBar
const TB_ICON_SIZE = 64; // icons are scaled to this size, in pixels

const TOOLTIP_SIZE = 32;

class Toolbar extends MyWidget {
    constructor() {
        super();
        this.numRows = 2; // number of rows of icons in the toolbar.
        this.highlighted_circuitPart_id = CP_EMPTY;
    }
    // returns pixel coordinates of upper left corner as an object of the form {x,y}
    getPositionOfIcon( circuitPart_id ) {
        let x = circuitPart_id;
        let y = 0;
        if ( this.numRows === 2 ) {
            switch ( circuitPart_id ) {
            case CP_CB:   x = 0; break;
            case CP_X:    x = 1; break;
            case CP_Y:    x = 2; break;
            case CP_Z:    x = 3; break;
            case CP_SX:  x = 4;  break;
            case CP_SY:  x = 5;  break;
            case CP_SZ:  x = 6;  break;
            case CP_SSX: x = 7;  break;
            case CP_SSY: x = 8;  break;
            case CP_SSZ: x = 9;  break;

            case CP_XE:  x = 10; break;
            case CP_YE:  x = 11; break;
            case CP_ZE:  x = 12; break;

            case CP_PH:  x = 13; break;
            case CP_GP:  x = 14; break;


            case CP_ACB: x = 0; y = 1; break;
            case CP_I:    x = 1; y = 1; break;
            case CP_SWAP: x = 2; y = 1; break;
            case CP_H:    x = 3; y = 1; break;
            case CP_invSX:  x = 4; y = 1; break;
            case CP_invSY:  x = 5; y = 1; break;
            case CP_invSZ:  x = 6; y = 1; break;
            case CP_invSSX: x = 7; y = 1; break;
            case CP_invSSY: x = 8; y = 1; break;
            case CP_invSSZ: x = 9; y = 1; break;

            case CP_RX:  x = 10; y = 1; break;
            case CP_RY:  x = 11; y = 1; break;
            case CP_RZ:  x = 12; y = 1; break;

            case CP_ZG:  x = 13; y = 1; break;
            case CP_YG:  x = 14; y = 1; break;
            case CP_HG:  x = 15; y = 1; break;

            }
        }
        return { x: (x*TB_ICON_SIZE), y: (y*TB_ICON_SIZE) };
    }
    // returns CP_EMPTY if none is found
    findIDOfIconUnderPosition( x_pixels, y_pixels ) {
        for ( let id = 0; id < CP_NUM; ++id ) {
            let pos = this.getPositionOfIcon( id );
            if (
                pos.x <= x_pixels && x_pixels <= pos.x+TB_ICON_SIZE
                && pos.y <= y_pixels && y_pixels <= pos.y+TB_ICON_SIZE
            )
                return id;
        }
        return CP_EMPTY;
    }
    // returns rectangle in pixel space
    getBoundingRect() {
        return new Box2(
            new Vec2(0,0),
            new Vec2( Math.ceil(CP_NUM / this.numRows)*TB_ICON_SIZE, this.numRows*TB_ICON_SIZE )
        );
    }
    draw( draw2 ) {
        //draw2.setCoordinateSystemToPixels();
        let rect = this.getBoundingRect();
        draw2.setFillColor_array(DC_background2);
        draw2.fillRect(rect.min.x,rect.min.y,rect.width(),rect.height());
        for ( let circuitPart_id = 0; circuitPart_id < CP_NUM; ++circuitPart_id ) {
            let pos = this.getPositionOfIcon( circuitPart_id );
            //draw2.canvas_context.drawImage(icons[circuitPart_id].image, pos.x, pos.y, TB_ICON_SIZE, TB_ICON_SIZE );
            draw2.drawImage(icons[circuitPart_id].image, pos.x, pos.y, TB_ICON_SIZE, TB_ICON_SIZE );
            if ( circuitPart_id === this.highlighted_circuitPart_id ) {
                draw2.setLineWidth( 3 ); // TODO_lineWidth
                draw2.setStrokeColor_array(DC_highlight_icon);
                draw2.drawRect(pos.x,pos.y,TB_ICON_SIZE,TB_ICON_SIZE);
            }
        }
    }
    // Only called if nothing is being dragged.
    drawTooltip(
        draw2,
        x_pixels, y_pixels
    ) {
        if ( this.highlighted_circuitPart_id < 0 )
            return;
        let s = icons[ this.highlighted_circuitPart_id ].tooltip;

        drawTextLabelWithOutline( x_pixels, y_pixels, s, false, true, true, TOOLTIP_SIZE );
    }
    // Only called if something is being dragged.
    drawObjectBeingDragged(
        draw2,
        x_pixels, y_pixels,
        infoAboutObjectBeingDragged // an object of the form {obj:reference}
    ) {
    }
    // Returns a boolean
    isUnder( x_pixels, y_pixels, x_world, y_world ) {
        return this.getBoundingRect().containsPoint( new Vec2( x_pixels, y_pixels ) );
    }
    // XXX we are in the Toolbar class
    // Returns an object of the form { redraw:boolean, initiatesDragAndDrop:boolean, objectBeingDragged:reference }
    widget_mousePress(
        x_pixels, y_pixels, x_world, y_world, mouseButton, buttonAndKeyState
    ) {
        let dragStarting = this.highlighted_circuitPart_id!==CP_EMPTY && mouseButton===MW_BUTTON_LEFT && buttonAndKeyState===MW_BUTTON_LEFT;
        return {
            redraw: true,
            initiatesDragAndDrop: dragStarting,
            objectBeingDragged: (dragStarting ? icons[ this.highlighted_circuitPart_id ].circuitPartFactory() : null)
        };
    }
    // Returns an object of the form { redraw:boolean, acceptsDragAndDrop:boolean }
    widget_mouseRelease(
        x_pixels, y_pixels, x_world, y_world,
        mouseButton, // one of MW_BUTTON_...
        buttonAndKeyState, // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
        isPartOfDragAndDrop, // if true, the caller is managing events; if false, the widget is managing events
        infoAboutObjectBeingDragged // an object of the form {obj:reference}
    ) {
        return { redraw:true, acceptsDragAndDrop:false };
    }
    // Returns an object of the form {redraw:boolean}
    widget_mouseHover(
        x_pixels, y_pixels, x_world, y_world
    ) {
        let new_id = this.findIDOfIconUnderPosition( x_pixels, y_pixels );
        if ( new_id !== this.highlighted_circuitPart_id ) {
            this.highlighted_circuitPart_id = new_id;
            return {redraw:true};
        }
        return {redraw:false};
    }
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_mouseHoverLeave() {
        let new_id = CP_EMPTY;
        if ( new_id !== this.highlighted_circuitPart_id ) {
            this.highlighted_circuitPart_id = new_id;
            return {redraw:true};
        }
        return {redraw:false};
    }
    // Returns an object of the form {redraw:boolean, initiatesDragAndDrop:boolean, objectBeingDragged:reference}
    widget_mouseDrag(
        x_pixels, y_pixels, x_world, y_world,
        buttonAndKeyState, // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
        isPartOfDragAndDrop, // if true, the caller is managing events; if false, the widget is managing events
        infoAboutObjectBeingDragged // null for none, otherwise an object of the form { obj:reference, source:reference }
    ) {
        return { redraw:false, initiatesDragAndDrop:false, objectBeingDragged:null };
    }
    // Only invoked during drag-and-drop.
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_mouseDragLeave() {
        return {redraw:false};
    }
    // Called if this object was the source and/or sink of a drag-and-drop.
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_cleanUpAfterDragAndDrop(wasSource,wasDestination) {
        let new_id = CP_EMPTY;
        if ( new_id !== this.highlighted_circuitPart_id ) {
            this.highlighted_circuitPart_id = new_id;
            return {redraw:true};
        }
        return {redraw:false};
    }
} // Toolbar class


// DispOpt is an abbreviation for DisplayOptions
let DispOpt = { };
DispOpt.showOriginalHalfmatrixTooltip = false;
DispOpt.showOriginalLSTooltip = false; // LS means LocalState
DispOpt.showFinalLocalState = false; // true;
DispOpt.showLocalStatePerLayer = false; // true;
DispOpt.showFinalHalfMatrix = false;
// LS_ means LocalState_
DispOpt.LS_numMetrics = 0;
DispOpt.LS_showPurity = false;
DispOpt.LS_showLinearEntropy = true;
DispOpt.LS_showVonNeumannEntropy = true;
DispOpt.LS_showProbability = true;
DispOpt.LS_showPhase = true;
// HM_ means HalfMatrix_
/*const*/ DispOpt.HM_BARCHART = 0;
/*const*/ DispOpt.HM_RECT_GLYPHS = 1;
DispOpt.HM_cellContents = DispOpt.HM_BARCHART;
DispOpt.HM_numMetrics = 0;
DispOpt.HM_showPurity = false;
DispOpt.HM_showLinearEntropy = true;
DispOpt.HM_showVonNeumannEntropy = true;
DispOpt.HM_showConcurrence = true;
DispOpt.HM_showCorrelation = true;
DispOpt.HM_signedMetricsHaveZeroInCenterOfCell = false;
DispOpt.showStateVectorsPerLayer = false;
DispOpt.showVisOfAllLayers = true;
DispOpt.scrollPerLayerVisHorizontally = false;
/*const*/ DispOpt.CELL_ASPECTRATIO_SQUARE = 1.0;
/*const*/ DispOpt.CELL_ASPECTRATIO_RECTANGULAR = 2.8; // 3.5;
/*const*/ DispOpt.OUTSIDE_BITSTRING_ASPECTRATIO = 3;
DispOpt.cell_aspectRatio = DispOpt.CELL_ASPECTRATIO_RECTANGULAR;
DispOpt.allowMultipleColumns = false;
DispOpt.displayOutsideBitstring = true;
DispOpt.displayInsideBitstring = false;
DispOpt.displayInsideProbability = true;
/*const*/ DispOpt.BARFUNCTION_PROBABILITY = 0;
/*const*/ DispOpt.BARFUNCTION_MAGNITUDE = 1;
/*const*/ DispOpt.BARFUNCTION_LOG_PROBABILITY = 2;
DispOpt.barFunction = DispOpt.BARFUNCTION_PROBABILITY;
/*const*/ DispOpt.DIFFVIS_NONE = 0;
/*const*/ DispOpt.DIFFVIS_ONE = 1;
/*const*/ DispOpt.DIFFVIS_ALL = 2;
DispOpt.show_diffvis = DispOpt.DIFFVIS_ALL;

// The DC_ prefix means DisplayColor
const DC_background = [ 255, 255, 255, 1.0 ]; // background of the viewport
const DC_background2 = [ 240, 240, 240, 1.0 ]; // background of the circuit
const DC_label_background = [ 255,255,255,0.85 ];
const DC_foreground = [ 0, 0, 0, 1 ];
const DC_highlight_icon = [ 255, 128, 0, 1 ]; // [ 0, 128, 255, 1 ];
const DC_highlight_wire = [ 255, 128, 0, 1 ];
const DC_highlight_dropSite = [ 255, 128, 0, 1 ];
const DC_barcolor = [ 128,192,255, 1 ]; // for positive values
const DC_barcolor_neg_opaque = [ 255,128,128, 1 ]; // for negative values
const DC_shadow = [ 192, 192, 192, 1.0 ];
const DC_diffvis_1_background = [ 255, 160, 255, 1.0  ];
const DC_diffvis_1_foreground = [ 255, 96, 255, 1.0 ];
const DC_diffvis_2_background = [ 160, 255, 160, 1.0 ];
const DC_diffvis_2_foreground = [ 48, 255, 48, 1.0 ];
const DC_HM_mixedness = [ 128, 128, 128, 1 ]; // [ 255, 0, 255, 1 ];
const DC_HM_mixedness_darker = [ 0, 0, 0, 1 ]; // [ 255, 0, 255, 1 ];
const DC_HM_entanglement_pos = [ 0,128,255, 1 ];
const DC_HM_entanglement_neg = [ 255,0,0, 1 ]; // for negative values

// I won't make these static members of the CircuitViewer class, because then I would need to prefix every mention of them with "CircuitViewer."

// The CVH_ prefix means CircuitViewerHighlight
const CVH_NOTHING = -1;
const CVH_CIRCUIT = 0;
const CVH_FV_LOCALSTATE = 1;
const CVH_FV_HALFMATRIX = 2;
const CVH_PLV_LOCALSTATE = 3;
const CVH_PLV_STATEVECTOR = 4;
// XXX YYY additional cases to consider:
/*
    user can be hovering over a particular parameter of a gate
    CVH_PLV_LOCALSTATE or CVH_PLV_STATEVECTOR
       user is on a PLV and in between two stages of the circuit; we can draw a vertical line segment in the circuit between the two stages
       if user is on a CVH_PLV_STATEVECTOR vis, they are on a particular state, for which we can popup a tooltip

    Things to check:
    - when CVH_PLV_LOCALSTATE, you should still highlight wire, but not a gate
    - when CVH_PLV_LOCALSTATE or CVH_PLV_STATEVECTOR, you should draw vertical line segment in between two stages of the circuit

    When cursor is over a parameter, can you make tooltip appear saying:
        Ctrl+drag left-right to adjust. Shift+drag left-right to snap to nice values.
*/

// CV_ prefix means CircuitViewer
const CV_MARGIN = 0.5; // only used for camera framing

// FV_ means FinalVisualization
// LS_ means LocalState
const FV_MARGIN_LEFT = 1;
let LS_W = 1;
let FV_LS_x0 = 0;

// FV_HM_ prefix for FinalVisualization_HalfMatrix
let FV_HM_center_x0 = 0;
let FV_HM_center_y0 = 0;

// PLV_ prefix for PerLayerVisualization
let PLV_x0 = 0;
let PLV_y0 = 0;
let PLV_col_w = 1;
const PLV_space_h_top = 1;
const PLV_space_h = 0.5;
let PLV_space_w = 1;
let PLV_total_w = 1;
let PLV_stage = 0;
let PLV_stage_fractionalPart = 0.5;
let PLV_mostRecentForScrolling_mouse_x_world = 0;
// SV_ means StateVector
let SV_col_w = 1;
const SV_arrowHeadLength = 0.15;
const SV_arrowHeadLength2 = 0.5;
const SV_splineTangentWeight = 0.6;
const diffvis_forSwapGates_thickness = 2;
let SV_numCols = 1;
let SV_numRows = 2;
let SV_numColBits = 0;
let SV_numRowBits = 0;
let SV_cell_w = 1;
let SV_cell_h = 1 / DispOpt.cell_aspectRatio;
let SV_total_h = 1;
// PLV_LS_ means PerLayerVisualization_LocalState
let PLV_LS_x0 = 0;
// PLV_SV_ means PerLayerVisualization_StateVector
let PLV_SV_x0 = 0;
let PLV_SV_y0 = 0;

const BAR_MARGIN = 0.1;
const BAR_WIDTH = 1 - 2*BAR_MARGIN;

// CV_DM_ prefix means CircuitViewer DragMode
const CV_DM_NOT_DRAGGING = 0;
const CV_DM_DRAGGING_NOTHING = 1;
const CV_DM_PARAMETER_DRAG = 2;
const CV_DM_PARAMETER_DRAG_WITH_SNAPPING = 3;
const CV_DM_TENTATIVE_DRAG_AND_DROP = 4;
const CV_DM_DRAG_AND_DROP = 5;
const CV_DM_DELETE_CIRCUITPART = 6;

class CircuitViewer extends MyWidget {
    clearHighlighting() {
        this.highlighted_mode = CVH_NOTHING;
        this.highlighted_wire = -1;
        this.highlighted_stage = -1;
        this.highlighted_circuitPart = null;
        this.highlighted_wire2 = -1;
        this.highlighted_circuitPart_parameter = -1;
        this.highlighted_baseState = -1;
    }
    clearSelection() {
        this.selected_circuitPart_isAnythingSelected = false;
        this.selected_circuitPart_wire = -1;
        this.selected_circuitPart_stage = -1;
        this.selected_circuitPart_parameter = -1;
    }
    clearDropCandidate() {
        this.hasDropCandidate = false;
        this.drop_wire = -1;
        this.drop_stage = -1;
        this.drop_insertBeforeTheGivenStage = false;
    }
    constructor(circuit) {
        super();
        this.circuit = circuit;
        this.clearHighlighting();
        this.clearDropCandidate();

        this.clearSelection();

        this.dragMode = CV_DM_NOT_DRAGGING;
        this.drag_x0_pixels = 0;
        this.drag_parameterValueAtStart = 0;
        this.drag_cumulativeDelta_pixels = 0;
    }
    // returns an object of the form { mode:..., wire:..., stage:..., circuitPart:..., wire2:..., circuitPart_parameter:..., baseState:... }
    findHighlightedElements( x_world, y_world ) {
        if ( DispOpt.showFinalHalfMatrix ) {
            let p_pm = this.transformWorldSpaceToPairwiseMatrixSpace( FV_HM_center_x0, FV_HM_center_y0, new Vec2(x_world,y_world) );
            let triangle_cell_i = Math.floor(p_pm.x);
            let triangle_cell_j = Math.floor(p_pm.y);
            if ( 0<=p_pm.x && 0<=p_pm.y && triangle_cell_i+triangle_cell_j<= this.circuit.numWires-2 ) {
                //console.log(`cell ${triangle_cell_i}, ${triangle_cell_j}`);
                return {mode:CVH_FV_HALFMATRIX, wire: triangle_cell_i, stage:-1, circuitPart:null, wire2: this.circuit.numWires-1-triangle_cell_j, circuitPart_parameter:-1, baseState:-1 };
            }
        }
        if (
            DispOpt.showFinalLocalState
            && FV_LS_x0 <= x_world && x_world <= FV_LS_x0+LS_W
            && 0 <= y_world && y_world <= this.circuit.numWires
        ) {
            return {mode:CVH_FV_LOCALSTATE, wire: Math.floor( y_world ), stage:-1, circuitPart:null, wire2:-1, circuitPart_parameter:-1, baseState:-1 };
        }
        if (
            DispOpt.showLocalStatePerLayer
            && PLV_x0 <= x_world && x_world <= PLV_x0+PLV_total_w
            && PLV_y0 <= y_world && y_world <= PLV_y0+this.circuit.numWires
        ) {
            return {mode:CVH_PLV_LOCALSTATE, wire: Math.floor(y_world - PLV_y0), stage:Math.floor((x_world-PLV_x0+PLV_space_w/2)/(PLV_col_w+PLV_space_w)), circuitPart:null, wire2:-1, circuitPart_parameter:-1, baseState:-1 };
        }
        if (
            DispOpt.showStateVectorsPerLayer
            && PLV_x0 <= x_world && x_world <= PLV_x0+PLV_total_w
            && PLV_SV_y0 <= y_world && y_world <= PLV_SV_y0+SV_total_h
        ) {
            let stage = Math.floor((x_world-PLV_x0+PLV_space_w/2)/(PLV_col_w+PLV_space_w));
            let baseState_col = Math.floor( (x_world-(PLV_SV_x0+stage*(PLV_col_w+PLV_space_w)))/SV_cell_w );
            let baseState_row = Math.floor( (y_world-PLV_SV_y0)/SV_cell_h );
            let baseState = -1;
            if (
                0 <= baseState_col && baseState_col < SV_numCols
                && 0 <= baseState_row && baseState_row < SV_numRows
            ) {
                baseState = baseState_row * SV_numCols + baseState_col;
            }
            else {
                // cursor is not on a cell of any state vector, so leave baseState === -1
            }
            return {mode:CVH_PLV_STATEVECTOR, wire:-1, stage:stage, circuitPart:null, wire2:-1, circuitPart_parameter:-1, baseState:baseState };
        }
        let stage = Math.floor( x_world );
        if ( stage < 0 || stage > this.circuit.numStages ) stage = -1;
        let wire = Math.floor( y_world );
        if ( wire < 0 || wire > this.circuit.numWires ) wire = -1;
        if ( stage < 0 && wire < 0 ) {
            return {mode:CVH_NOTHING, wire:-1, stage:-1, circuitPart:null, wire2:-1, circuitPart_parameter:-1, baseState:-1 };
        }

        let circuitPart = this.circuit.getCellContents(wire,stage);
        let circuitPart_parameter = -1;
        if ( circuitPart !== null ) {
            for ( let i = 0; i < circuitPart.getNumParameters(); ++i ) {
                let boundingRect = circuitPart.getBoundingRectOfParameterString( i, new Vec2( stage, wire ) );
                if ( boundingRect.containsPoint( new Vec2( x_world, y_world ) ) ) {
                    circuitPart_parameter = i;
                    break;
                }
            }
        }
        return { mode:CVH_CIRCUIT, wire:wire, stage:stage, circuitPart:circuitPart, wire2:-1, circuitPart_parameter:circuitPart_parameter, baseState:-1 };
    }
    // Useful for completing a drag-and-drop.
    // Returns an object of the form { hasDropCandidate:boolean, wire:...,stage:...,/*boolean*/insertBeforeTheGivenStage }
    findCellForDrop( x_world, y_world, circuitPart_id ) {
        const margin = 0.25;
        let wire = -1;
        let stage = -1;
        let insertBeforeTheGivenStage = false;
        let failureReturnValue = { hasDropCandidate:false, wire:-1, stage:-1, insertBeforeTheGivenStage:false };

        if ( x_world < -1 || this.circuit.numStages+2 < x_world ) { // it's too far outside
            return failureReturnValue;
        }
        else if ( x_world < margin ) { // close to left-most cell
            stage = 0;
            insertBeforeTheGivenStage = true;
        }
        else if ( this.circuit.numStages - margin < x_world ) { // just past right-most cell
            stage = this.circuit.numStages;
            insertBeforeTheGivenStage = true;
        }
        else { // inside the range of cells
            let distanceFromEdge = Math.abs(x_world - Math.round(x_world));
            if ( distanceFromEdge < margin ) {
                stage = Math.round( x_world );
                insertBeforeTheGivenStage = true;
            }
            else {
                stage = Math.floor( x_world );
                insertBeforeTheGivenStage = false;
            }
        }

        if ( y_world < -1 || y_world > this.circuit.numWires+1 ) { // it's too far outside
            return failureReturnValue;
        }
        else {
            wire = Math.floor( y_world );
            if ( wire < 0 ) wire = 0;
            else if ( wire > this.circuit.numWires ) wire = this.circuit.numWires;
        }

        if ( !insertBeforeTheGivenStage ) {
            if (
                ! this.circuit.isCellEmpty(wire,stage)
                || ( circuitPart_id===CP_SWAP && this.circuit.numSwapPartsInStage(stage)>=2 )
            ) {
                // the cell is not empty, or we already have 2 swap parts in the stage, so don't allow the drop
                return failureReturnValue;
            }
        }
        return { hasDropCandidate:true, wire:wire, stage:stage, insertBeforeTheGivenStage:insertBeforeTheGivenStage };
    }
    // returns rectangle in world space
    getBoundingRect() {
        let b = new Box2(
            new Vec2(-1-CV_MARGIN,-CV_MARGIN),
            new Vec2(
                this.circuit.numStages + FV_MARGIN_LEFT + ( DispOpt.showFinalLocalState ? LS_W : 0 ) + CV_MARGIN,
                this.circuit.numWires + CV_MARGIN
            ),
        );
        if ( DispOpt.showFinalHalfMatrix ) {
            b.boundPoint( new Vec2( FV_HM_center_x0 + CV_MARGIN, 0 ) );
        }
        if ( DispOpt.showLocalStatePerLayer ) {
            // account for how low the Local State visualization extends downward
            b.boundPoint( new Vec2( 0, PLV_y0 + this.circuit.numWires + CV_MARGIN ) )
            // account for how far left and right it extends
            let extent = DispOpt.scrollPerLayerVisHorizontally ? ( PLV_col_w + PLV_space_w/2 - 0.5 + CV_MARGIN ) : ((PLV_total_w-this.circuit.numStages)/2+CV_MARGIN);
            b.boundPoint( new Vec2( -extent, 0 ) );
            b.boundPoint( new Vec2( this.circuit.numStages + extent, 0 ) );
        }
        if ( DispOpt.showStateVectorsPerLayer ) {
            // account for how low the State Vector visualization extends downward
            b.boundPoint( new Vec2( 0, PLV_SV_y0 + SV_total_h + CV_MARGIN + ( DispOpt.displayOutsideBitstring&&DispOpt.allowMultipleColumns ? SV_cell_h * DispOpt.OUTSIDE_BITSTRING_ASPECTRATIO : 0 ) ) )
            // account for how far left and right it extends
            let extent = DispOpt.scrollPerLayerVisHorizontally ? ( PLV_col_w + PLV_space_w/2 - 0.5 + CV_MARGIN ) : ((PLV_total_w-this.circuit.numStages)/2+CV_MARGIN);
            b.boundPoint( new Vec2( -extent, 0 ) );
            b.boundPoint( new Vec2( this.circuit.numStages + extent + ( DispOpt.displayOutsideBitstring ? SV_cell_h * DispOpt.OUTSIDE_BITSTRING_ASPECTRATIO : 0 ), 0 ) );
        }
        return b;
    }
    // caller passes in coordinates, in pixels, of the region in the canvas within which we want the viewer to be framed
    frame( draw2, region_x,region_y,region_w,region_h ) {
        draw2.frameWithinCanvasRegion( this.getBoundingRect(), true, region_x,region_y,region_w,region_h );
    }
    transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, point_pm ) {
        const s = Math.SQRT1_2;
        let x = point_pm.x * s;
        let y = point_pm.y * s;
        return new Vec2( -s*x - s*y + halfMatrixCenter_x0, s*x - s*y + halfMatrixCenter_y0 );
    }
    transformWorldSpaceToPairwiseMatrixSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, point_w ) {
        const s = Math.SQRT1_2;
        let x = ( point_w.x - halfMatrixCenter_x0 ) / s;
        let y = ( point_w.y - halfMatrixCenter_y0 ) / s;
        return new Vec2( -s*x + s*y, - s*x - s*y );
    }
    drawLocalState( /*world*/x0, /*world*/y0, /*circuit*/C, /*int*/layer, /*bool*/drawDiffVis/*TODO_diff not yet used*/, alpha ) {
        draw2.setLineWidth(1);
        let partWidth = 0.5;

        for ( let wire = 0; wire < C.numWires; ++wire ) {
            draw2.setFillColor(DC_HM_mixedness[0],DC_HM_mixedness[1],DC_HM_mixedness[2],alpha);
            draw2.setStrokeColor_array(DC_foreground);
            let currentX = x0;
            if ( DispOpt.LS_showPurity ) {
                let h = C.perQubitStats[layer][wire].purity._r;
                draw2.fillRect(currentX+partWidth*BAR_MARGIN,y0+wire+(1-h),partWidth*BAR_WIDTH,h);
                currentX += partWidth;
            }
            if ( DispOpt.LS_showLinearEntropy ) {
                let h = C.perQubitStats[layer][wire].linearEntropy;
                draw2.fillRect(currentX+partWidth*BAR_MARGIN,y0+wire+(1-h),partWidth*BAR_WIDTH,h);
                currentX += partWidth;
            }
            if ( DispOpt.LS_showVonNeumannEntropy ) {
                let h = C.perQubitStats[layer][wire].vonNeumannEntropy;
                draw2.fillRect(currentX+partWidth*BAR_MARGIN,y0+wire+(1-h),partWidth*BAR_WIDTH,h);
                currentX += partWidth;
            }
            draw2.setFillColor(DC_barcolor[0],DC_barcolor[1],DC_barcolor[2],alpha);
            if ( DispOpt.LS_showProbability ) {
                let h = C.perQubitStats[layer][wire].probabilityOfOne;
                draw2.fillRect(currentX+partWidth*BAR_MARGIN,y0+wire+(1-h),partWidth*BAR_WIDTH,h);
                currentX += partWidth;
            }
            if ( DispOpt.LS_showPhase ) {
                let circle_x = currentX + partWidth*0.5;
                let circle_y = y0+wire + 0.5;
                let circle_radius = partWidth * 0.5;
                let circle_hand_angle = - C.perQubitStats[layer][wire].phase;
                let circle_hand_x = circle_x + circle_radius*Math.cos(circle_hand_angle);
                let circle_hand_y = circle_y + circle_radius*Math.sin(circle_hand_angle)
                draw2.fillCircle( circle_x, circle_y, circle_radius );
                draw2.drawCircle( circle_x, circle_y, circle_radius );
                draw2.drawLine( circle_x, circle_y, circle_hand_x, circle_hand_y );
            }
            draw2.drawRect(x0,y0+wire,LS_W,1);
        }
    }
    drawLocalStateTooltip( /*world*/x0, /*world*/y0, /*circuit*/C, /*int*/layer, /*int*/wire, below ) {
        let precision = 3;
        let strings = [];
        let endpoints = [];
        let arrow_foreground_colors = [];
        let arrow_background_colors = [];
        let partWidth = 0.5;

        let currentX = x0;
        if ( DispOpt.LS_showPurity ) {
            strings.push( "Purity=" + StringUtil.numToString(C.perQubitStats[layer][wire].purity._r, precision ) );
            endpoints.push( new Vec2( currentX+0.5*partWidth, y0+(below ? 1 : 0) ) );
            arrow_foreground_colors.push( DC_HM_mixedness_darker );
            arrow_background_colors.push( DC_HM_mixedness );
            currentX += partWidth;
        }
        if ( DispOpt.LS_showLinearEntropy ) {
            strings.push( "Linear Entropy=" + StringUtil.numToString(C.perQubitStats[layer][wire].linearEntropy, precision ) );
            endpoints.push( new Vec2( currentX+0.5*partWidth, y0+(below ? 1 : 0) ) );
            arrow_foreground_colors.push( DC_HM_mixedness_darker );
            arrow_background_colors.push( DC_HM_mixedness );
            currentX += partWidth;
        }
        if ( DispOpt.LS_showVonNeumannEntropy ) {
            strings.push( "Von Neumann Entropy=" + StringUtil.numToString(C.perQubitStats[layer][wire].vonNeumannEntropy, precision ) );
            endpoints.push( new Vec2( currentX+0.5*partWidth, y0+(below ? 1 : 0) ) );
            arrow_foreground_colors.push( DC_HM_mixedness_darker );
            arrow_background_colors.push( DC_HM_mixedness );
            currentX += partWidth;
        }
        if ( DispOpt.LS_showProbability ) {
            strings.push( "Probability(|1>)=" + StringUtil.numToString(C.perQubitStats[layer][wire].probabilityOfOne , precision ) );
            endpoints.push( new Vec2( currentX+0.5*partWidth, y0+(below ? 1 : 0) ) );
            arrow_foreground_colors.push( DC_HM_entanglement_pos );
            arrow_background_colors.push( DC_HM_entanglement_pos );
            currentX += partWidth;
        }
        if ( DispOpt.LS_showPhase ) {
            strings.push( "Phase=" + StringUtil.numToString(C.perQubitStats[layer][wire].phase/Math.PI*180 , precision )+"°" );
            endpoints.push( new Vec2( currentX+0.5*partWidth, y0+(below ? 1 : 0) ) );
            arrow_foreground_colors.push( DC_HM_entanglement_pos );
            arrow_background_colors.push( DC_HM_entanglement_pos );
            currentX += partWidth;
        }

        drawMultilineTextLabelWithOutlineAndArrows(
            endpoints[0].x-(below ? 0.8 : 1.05 ), endpoints[0].y+(below?0.5:-2.25),
            0.6 * TB_ICON_SIZE*0.7 * draw2.scaleFactorInWorldSpaceUnitsPerPixel,
            strings,
            endpoints,
            0.3,
            [ new Vec2(0,below ? 1 : -1) ],
            // [ DC_foreground ]
            arrow_foreground_colors,
            arrow_background_colors
        );
    }
    drawHalfMatrix( halfMatrixCenter_x0, halfMatrixCenter_y0, /*circuit*/C, /*int*/layer/*not used yet*/, /*bool*/drawDiffVis/*TODO_diff not used yet*/ ) {

        const PURITY_MIN = 0;
        const PURITY_MAX = 1;
        const LINEARENTROPY_MIN = 0;
        const LINEARENTROPY_MAX = 1;
        const VONNEUMANENTROPY_MIN = 0;
        const VONNEUMANENTROPY_MAX = 2;
        const CONCURRENCE_MIN =  0;
        const CONCURRENCE_MAX =  1;
        const CORRELATION_MIN = -1;
        const CORRELATION_MAX =  1;

        const alpha = 0.5;
        const min_width = 0.1;

        // draw triangular half of matrix (HalfMatrix) for pairwise qubit stats
        //draw2.setLineWidth(1);
        //draw2.setStrokeColor_array(DC_foreground);
        let halfMatrixCenter_x0_pixels = draw2.convertWorldSpaceUnitsToPixelsX( halfMatrixCenter_x0 );
        let halfMatrixCenter_y0_pixels = draw2.convertWorldSpaceUnitsToPixelsY( halfMatrixCenter_y0 );

        draw2.canvas_context.save();
        draw2.canvas_context.translate( halfMatrixCenter_x0_pixels, halfMatrixCenter_y0_pixels );
        let scaleFactor = Math.SQRT1_2 / draw2.scaleFactorInWorldSpaceUnitsPerPixel;
        draw2.canvas_context.scale( scaleFactor, scaleFactor );
        draw2.canvas_context.rotate(Math.PI*0.75); // 135 degree rotation. Now, instead of (x+ right, y+ down), we have (x+ south west, y+ north west)
        let barWidth = 1/(DispOpt.HM_numMetrics*2+1);
        for ( let wire1 = 0; wire1 < C.numWires-1; wire1++ ) {
            for ( let wire2 = wire1+1; wire2 < C.numWires; wire2++ ) {
                if ( DispOpt.HM_cellContents === DispOpt.HM_RECT_GLYPHS ) {
                    // Reminder: we have (x+ south west, y+ north west)
                    //
                    // We also want to draw the glyphs with their origin in the bottom of each cell,
                    // so we define another coordinate system (a+ north west, b+ north east).
                    // Then, if we want to draw a rectangle with corner at (a,b) with dimensions (delta_a,delta_b),
                    // we can draw it with (x,y,width,height) = (1-b,a,-delta_b,delta_a)


                    // corner of cell within the half matrix, in the rotated local coordinate system of the half matrix
                    let x00 = wire1;
                    let y00 = C.numWires-1-wire2;

                    draw2.setLineWidth( draw2.scaleFactorInWorldSpaceUnitsPerPixel );
                    draw2.setStrokeColor_array(DC_foreground);
                    draw2.canvas_context.strokeRect(
                        x00, y00, 1, 1
                    );

                    // Corner of rectangular glyph, within the normalized local coordinate system of the cell
                    let a0 = 0;
                    let b0 = 0;
                    // dimensions of the rectangle glyph, normalized
                    let delta_a = ( 1-C.pairwisePurities.get(wire1,wire2)._r - LINEARENTROPY_MIN )/( LINEARENTROPY_MAX - LINEARENTROPY_MIN ) - a0;
                    if ( delta_a < min_width ) delta_a = min_width;
                    let delta_b = ( C.pairwiseEntropies.get(wire1,wire2)._r - VONNEUMANENTROPY_MIN )/( VONNEUMANENTROPY_MAX - VONNEUMANENTROPY_MIN ) - b0;
                    if ( delta_b < min_width ) delta_b = min_width;

                    draw2.setFillColor(DC_HM_mixedness[0],DC_HM_mixedness[1],DC_HM_mixedness[2],alpha);
                    draw2.setStrokeColor(DC_HM_mixedness[0],DC_HM_mixedness[1],DC_HM_mixedness[2],1.0);
                    draw2.canvas_context.fillRect( x00+(1-b0), y00+a0, -delta_b, delta_a );
                    draw2.canvas_context.strokeRect( x00+(1-b0), y00+a0, -delta_b, delta_a );

                    C.normalizedPositionsOfGlyphs[wire1][wire2][0] = delta_a + a0;
                    C.normalizedPositionsOfGlyphs[wire1][wire2][1] = delta_b + b0;

                    if ( DispOpt.HM_signedMetricsHaveZeroInCenterOfCell ) {
                        // Draws the glyph with a zero-correlation in the middle of the cell, positive correlations falling on one side of that zero,
                        // and negative correlations falling on the other side

                        a0 = 0;
                        b0 = 0.5;
                        delta_a = ( C.pairwiseConcurrences.get(wire1,wire2)._r - CONCURRENCE_MIN )/( CONCURRENCE_MAX - CONCURRENCE_MIN ) - a0;
                        if ( delta_a < min_width ) delta_a = min_width;
                        delta_b = ( C.pairwiseCorrelations.get(wire1,wire2)._r - CORRELATION_MIN )/( CORRELATION_MAX - CORRELATION_MIN ) - b0;
                        if ( Math.abs(delta_b) < min_width ) delta_b = delta_b < 0 ? -min_width : min_width;
                        if ( delta_b < 0 ) {
                            //draw2.setFillColor(DC_HM_entanglement_neg[0],DC_HM_entanglement_neg[1],DC_HM_entanglement_neg[2],alpha);
                            const gradient = draw2.canvas_context.createLinearGradient( x00+(1-b0), y00+(a0+delta_a), x00+(1-b0-delta_b), y00+(a0)); // (a,b) from (a0+delta_a,b0) to (a0,b0+delta_b)
                            gradient.addColorStop(0,`rgba(${DC_HM_entanglement_pos[0]},${DC_HM_entanglement_pos[1]},${DC_HM_entanglement_pos[2]},${alpha})`);
                            gradient.addColorStop(1,`rgba(${DC_HM_entanglement_neg[0]},${DC_HM_entanglement_neg[1]},${DC_HM_entanglement_neg[2]},${alpha})`);
                            //gradient.addColorStop(0, 'rgba(0, 0, 255, 0.5)');  // 50% transparent blue
                            //gradient.addColorStop(1, 'rgba(255, 0, 0, 0.5)');  // 50% transparent red
                            draw2.canvas_context.fillStyle = gradient;

                            draw2.setStrokeColor(DC_HM_entanglement_neg[0],DC_HM_entanglement_neg[1],DC_HM_entanglement_neg[2],1.0);
                        }
                        else {
                            draw2.setFillColor(DC_HM_entanglement_pos[0],DC_HM_entanglement_pos[1],DC_HM_entanglement_pos[2],alpha);
                            draw2.setStrokeColor(DC_HM_entanglement_pos[0],DC_HM_entanglement_pos[1],DC_HM_entanglement_pos[2],1.0);
                        }
                        draw2.canvas_context.fillRect( x00+(1-b0), y00+a0, -delta_b, delta_a );
                        draw2.canvas_context.strokeRect( x00+(1-b0), y00+a0, -delta_b, delta_a );

                        // draw a line segment to indicate where the 'zero' is for correlation
                        draw2.setStrokeColor_array(DC_foreground);
                        draw2.setLineWidth( 2 * draw2.scaleFactorInWorldSpaceUnitsPerPixel );
                        draw2.canvas_context.beginPath();
                        draw2.canvas_context.moveTo( x00+(1-b0), y00+(a0) );
                        draw2.canvas_context.lineTo( x00+(1-b0), y00+(a0+delta_a) );
                        draw2.canvas_context.stroke();
                    }
                    else {
                        a0 = 0;
                        b0 = 0;
                        delta_a = ( C.pairwiseConcurrences.get(wire1,wire2)._r - CONCURRENCE_MIN )/( CONCURRENCE_MAX - CONCURRENCE_MIN ) - a0;
                        if ( delta_a < min_width ) delta_a = min_width;
                        let absoluteCorrelation = Math.abs( C.pairwiseCorrelations.get(wire1,wire2)._r );
                        delta_b = absoluteCorrelation / CORRELATION_MAX;
                        if ( delta_b < min_width ) delta_b = min_width;
                        if ( C.pairwiseCorrelations.get(wire1,wire2)._r < 0 ) {
                            //draw2.setFillColor(DC_HM_entanglement_neg[0],DC_HM_entanglement_neg[1],DC_HM_entanglement_neg[2],alpha);
                            const gradient = draw2.canvas_context.createLinearGradient( x00+(1-b0), y00+(a0+delta_a), x00+(1-b0-delta_b), y00+(a0)); // (a,b) from (a0+delta_a,b0) to (a0,b0+delta_b)
                            gradient.addColorStop(0,`rgba(${DC_HM_entanglement_pos[0]},${DC_HM_entanglement_pos[1]},${DC_HM_entanglement_pos[2]},${alpha})`);
                            gradient.addColorStop(1,`rgba(${DC_HM_entanglement_neg[0]},${DC_HM_entanglement_neg[1]},${DC_HM_entanglement_neg[2]},${alpha})`);
                            //gradient.addColorStop(0, 'rgba(0, 0, 255, 0.5)');  // 50% transparent blue
                            //gradient.addColorStop(1, 'rgba(255, 0, 0, 0.5)');  // 50% transparent red
                            draw2.canvas_context.fillStyle = gradient;

                            draw2.setStrokeColor(DC_HM_entanglement_neg[0],DC_HM_entanglement_neg[1],DC_HM_entanglement_neg[2],1.0);
                        }
                        else {
                            draw2.setFillColor(DC_HM_entanglement_pos[0],DC_HM_entanglement_pos[1],DC_HM_entanglement_pos[2],alpha);
                            draw2.setStrokeColor(DC_HM_entanglement_pos[0],DC_HM_entanglement_pos[1],DC_HM_entanglement_pos[2],1.0);
                        }
                        draw2.canvas_context.fillRect( x00+(1-b0), y00+a0, -delta_b, delta_a );
                        draw2.canvas_context.strokeRect( x00+(1-b0), y00+a0, -delta_b, delta_a );
                    }
                    C.normalizedPositionsOfGlyphs[wire1][wire2][2] = delta_a + a0;
                    C.normalizedPositionsOfGlyphs[wire1][wire2][3] = delta_b + b0;
                }
                else {
                    // Reminder: we have (x+ south west, y+ north west)
                    let metrics = [];

                    if ( DispOpt.HM_showCorrelation ) metrics.push( { min: CORRELATION_MIN,max: CORRELATION_MAX,value:C.pairwiseCorrelations.get(wire1,wire2)._r, isMixedness:false } );
                    if ( DispOpt.HM_showConcurrence ) metrics.push( { min: CONCURRENCE_MIN,max: CONCURRENCE_MAX,value:C.pairwiseConcurrences.get(wire1,wire2)._r, isMixedness:false } );
                    if ( DispOpt.HM_showVonNeumannEntropy ) metrics.push( { min: VONNEUMANENTROPY_MIN,max: VONNEUMANENTROPY_MAX,value:C.pairwiseEntropies.get(wire1,wire2)._r, isMixedness:true } );
                    if ( DispOpt.HM_showLinearEntropy ) metrics.push( { min: LINEARENTROPY_MIN,max: LINEARENTROPY_MAX,value:1-C.pairwisePurities.get(wire1,wire2)._r, isMixedness:true } );
                    if ( DispOpt.HM_showPurity ) metrics.push( { min: PURITY_MIN,max: PURITY_MAX,value:C.pairwisePurities.get(wire1,wire2)._r, isMixedness:true } );
                    let currentX = wire1;
                    let currentY = C.numWires-1-wire2;

                    draw2.setLineWidth( draw2.scaleFactorInWorldSpaceUnitsPerPixel );
                    draw2.setStrokeColor_array(DC_foreground);
                    draw2.canvas_context.strokeRect(
                        currentX, currentY, 1, 1
                    );
                    currentX += barWidth;
                    for ( let metricIndex = 0; metricIndex < metrics.length; ++metricIndex ) {
                        let metric = metrics[ metricIndex ];
                        if ( DispOpt.HM_signedMetricsHaveZeroInCenterOfCell ) {
                            let y0 = (-metric.min)/(metric.max - metric.min);
                            let y = (metric.value - metric.min)/(metric.max - metric.min);
                            if ( metric.isMixedness ) {
                                draw2.setFillColor_array( DC_HM_mixedness );
                                draw2.canvas_context.fillRect(
                                    currentX, currentY + y, barWidth, y0-y
                                );
                            }
                            else {
                                if ( y >= y0 ) {
                                    draw2.setFillColor_array( DC_barcolor );
                                    draw2.canvas_context.fillRect(
                                        currentX, currentY + y0, barWidth, y-y0
                                    );
                                }
                                else {
                                    draw2.setFillColor_array( DC_barcolor_neg_opaque );
                                    draw2.canvas_context.fillRect(
                                        currentX, currentY + y, barWidth, y0-y
                                    );
                                }
                            }
                            if ( metric.min < 0 ) {
                                draw2.setLineWidth( 2 * draw2.scaleFactorInWorldSpaceUnitsPerPixel );
                                draw2.canvas_context.beginPath();
                                draw2.canvas_context.moveTo( currentX, currentY + y0 );
                                draw2.canvas_context.lineTo( currentX+barWidth, currentY + y0 );
                                draw2.canvas_context.stroke();
                            }
                        }
                        else {
                            let y0 = 0;
                            let absoluteMetric = Math.abs(metric.value);
                            let y = absoluteMetric / metric.max;

                            if ( metric.isMixedness ) {
                                draw2.setFillColor_array( DC_HM_mixedness );
                                draw2.canvas_context.fillRect(
                                    currentX, currentY + y, barWidth, y0-y
                                );
                            }
                            else {
                                if ( metric.value < 0 ) {
                                    draw2.setFillColor_array( DC_barcolor_neg_opaque );
                                }
                                else {
                                    draw2.setFillColor_array( DC_barcolor );
                                }
                                draw2.canvas_context.fillRect(
                                    currentX, currentY + y0, barWidth, y-y0
                                );
                            }
                        }
                        currentX += 2 * barWidth;
                    }
                }
            }
        }
        draw2.canvas_context.restore(); // restores us to (x+ right, y+ down)
    }
    drawHalfMatrixTooltip( halfMatrixCenter_x0, halfMatrixCenter_y0, /*circuit*/C, /*int*/layer/*not used yet*/, /*int*/qubit_i, /*int*/qubit_j ) {

        let row = qubit_i;
        let col = qubit_j;
        let strings = [];
        let endpoints = [];
        let tangents = [];
        let arrow_foreground_colors = [];
        let arrow_background_colors = [];
        let precision = 3;
        let metricCounter = 0;

        if ( DispOpt.HM_cellContents === DispOpt.HM_RECT_GLYPHS ) {
            strings.push( "Mixedness:" );
            endpoints.push( null );
            tangents.push( null );
            arrow_foreground_colors.push( null );
            arrow_background_colors.push( null );

            strings.push( "  Linear Entropy=" + StringUtil.numToString(1-C.pairwisePurities.get(row,col)._r,precision) );
            endpoints.push( this.transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, new Vec2(row+1,C.numWires-col-1+C.normalizedPositionsOfGlyphs[qubit_i][qubit_j][0]) ) );
            tangents.push( new Vec2(-1,1) );
            arrow_foreground_colors.push( DC_HM_mixedness_darker );
            arrow_background_colors.push( DC_HM_mixedness );

            strings.push( "  von Neumann Entropy=" + StringUtil.numToString(C.pairwiseEntropies.get(row,col)._r,precision) );
            endpoints.push( this.transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, new Vec2(row+(1-C.normalizedPositionsOfGlyphs[qubit_i][qubit_j][1]),C.numWires-col-1) ) );
            tangents.push( new Vec2(1,1) );
            arrow_foreground_colors.push( DC_HM_mixedness_darker );
            arrow_background_colors.push( DC_HM_mixedness );

            strings.push( "Intra-pair metrics:" );
            endpoints.push( null );
            tangents.push( null );
            arrow_foreground_colors.push( null );
            arrow_background_colors.push( null );

            strings.push( "  Concurrence=" + StringUtil.numToString(C.pairwiseConcurrences.get(row,col)._r,precision) );
            endpoints.push( this.transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, new Vec2(row+1,C.numWires-col-1+C.normalizedPositionsOfGlyphs[qubit_i][qubit_j][2]) ) );
            tangents.push( new Vec2(-1,1) );
            arrow_foreground_colors.push( DC_HM_entanglement_pos );
            arrow_background_colors.push( DC_HM_entanglement_pos );

            strings.push( "  Correlation=" + StringUtil.numToString(C.pairwiseCorrelations.get(row,col)._r,precision) );
            endpoints.push( this.transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, new Vec2(row+(1-C.normalizedPositionsOfGlyphs[qubit_i][qubit_j][3]),C.numWires-col-1) ) );
            tangents.push( new Vec2(1,1) );
            if ( C.pairwiseCorrelations.get(row,col)._r >= 0 || Number.isNaN( C.pairwiseCorrelations.get(row,col)._r ) ) {
                arrow_foreground_colors.push( DC_HM_entanglement_pos );
                arrow_background_colors.push( DC_HM_entanglement_pos );
            }
            else {
                arrow_foreground_colors.push( DC_HM_entanglement_neg );
                arrow_background_colors.push( DC_HM_entanglement_neg );
            }

            drawMultilineTextLabelWithOutlineAndArrows(
                endpoints[1].x-0.75, endpoints[1].y+0.5,
                0.6 * TB_ICON_SIZE*0.7 * draw2.scaleFactorInWorldSpaceUnitsPerPixel,
                strings,
                endpoints,
                Math.SQRT1_2 * Math.min( 1 / (DispOpt.HM_numMetrics+0.5), 0.5 ),
                tangents,
                arrow_foreground_colors,
                arrow_background_colors
            );
        }
        else {
            if ( DispOpt.HM_showPurity || DispOpt.HM_showLinearEntropy || DispOpt.HM_showVonNeumannEntropy ) {
                strings.push( "Mixedness:" );
                endpoints.push( null );
                arrow_foreground_colors.push( null );
                arrow_background_colors.push( null );
            }
            if ( DispOpt.HM_showPurity ) {
                strings.push( "  Purity=" + StringUtil.numToString(C.pairwisePurities.get(row,col)._r,precision) );
                endpoints.push( this.transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, new Vec2(row+1-(metricCounter+0.75)/(DispOpt.HM_numMetrics+0.5),C.numWires-col-1) ) );
                arrow_foreground_colors.push( DC_HM_mixedness_darker );
                arrow_background_colors.push( DC_HM_mixedness );
                metricCounter ++;
            }
            if ( DispOpt.HM_showLinearEntropy ) {
                strings.push( "  Linear Entropy=" + StringUtil.numToString(1-C.pairwisePurities.get(row,col)._r,precision) );
                endpoints.push( this.transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, new Vec2(row+1-(metricCounter+0.75)/(DispOpt.HM_numMetrics+0.5),C.numWires-col-1) ) );
                arrow_foreground_colors.push( DC_HM_mixedness_darker );
                arrow_background_colors.push( DC_HM_mixedness );
                metricCounter ++;
            }
            if ( DispOpt.HM_showVonNeumannEntropy ) {
                strings.push( "  von Neumann Entropy=" + StringUtil.numToString(C.pairwiseEntropies.get(row,col)._r,precision) );
                endpoints.push( this.transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, new Vec2(row+1-(metricCounter+0.75)/(DispOpt.HM_numMetrics+0.5),C.numWires-col-1) ) );
                arrow_foreground_colors.push( DC_HM_mixedness_darker );
                arrow_background_colors.push( DC_HM_mixedness );
                metricCounter ++;
            }
            if ( DispOpt.HM_showConcurrence || DispOpt.HM_showCorrelation ) {
                strings.push( "Intra-pair metrics:" );
                endpoints.push( null );
                arrow_foreground_colors.push( null );
                arrow_background_colors.push( null );
            }
            if ( DispOpt.HM_showConcurrence ) {
                strings.push( "  Concurrence=" + StringUtil.numToString(C.pairwiseConcurrences.get(row,col)._r,precision) );
                endpoints.push( this.transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, new Vec2(row+1-(metricCounter+0.75)/(DispOpt.HM_numMetrics+0.5),C.numWires-col-1) ) );
                arrow_foreground_colors.push( DC_HM_entanglement_pos );
                arrow_background_colors.push( DC_HM_entanglement_pos );
                metricCounter ++;
            }
            if ( DispOpt.HM_showCorrelation ) {
                strings.push( "  Correlation=" + StringUtil.numToString(C.pairwiseCorrelations.get(row,col)._r,precision) );
                endpoints.push( this.transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, new Vec2(row+1-(metricCounter+0.75)/(DispOpt.HM_numMetrics+0.5),C.numWires-col-1) ) );
                if ( C.pairwiseCorrelations.get(row,col)._r >= 0 || Number.isNaN( C.pairwiseCorrelations.get(row,col)._r ) ) {
                    arrow_foreground_colors.push( DC_HM_entanglement_pos );
                    arrow_background_colors.push( DC_HM_entanglement_pos );
                }
                else {
                    arrow_foreground_colors.push( DC_HM_entanglement_neg );
                    arrow_background_colors.push( DC_HM_entanglement_neg );
                }
                metricCounter ++;
            }

            drawMultilineTextLabelWithOutlineAndArrows(
                endpoints[1].x-0.5, endpoints[1].y+0.5,
                0.6 * TB_ICON_SIZE*0.7 * draw2.scaleFactorInWorldSpaceUnitsPerPixel,
                strings,
                endpoints,
                Math.SQRT1_2 * Math.min( 1 / (DispOpt.HM_numMetrics+0.5), 0.5 ),
                [ new Vec2(1,1) ],
                arrow_foreground_colors,
                arrow_background_colors
            );
        }
    }
    // XXX YYY test that all these new gates are visualized correctly:
    /*
        (done, not tested) CP_ZE, CP_PH
        (done, not tested) CP_YG, similar to Y and Z
        (done, not tested) CP_ZG, similar to Z and Y
        (done, not tested) CP_HG, similar to Y and H
        (done, not tested) CP_GP, similar to ZG (all amplitudes should be green, except when control bits)
        but don't visualize CP_RZ
    */
    drawStateVector(
        /*world*/ _x0, /*world*/ _y0,
        /*circuit*/ C, /*int*/ stage,
        /*bool*/ drawDiffVis,
        /*bool*/ drawTextInsideCells,
        /*bool*/ drawTextOutsideCells,
        /*int, -1 for none*/ highlightedBit,
        /*float*/ alpha
    ) {
        let diffvis_gateWire = -1;
        let diffvis_gateWire2 = -1;
        let show_diffvis_forXGate = false;
        let show_diffvis_forYGate = false;
        let show_diffvis_forRotationGate = false;
        let show_diffvis_forHGate = false;
        let show_diffvis_forSwapGates = false;
        // The "half block" terminology is the same as used in Sim.qubitWiseMultiply()
        let diffvis_showHighlightInHalfBlock0 = false;
        let diffvis_showHighlightInHalfBlock1 = false;
        let diffvis_useSameHighlightColorForBothBlocks = false;
        let diffvis_showSplinesConnectingHalfBlocks = false;
        let diffvis_showArithmeticOperatorsOnSpline = false;
        let diffvis_rotationAngleForHalfBlock0 = 0;
        let diffvis_rotationAngleForHalfBlock1 = 0;
        let diffvis_verticallyCenterRotationAngle = false;
        let diffvis_stateInclusionMask = 0;
        let diffvis_stateDesiredValue = 0;
        let diffvis_swap_mask_i;
        let diffvis_swap_mask_j;
        let diffvis_swap_antimask;

        // used to draw splines to show diffvis for X gate
        let diffvis_listOfCellCenters_earlierCells_inProgress = [];
        let diffvis_listOfCellCenters_laterCells_inProgress = [];
        let diffvis_listOfCellCenters_earlierCells_complete = [];
        let diffvis_listOfCellCenters_laterCells_complete = [];

        if ( drawDiffVis && stage < C.numStages ) {
            // determine what kind of diffvis to show
            let numSupportedGateParts = 0; // not including swap gate parts, control and anti-control bits
            let numSwapParts = 0;
            let numUnsupportedParts = 0;
            for ( let w = 0; w < C.numWires; ++w ) {
                let bit = (1<<w);
                let circuitPart = C.getCellContents(w,stage);
                let circuitPart_id = C.getCircuitPartIDOfCell(w,stage);
                if ( circuitPart_id === CP_X ) {
                    numSupportedGateParts ++;
                    diffvis_gateWire = w;
                    show_diffvis_forXGate = true;
                    diffvis_showHighlightInHalfBlock0 = true;
                    diffvis_showHighlightInHalfBlock1 = true;
                    diffvis_showSplinesConnectingHalfBlocks = true;
                }
                else if ( circuitPart_id === CP_Y ) {
                    numSupportedGateParts ++;
                    diffvis_gateWire = w;
                    show_diffvis_forYGate = true;
                    diffvis_showHighlightInHalfBlock0 = true;
                    diffvis_showHighlightInHalfBlock1 = true;
                    diffvis_showSplinesConnectingHalfBlocks = true;
                    diffvis_rotationAngleForHalfBlock0 = 90;
                    diffvis_rotationAngleForHalfBlock1 = -90;
                    diffvis_verticallyCenterRotationAngle = false;
                }
                else if ( circuitPart_id === CP_YG ) {
                    numSupportedGateParts ++;
                    diffvis_gateWire = w;
                    diffvis_showHighlightInHalfBlock0 = true;
                    diffvis_showHighlightInHalfBlock1 = true;
                    diffvis_showSplinesConnectingHalfBlocks = true;
                    diffvis_rotationAngleForHalfBlock0 = circuitPart.paramValues[0];
                    diffvis_rotationAngleForHalfBlock1 = circuitPart.paramValues[1];
                    diffvis_verticallyCenterRotationAngle = false;
                }
                else if ( circuitPart_id === CP_H ) {
                    numSupportedGateParts ++;
                    diffvis_gateWire = w;
                    show_diffvis_forHGate = true;
                    diffvis_showHighlightInHalfBlock0 = true;
                    diffvis_showHighlightInHalfBlock1 = true;
                    diffvis_showSplinesConnectingHalfBlocks = true;
                    diffvis_showArithmeticOperatorsOnSpline = true;
                }
                else if ( circuitPart_id === CP_HG ) {
                    numSupportedGateParts ++;
                    diffvis_gateWire = w;
                    diffvis_showHighlightInHalfBlock0 = true;
                    diffvis_showHighlightInHalfBlock1 = true;
                    diffvis_showSplinesConnectingHalfBlocks = true;
                    diffvis_showArithmeticOperatorsOnSpline = true;
                    diffvis_rotationAngleForHalfBlock0 = circuitPart.paramValues[0];
                    diffvis_rotationAngleForHalfBlock1 = circuitPart.paramValues[1];
                    diffvis_verticallyCenterRotationAngle = false;
                }
                else if (
                    circuitPart_id === CP_Z
                    || circuitPart_id === CP_SZ
                    || circuitPart_id === CP_SSZ
                    || circuitPart_id === CP_invSZ
                    || circuitPart_id === CP_invSSZ
                    || circuitPart_id === CP_ZE
                    || circuitPart_id === CP_PH
                ) {
                    numSupportedGateParts ++;
                    diffvis_gateWire = w;
                    show_diffvis_forRotationGate = true;
                    diffvis_showHighlightInHalfBlock0 = false;
                    diffvis_showHighlightInHalfBlock1 = true;
                    if ( circuitPart_id === CP_Z )
                        diffvis_rotationAngleForHalfBlock1 = 180;
                    else if ( circuitPart_id === CP_SZ )
                        diffvis_rotationAngleForHalfBlock1 = 90;
                    else if ( circuitPart_id === CP_SSZ )
                        diffvis_rotationAngleForHalfBlock1 = 45;
                    else if ( circuitPart_id === CP_invSZ )
                        diffvis_rotationAngleForHalfBlock1 = -90;
                    else if ( circuitPart_id === CP_invSSZ )
                        diffvis_rotationAngleForHalfBlock1 = -45;
                    else if ( circuitPart_id === CP_ZE )
                        diffvis_rotationAngleForHalfBlock1 = circuitPart.paramValues[0] * 180;
                    else if ( circuitPart_id === CP_PH )
                        diffvis_rotationAngleForHalfBlock1 = circuitPart.paramValues[0];
                    diffvis_verticallyCenterRotationAngle = true;
                }
                else if ( circuitPart_id === CP_ZG ) {
                    numSupportedGateParts ++;
                    diffvis_gateWire = w;
                    diffvis_showHighlightInHalfBlock0 = true;
                    diffvis_showHighlightInHalfBlock1 = true;
                    diffvis_rotationAngleForHalfBlock0 = circuitPart.paramValues[0];
                    diffvis_rotationAngleForHalfBlock1 = circuitPart.paramValues[1];
                    diffvis_verticallyCenterRotationAngle = false;
                }
                else if ( circuitPart_id === CP_GP ) {
                    numSupportedGateParts ++;
                    diffvis_gateWire = w;
                    diffvis_showHighlightInHalfBlock0 = true;
                    diffvis_showHighlightInHalfBlock1 = true;
                    diffvis_useSameHighlightColorForBothBlocks = true;
                    diffvis_rotationAngleForHalfBlock1 = circuitPart.paramValues[0];
                    diffvis_verticallyCenterRotationAngle = true;
                }
                else if ( circuitPart_id === CP_SWAP ) {
                    numSwapParts ++;
                    if ( diffvis_gateWire < 0 )
                        diffvis_gateWire = w;
                    else {
                        diffvis_gateWire2 = w;
                        show_diffvis_forSwapGates = true;
                    }
                }
                else if ( circuitPart_id === CP_CB ) {
                    diffvis_stateInclusionMask |= bit;
                    diffvis_stateDesiredValue |= bit;
                }
                else if ( circuitPart_id === CP_ACB ) {
                    diffvis_stateInclusionMask |= bit;
                }
                else if ( circuitPart_id !== CP_EMPTY && circuitPart_id !== CP_I ) {
                    numUnsupportedParts ++;
                    diffvis_gateWire = w;
                    diffvis_showHighlightInHalfBlock0 = true;
                    diffvis_showHighlightInHalfBlock1 = true;
                }
            }
            let totalNumParts = numSupportedGateParts + numSwapParts + numUnsupportedParts; // not including control and anti-control bits
            if (
                ( totalNumParts===1 && numSupportedGateParts===1 )
                || ( totalNumParts===2 && numSwapParts===2 )
            ) {
                // no problem
            }
            else if ( totalNumParts===1 && numUnsupportedParts===1 ) {
                // also no problem; we will still show highlighting of half blocks
            }
            else {
                // we don't support this case at all, so turn off all diff visual feedback for this layer
                show_diffvis_forXGate = false;
                show_diffvis_forYGate = false;
                show_diffvis_forRotationGate = false;
                show_diffvis_forHGate = false;
                show_diffvis_forSwapGates = false;
                diffvis_showHighlightInHalfBlock0 = false;
                diffvis_showHighlightInHalfBlock1 = false;
                diffvis_showSplinesConnectingHalfBlocks = false;
                diffvis_showArithmeticOperatorsOnSpline = false;
                diffvis_rotationAngleForHalfBlock0 = 0;
                diffvis_rotationAngleForHalfBlock1 = 0;
                diffvis_verticallyCenterRotationAngle = false;
            }

            if ( show_diffvis_forSwapGates ) {
                diffvis_swap_mask_i = 1 << diffvis_gateWire;
                diffvis_swap_mask_j = 1 << diffvis_gateWire2;
                diffvis_swap_antimask = ~( diffvis_swap_mask_i | diffvis_swap_mask_j );
            }
        }

        // draw diffvis for rotations
        if ( diffvis_rotationAngleForHalfBlock0 || diffvis_rotationAngleForHalfBlock1 ) {
            let numAnglesToDraw = ( diffvis_rotationAngleForHalfBlock0!==0 ? 1 : 0 ) + ( diffvis_rotationAngleForHalfBlock1!==0 ? 1 : 0 );
            for ( let block = 0; block <= 1; ++block ) {
                let angleInDegrees = block===0 ? diffvis_rotationAngleForHalfBlock0 : diffvis_rotationAngleForHalfBlock1;
                if ( angleInDegrees === 0 )
                    continue;
                let angle = - angleInDegrees / 180 * Math.PI; // convert to radians
                let radius, x, y;
                if ( Math.abs(angleInDegrees) <= 90 ) {
                    radius = PLV_space_w / 3;
                    x = _x0 + SV_col_w + radius;
                }
                else {
                    radius = PLV_space_w * 0.25;
                    x = _x0 + SV_col_w + PLV_space_w/2;
                }
                if ( diffvis_verticallyCenterRotationAngle ) {
                    y = _y0 + SV_total_h / 2;
                }
                else {
                    y = _y0 + ( (block===0) ? 0 : SV_total_h );
                }
                draw2.setFillColor_array( block===0 ? DC_diffvis_1_background : DC_diffvis_2_background );
                draw2.drawArc( x, y, radius, 0, angle, true );
                draw2.drawArc( x, y, radius, 0, angle, false );
                let cosine = Math.cos( angle );
                let sine = Math.sin( angle );
                let arrow_tip_x = x + radius * cosine;
                let arrow_tip_y = y + radius * sine;
                draw2.setFillColor_array( block===0 ? DC_diffvis_1_foreground : DC_diffvis_2_foreground );
                draw2.drawArrowHead( arrow_tip_x, arrow_tip_y, angleInDegrees < 0 ? - sine : sine, angleInDegrees < 0 ? cosine : - cosine, radius/3 );
            }
        }

        let length_of_substring_in_bitstring_to_highlight = 0; // by default, this highlighting is suppressed by setting this length to zero
        if ( this.highlighted_mode === CVH_CIRCUIT && highlightedBit >= 0 ) {
            length_of_substring_in_bitstring_to_highlight = 1;
        }

        let min_log2_probability = -1;
        let max_minus_min_log2_probability = 1;
        if ( DispOpt.barFunction === DispOpt.BARFUNCTION_LOG_PROBABILITY ) {
            let max_log2_probability = 0;
            let areMinAndMaxInitialized = false;
            let numNonzeroAmplitudes = 0;
            for ( let state = 0; state < C.stateVectors[ stage ]._rows; ++state ) {
                let probability = C.stateVectors[ stage ].get(state,0).magSquared();
                if ( probability > 0 ) {
                    numNonzeroAmplitudes ++;
                    let log2_p = Math.log2( probability );
                    if ( ! areMinAndMaxInitialized ) {
                        min_log2_probability = max_log2_probability = log2_p;
                        areMinAndMaxInitialized = true;
                    }
                    else {
                        if ( log2_p < min_log2_probability ) min_log2_probability = log2_p;
                        else if ( log2_p > max_log2_probability ) max_log2_probability = log2_p;
                    }
                }
            }
            max_minus_min_log2_probability = max_log2_probability - min_log2_probability;
            if ( max_minus_min_log2_probability < 0.001 ) {
                // This can happen if only one value of probability was encountered, maybe multiple times.
                // For example, we may have encountered only 1.0 once (resulting in a min and max of 0);
                // or 0.5 twice (resulting in a min and max of -1);
                // or 0.25 four times (resulting in a min and max of -2).
                // We force there to be a difference between the min and max.
                if ( numNonzeroAmplitudes === 1 ) {
                    // probability is 1.0, and we want log(probability) to be at the top end of the range [min,max]
                    max_log2_probability = 0;
                    min_log2_probability = -1;
                }
                else {
                    // There are multiple non-zero amplitudes, and they all have (nearly) the same magnitude.
                    // This will make it so their log2(probability) is in the center of the range of [min,max]
                    max_log2_probability = 0;
                    min_log2_probability *= 2;
                }
                max_minus_min_log2_probability = max_log2_probability - min_log2_probability;
            }
            else {
                // Make it so the min probability isn't quite mapped to the bottom end of the range [min,max]
                max_minus_min_log2_probability *= 1.2;
                min_log2_probability = max_log2_probability - max_minus_min_log2_probability;
            }
        }

        const margin = 0.1;
        let areCellsRectangular = ( DispOpt.cell_aspectRatio > 1 );
        for ( let state = 0; state < C.stateVectors[ stage ]._rows; ++state ) {
            // used to draw splines to implement diffvis_showSplinesConnectingHalfBlocks
            let diffvis_drawSplineUsingListsOfCellCenters = false;

            let _cell_x0 = _x0 + (state % SV_numCols) * SV_cell_w;
            let _cell_y0 = _y0 + Math.floor(state / SV_numCols) * SV_cell_h;
            let circle_radius = SV_cell_h / 2;
            let circle_x = _cell_x0 + SV_cell_w - circle_radius;
            let circle_y = _cell_y0 + circle_radius;

            let circle_hand_angle = - C.stateVectors[ stage ].get(state,0).arg();
            let circle_hand_x = circle_x + circle_radius*Math.cos(circle_hand_angle);
            let circle_hand_y = circle_y + circle_radius*Math.sin(circle_hand_angle);

            let barcolor = DC_barcolor;


            // draw diffvis between this stage and the next
            if ( (state & diffvis_stateInclusionMask) === diffvis_stateDesiredValue ) {
                if ( diffvis_showHighlightInHalfBlock0 || diffvis_showHighlightInHalfBlock1 || diffvis_showSplinesConnectingHalfBlocks || show_diffvis_forSwapGates ) {
                    if ( diffvis_showHighlightInHalfBlock0 || diffvis_showHighlightInHalfBlock1 ) {
                        if ( diffvis_useSameHighlightColorForBothBlocks ) {
                            draw2.setFillColor_array(DC_diffvis_2_background);
                            barcolor = DC_diffvis_2_foreground;
                            draw2.fillRect( _cell_x0, _cell_y0, SV_cell_w, SV_cell_h );
                        }
                        else if ( (( state >> diffvis_gateWire ) & 1) == 0 ) {
                            if ( diffvis_showHighlightInHalfBlock0 ) {
                                draw2.setFillColor_array(DC_diffvis_1_background);
                                barcolor = DC_diffvis_1_foreground;
                                draw2.fillRect( _cell_x0, _cell_y0, SV_cell_w, SV_cell_h );
                            }
                        }
                        else {
                            if ( diffvis_showHighlightInHalfBlock1 ) {
                                draw2.setFillColor_array(DC_diffvis_2_background);
                                barcolor = DC_diffvis_2_foreground;
                                draw2.fillRect( _cell_x0, _cell_y0, SV_cell_w, SV_cell_h );
                            }
                        }
                    }
                    if ( diffvis_showSplinesConnectingHalfBlocks ) {
                        let cellCenter = new Vec2( _cell_x0+SV_cell_w/2, _cell_y0+SV_cell_h/2 );
                        if ( (( state >> diffvis_gateWire ) & 1) == 0 ) {

                            if ( diffvis_listOfCellCenters_laterCells_inProgress.length > 0 ) {
                                // We have encountered the first of a *new* group of 'earlier' cells
                                // within this stage,
                                // so we need to trigger the drawing of the spline for the previous
                                // groups of 'earlier' and 'later' cells.
                                diffvis_listOfCellCenters_earlierCells_complete = diffvis_listOfCellCenters_earlierCells_inProgress;
                                diffvis_listOfCellCenters_laterCells_complete = diffvis_listOfCellCenters_laterCells_inProgress;
                                diffvis_listOfCellCenters_earlierCells_inProgress = [];
                                diffvis_listOfCellCenters_laterCells_inProgress = [];

                                diffvis_drawSplineUsingListsOfCellCenters = true;
                            }

                            diffvis_listOfCellCenters_earlierCells_inProgress.push( cellCenter );
                        }
                        else {
                            diffvis_listOfCellCenters_laterCells_inProgress.push( cellCenter );
                        }
                    }

                    if ( show_diffvis_forSwapGates ) {
                        let ithBit = (state >> diffvis_gateWire) & 1;
                        let jthBit = (state >> diffvis_gateWire2) & 1;
                        if ( ithBit !== jthBit ) { // this cell's amplitude is swapped with another cell's
                            if ( jthBit===0 ) { // we are encountering the first of the pair of cells
                                draw2.setFillColor_array(DC_diffvis_1_background);
                                barcolor = DC_diffvis_1_foreground;
                            }
                            else {
                                draw2.setFillColor_array(DC_diffvis_2_background);
                                barcolor = DC_diffvis_2_foreground;
                            }
                            draw2.fillRect( _cell_x0, _cell_y0, SV_cell_w, SV_cell_h );
                        }
                    }
                }
            }

            let magnitude = C.stateVectors[ stage ].get(state,0).mag();
            let probability = C.stateVectors[ stage ].get(state,0).magSquared();
            let barLength = probability;
            switch ( DispOpt.barFunction ) {
            case DispOpt.BARFUNCTION_PROBABILITY:
                barLength = probability;
                break;
            case DispOpt.BARFUNCTION_MAGNITUDE:
                barLength = magnitude;
                break;
            case DispOpt.BARFUNCTION_LOG_PROBABILITY:
                barLength = ( Math.log2( probability ) - min_log2_probability ) / max_minus_min_log2_probability;
                break;
            }
            if ( areCellsRectangular ) {
                barLength *= SV_cell_w-SV_cell_h;
            }
            else { // square shaped cell
                barLength *= SV_cell_h;
            }

            // draw bar inside the cell
            if ( barLength > 0 ) {
                draw2.setFillColor(barcolor[0],barcolor[1],barcolor[2],alpha);
                draw2.fillRect( _cell_x0, _cell_y0, barLength, SV_cell_h );
            }
            // draw strings inside the cell
            if ( areCellsRectangular && drawTextInsideCells ) {
                draw2.setFillColor_array(DC_foreground);
                let upperLeft = new Vec2( _cell_x0, _cell_y0 );
                let lowerRight = new Vec2(
                    _cell_x0+SV_cell_w-SV_cell_h,
                    _cell_y0+( (DispOpt.displayInsideBitstring&&DispOpt.displayInsideProbability) ? SV_cell_h/2 : SV_cell_h )
                );
                if ( DispOpt.displayInsideBitstring ) {
                    draw2.drawStringCenteredInRectangle(
                        new Box2(upperLeft,lowerRight),
                        StringUtil.intToBinaryString( state, C.numWires ),
                        margin,
                        TD_HORIZONTALLY_RIGHT
                        //
                        // ,
                        // C.numWires-1 - highlightedBit, // index of char to highlight
                        // length_of_substring_in_bitstring_to_highlight
                    );
                }
                if ( DispOpt.displayInsideBitstring && DispOpt.displayInsideProbability ) {
                    upperLeft.y += SV_cell_h/2;
                    lowerRight.y += SV_cell_h/2;
                }
                if ( DispOpt.displayInsideProbability && probability > 0 ) {
                    draw2.drawStringCenteredInRectangle(
                        new Box2(upperLeft,lowerRight),
                        StringUtil.numToString( probability ),
                        margin,
                        TD_HORIZONTALLY_RIGHT
                    );
                }
            }

            // draw phase glyph inside the cell
            if ( barLength > 0 ) {
                draw2.drawCircle( circle_x, circle_y, circle_radius );
                draw2.drawLine( circle_x, circle_y, circle_hand_x, circle_hand_y );
            }
            // draw rectangle around the cell
            draw2.drawRect( _cell_x0, _cell_y0, SV_cell_w, SV_cell_h );

            if ( (state & diffvis_stateInclusionMask) === diffvis_stateDesiredValue ) {
                if ( show_diffvis_forSwapGates ) {
                    {
                        let ithBit = (state >> diffvis_gateWire) & 1;
                        let jthBit = (state >> diffvis_gateWire2) & 1;
                        if ( ithBit !== jthBit ) { // this cell's amplitude is swapped with another cell's

                            if ( jthBit===1 ) { // we are encountering the second of the pair of cells
                                let otherState = state;
                                otherState &= diffvis_swap_antimask; // turns off bits i and j
                                otherState |= diffvis_swap_mask_i; // turns on bit i
                                Util.assert( otherState < state, "unexpected condition when drawing diffvis for swap" );

                                let cell_center_x = _cell_x0+SV_cell_w/2;
                                let cell_center_y = _cell_y0+SV_cell_h/2;
                                let otherCell_center_x = _x0 + ((otherState % SV_numCols)+0.5) * SV_cell_w;
                                let otherCell_center_y = _y0+(Math.floor(otherState / SV_numCols)+0.5) * SV_cell_h;

                                // draw a spline connecting the two cells
                                if ( state % SV_numCols === otherState % SV_numCols ) {
                                    // the two cells are in the same column

                                    let direction_x
                                        = (((state % SV_numCols)/(SV_numCols-1)) > 0.5)
                                        ? 1 // we are in the right half of the StateVectorVisualization1
                                        : -1; // we are in the left half
                                    draw2.setLineWidth( diffvis_forSwapGates_thickness ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                                    draw2.drawSpline(
                                        otherCell_center_x + direction_x*SV_arrowHeadLength2*SV_cell_h,
                                        otherCell_center_y,
                                        cell_center_x + direction_x*SV_arrowHeadLength2*SV_cell_h,
                                        cell_center_y,
                                        direction_x, 0, direction_x, 0,
                                        SV_splineTangentWeight, SV_splineTangentWeight
                                    );
                                    draw2.setFillColor_array(DC_diffvis_1_foreground);
                                    draw2.drawArrowHead(
                                        otherCell_center_x, otherCell_center_y,
                                        - direction_x, 0,
                                        SV_arrowHeadLength2 * SV_cell_h
                                    );
                                    draw2.setFillColor_array(DC_diffvis_2_foreground);
                                    draw2.drawArrowHead(
                                        cell_center_x, cell_center_y,
                                        - direction_x, 0,
                                        SV_arrowHeadLength2 * SV_cell_h
                                    );
                                    draw2.setLineWidth( 1 ); // TODO_lineWidth
                                }
                                else if ( Math.floor(state / SV_numCols) === Math.floor(otherState / SV_numCols) ) {
                                    // the two cells are in the same row

                                    let direction_y
                                        = ((state / C.stateVectors[ stage ]._rows) > 0.5)
                                        ? 1 // we are in the bottom half of the StateVectorVisualization1
                                        : -1; // we are in the top half
                                    draw2.setLineWidth( diffvis_forSwapGates_thickness ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                                    draw2.drawSpline(
                                        otherCell_center_x,
                                        otherCell_center_y + direction_y*SV_arrowHeadLength2*SV_cell_h,
                                        cell_center_x,
                                        cell_center_y + direction_y*SV_arrowHeadLength2*SV_cell_h,
                                        0, direction_y, 0, direction_y,
                                        SV_splineTangentWeight, SV_splineTangentWeight
                                    );
                                    draw2.setFillColor_array(DC_diffvis_1_foreground);
                                    draw2.drawArrowHead(
                                        otherCell_center_x, otherCell_center_y,
                                        0, - direction_y,
                                        SV_arrowHeadLength2 * SV_cell_h
                                    );
                                    draw2.setFillColor_array(DC_diffvis_2_foreground);
                                    draw2.drawArrowHead(
                                        cell_center_x, cell_center_y,
                                        0, - direction_y,
                                        SV_arrowHeadLength2 * SV_cell_h
                                    );
                                    draw2.setLineWidth( 1 ); // TODO_lineWidth
                                }
                                else if ( otherCell_center_x < cell_center_x ) {
                                    // the other cell is north west of the current cell
                                    // TODO I think this case actually never happens, but I'll leave this code here just in case

                                    Util.assert( otherCell_center_y < cell_center_y, "unexpected condition when drawing diffvis for swap" );

                                    draw2.setLineWidth( diffvis_forSwapGates_thickness ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                                    draw2.drawSpline(
                                        otherCell_center_x, otherCell_center_y, cell_center_x, cell_center_y,
                                        1, 0, -1, 0,
                                        SV_splineTangentWeight, SV_splineTangentWeight
                                    );
                                    draw2.setFillColor_array(DC_diffvis_1_foreground);
                                    draw2.drawArrowHead(
                                        otherCell_center_x, otherCell_center_y,
                                        -1, 0,
                                        SV_arrowHeadLength2 * SV_cell_h
                                    );
                                    draw2.setFillColor_array(DC_diffvis_2_foreground);
                                    draw2.drawArrowHead(
                                        cell_center_x, cell_center_y,
                                        1, 0,
                                        SV_arrowHeadLength2 * SV_cell_h
                                    );
                                    draw2.setLineWidth( 1 ); // TODO_lineWidth
                                }
                                else {
                                    // the other cell is north east of the current cell
                                    Util.assert( otherCell_center_y < cell_center_y, "unexpected condition when drawing diffvis for swap" );

                                    draw2.setLineWidth( diffvis_forSwapGates_thickness ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                                    draw2.drawSpline(
                                        otherCell_center_x, otherCell_center_y, cell_center_x, cell_center_y,
                                        -1, 0, 1, 0,
                                        SV_splineTangentWeight, SV_splineTangentWeight
                                    );
                                    draw2.setFillColor_array(DC_diffvis_1_foreground);
                                    draw2.drawArrowHead(
                                        otherCell_center_x, otherCell_center_y,
                                        1, 0,
                                        SV_arrowHeadLength2 * SV_cell_h
                                    );
                                    draw2.setFillColor_array(DC_diffvis_2_foreground);
                                    draw2.drawArrowHead(
                                        cell_center_x, cell_center_y,
                                        -1, 0,
                                        SV_arrowHeadLength2 * SV_cell_h
                                    );
                                    draw2.setLineWidth( 1 ); // TODO_lineWidth
                                }
                            }
                        }
                    }
                }
            }

            if ( diffvis_showSplinesConnectingHalfBlocks && state === C.stateVectors[ stage ]._rows -1 ) {
                // We have reached the last cell of the stage,
                // so we need to trigger the drawing of the spline for the last
                // groups of 'earlier' and 'later' cells.

                diffvis_listOfCellCenters_earlierCells_complete = diffvis_listOfCellCenters_earlierCells_inProgress;
                diffvis_listOfCellCenters_laterCells_complete = diffvis_listOfCellCenters_laterCells_inProgress;
                diffvis_listOfCellCenters_earlierCells_inProgress = [];
                diffvis_listOfCellCenters_laterCells_inProgress = [];

                diffvis_drawSplineUsingListsOfCellCenters = true;
            }

            // draw spline for diffvis
            if ( diffvis_drawSplineUsingListsOfCellCenters ) {
                const biggerArrowHeadFactor = 1.8;
                let center_earlier = Vec2.centroid( diffvis_listOfCellCenters_earlierCells_complete );
                let center_later = Vec2.centroid( diffvis_listOfCellCenters_laterCells_complete );
                if ( diffvis_gateWire < SV_numColBits ) {
                    // draw spline above the StateVectorVisualization1
                    let y = _y0 - SV_cell_h/2;
                    let delta = Math.abs( center_later.x - center_earlier.x );
                    draw2.drawSpline(
                        center_earlier.x, y,
                        center_later.x, y,
                        1, -2, -1, -2,
                        SV_splineTangentWeight, SV_splineTangentWeight
                    );

                    let arrowHeadLength = biggerArrowHeadFactor * SV_arrowHeadLength * delta;
                    if ( arrowHeadLength < SV_cell_h/2 ) arrowHeadLength = SV_cell_h/2;
                    else if ( arrowHeadLength > SV_cell_h ) arrowHeadLength = SV_cell_h;

                    draw2.setFillColor_array(DC_diffvis_1_foreground);
                    if ( diffvis_showArithmeticOperatorsOnSpline )
                        draw2.drawArithmeticOperator( center_earlier.x, y, arrowHeadLength, "+" );
                    else
                        draw2.drawArrowHead(
                            center_earlier.x, y,
                            -1, 2,
                            arrowHeadLength
                        );
                    draw2.setFillColor_array(DC_diffvis_2_foreground);
                    if ( diffvis_showArithmeticOperatorsOnSpline )
                        draw2.drawArithmeticOperator( center_later.x, y, arrowHeadLength, "-" );
                    else
                        draw2.drawArrowHead(
                            center_later.x, y,
                            1, 2,
                            arrowHeadLength
                        );
                }
                else {
                    // draw spline to the right of the StateVectorVisualization1
                    let margin = SV_cell_h/2;
                    let x = _x0 + SV_col_w + margin;
                    let delta = Math.abs( center_later.y - center_earlier.y );
                    draw2.drawSpline(
                        x, center_earlier.y,
                        x, center_later.y,
                        2, 1, 2, -1,
                        SV_splineTangentWeight, SV_splineTangentWeight,
                        SV_col_w - 2*margin
                    );

                    let arrowHeadLength = biggerArrowHeadFactor * SV_arrowHeadLength * delta;
                    if ( arrowHeadLength < SV_cell_h/3 ) arrowHeadLength = SV_cell_h/3;
                    else if ( arrowHeadLength > SV_cell_h ) arrowHeadLength = SV_cell_h;

                    draw2.setFillColor_array(DC_diffvis_1_foreground);
                    if ( diffvis_showArithmeticOperatorsOnSpline )
                        draw2.drawArithmeticOperator( x, center_earlier.y, arrowHeadLength, "+" );
                    else
                        draw2.drawArrowHead(
                            x, center_earlier.y,
                            -2, -1,
                            arrowHeadLength
                        );
                    draw2.setFillColor_array(DC_diffvis_2_foreground);
                    if ( diffvis_showArithmeticOperatorsOnSpline )
                        draw2.drawArithmeticOperator( x, center_later.y, arrowHeadLength, "-" );
                    else
                        draw2.drawArrowHead(
                            x, center_later.y,
                            -2, 1,
                            arrowHeadLength
                        );
                }
            }

        } // for state

        if ( drawTextOutsideCells ) {
            // draw the bit strings outside the cells
            draw2.setFillColor_array(DC_foreground);
            draw2.setStrokeColor_array(DC_highlight_wire);

            // This is necessary because, without this shift, the bitstrings are sometimes drawn on top of diffvis visual feedback
            let shift_x = ( stage < C.numStages ) ? PLV_space_w : 0;

            if ( true ) {
                if ( SV_numCols===1 ) {
                    for ( let state = 0; state < C.stateVectors[ stage ]._rows; ++state ) {
                        // upper-left corner of the (state)th cell
                        let cell_x0 = _x0;
                        let cell_y0 = _y0 + state * SV_cell_h;

                        draw2.drawStringCenteredInRectangle(
                            new Box2(
                                new Vec2( cell_x0+SV_cell_w+shift_x, cell_y0 ),
                                new Vec2( cell_x0+SV_cell_w+shift_x+SV_cell_h*DispOpt.OUTSIDE_BITSTRING_ASPECTRATIO, cell_y0+SV_cell_h )
                            ),
                            StringUtil.intToBinaryString( state, C.numWires ),
                            margin,
                            TD_HORIZONTALLY_RIGHT,
                            C.numWires-1 - highlightedBit, // index of char to highlight
                            length_of_substring_in_bitstring_to_highlight // this may be zero, which will just suppress the highlighting
                        );
                    }
                }
                else {
                    // labels for rows
                    for ( let r = 0; r < SV_numRows; ++r ) {
                        // upper-left corner of left-most cell within the (r)th row
                        let cell_x0 = _x0;
                        let cell_y0 = _y0 + r * SV_cell_h;

                        draw2.drawStringCenteredInRectangle(
                            new Box2(
                                new Vec2( cell_x0+SV_col_w+shift_x, cell_y0 ),
                                new Vec2( cell_x0+SV_col_w+shift_x+SV_cell_h*DispOpt.OUTSIDE_BITSTRING_ASPECTRATIO, cell_y0+SV_cell_h )
                            ),
                            StringUtil.intToBinaryString( r, SV_numRowBits ) + '…',
                            margin,
                            TD_HORIZONTALLY_RIGHT,
                            C.numWires-1 - highlightedBit, // index of char to highlight. if out of bounds, highlighting is just suppressed.
                            length_of_substring_in_bitstring_to_highlight // this may be zero, which will just suppress the highlighting
                        );
                    }
                    // labels for columns
                    for ( let c = 0; c < SV_numCols; ++c ) {
                        // upper-left corner of top-most cell within the (c)th column
                        let cell_x0 = _x0 + c * SV_cell_w;
                        let cell_y0 = _y0;

                        draw2.drawStringCenteredInRectangle(
                            new Box2(
                                new Vec2( cell_x0, cell_y0 + SV_cell_h * SV_numRows ),
                                new Vec2( cell_x0 + SV_cell_w, cell_y0 + SV_cell_h * (SV_numRows+DispOpt.OUTSIDE_BITSTRING_ASPECTRATIO) )
                            ),
                            '…' + StringUtil.intToBinaryString( c, SV_numColBits ),
                            margin,
                            TD_VERTICALLY_DOWN,
                            SV_numColBits - highlightedBit, // index of char to highlight. if out of bounds, highlighting is just suppressed.
                            length_of_substring_in_bitstring_to_highlight // this may be zero, which will just suppress the highlighting
                        );
                    }
                }
            }
        } // if drawTextOutsideCells
    }
    drawStateVectorTooltip( /*world*/x0, /*world*/y0, /*circuit*/C, /*int*/layer, /*int*/state ) {
        // TODO not implemented
    }
    drawCircuitView( draw2 ) {
        let rect = this.getBoundingRect();
        draw2.setFillColor_array(DC_background2);
        draw2.fillRect(rect.min.x,rect.min.y,rect.width(),rect.height());

        // draw wires
        for ( let w = 0; w < this.circuit.numWires; ++w ) {
            if ( w === this.highlighted_wire || w === this.highlighted_wire2 ) {
                draw2.setLineWidth( 7 ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                draw2.setStrokeColor_array(DC_highlight_wire);
            }
            else {
                draw2.setLineWidth( 5 ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                draw2.setStrokeColor_array(DC_foreground);
            }
            draw2.drawLine( -0.5, w+0.5, this.circuit.numStages+0.5, w+0.5 );
        }

        if (
            ( this.highlighted_mode === CVH_PLV_LOCALSTATE || this.highlighted_mode === CVH_PLV_STATEVECTOR )
            && this.highlighted_stage >= 0
        ) {
            // draw vertical line segment
            draw2.setLineWidth( 3 ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
            draw2.setStrokeColor_array(DC_highlight_wire);
            draw2.drawLine( this.highlighted_stage, 0, this.highlighted_stage, this.circuit.numWires );
        }

        // draw circuit parts
        for ( let s = 0; s < this.circuit.numStages; ++s ) {

            let numCircuitParts = 0;
            let hasControlBits = false;
            let numSwapParts = 0;
            let min_w_of_any_part = -1;
            let max_w_of_any_part = -1;
            let min_w_of_swap_part = -1;
            let max_w_of_swap_part = -1;

            for ( let w = 0; w < this.circuit.numWires; ++w ) {
                let circuitPart_id = this.circuit.getCircuitPartIDOfCell(w,s);
                if ( circuitPart_id >= 0 ) {
                    numCircuitParts ++;
                    if ( numCircuitParts === 1 )
                        min_w_of_any_part = w;
                    max_w_of_any_part = w;
                    if ( circuitPart_id === CP_CB || circuitPart_id === CP_ACB ) {
                        hasControlBits = true;
                    }
                    else if ( circuitPart_id === CP_SWAP ) {
                        numSwapParts ++;
                        if ( numSwapParts === 1 )
                            min_w_of_swap_part = w;
                        max_w_of_swap_part = w;
                    }
                }
            }

            // draw vertical line segment connecting control bits or swap gate parts
            draw2.setLineWidth(3); // TODO_lineWidth should be scale dependent
            draw2.setStrokeColor_array(DC_foreground);
            if ( hasControlBits ) {
                draw2.drawLine( s+0.5, min_w_of_any_part+0.5, s+0.5, max_w_of_any_part+0.5 );
            }
            else if ( numSwapParts === 2 ) {
                draw2.drawLine( s+0.5, min_w_of_swap_part+0.5, s+0.5, max_w_of_swap_part+0.5 );
            }

            // draw circuit part
            for ( let w = 0; w < this.circuit.numWires; ++w ) {
                let circuitPart = this.circuit.getCellContents(w,s);
                let circuitPart_id = this.circuit.getCircuitPartIDOfCell(w,s);
                if ( circuitPart_id >= 0 ) {
                    if ( circuitPart.isParametric() ) {
                        draw2.drawImage(empty_icon_image, s, w, 1, 1 );
                        let margin = circuitPart.getMargin();
                        let x0 = s + margin;
                        let textHeight = circuitPart.getHeightOfParameterString();
                        drawTextLabelWithOutline( x0, w+margin+textHeight, circuitPart.getName(),false,true,false,textHeight);
                        for ( let i = 0; i < circuitPart.getNumParameters(); ++i ) {
                            if (
                                this.highlighted_mode === CVH_CIRCUIT
                                && w === this.highlighted_wire && s === this.highlighted_stage
                            ) {
                                if ( this.highlighted_circuitPart_parameter === i ) {
                                    draw2.setFillColor_array(DC_highlight_icon);
                                    draw2.fillRect( x0, w+margin+(i+1)*textHeight, 1-2*margin, textHeight );
                                }
                            }
                            if (
                                this.selected_circuitPart_isAnythingSelected
                                && w === this.selected_circuitPart_wire && s === this.selected_circuitPart_stage
                            ) {
                                if ( this.selected_circuitPart_parameter === i ) {
                                    draw2.setLineWidth( 2 ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                                    draw2.setStrokeColor_array(DC_highlight_icon);
                                    draw2.drawRect( x0, w+margin+(i+1)*textHeight, 1-2*margin, textHeight );
                                }
                            }
                            drawTextLabelWithOutline( x0, w+margin+(i+2)*textHeight, circuitPart.getParameterAsString(i),false,false,false,textHeight);
                        }
                    }
                    else {
                        draw2.drawImage(circuitPart.getImage(), s, w, 1, 1 );
                    }
                    if (
                        this.highlighted_mode === CVH_CIRCUIT
                        && w === this.highlighted_wire && s === this.highlighted_stage
                    ) {
                        draw2.setLineWidth( 3 ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                        draw2.setStrokeColor_array(DC_highlight_icon);
                        draw2.drawRect(s,w,1,1);
                    }
                    if (
                        this.selected_circuitPart_isAnythingSelected
                        && w === this.selected_circuitPart_wire
                        && s === this.selected_circuitPart_stage
                    ) {
                        draw2.setLineWidth( 5 ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                        draw2.setStrokeColor_array(DC_highlight_icon);
                        let a = 0.3;
                        draw2.drawLine( s, w, s+a, w );
                        draw2.drawLine( s+1-a, w, s+1, w );
                        draw2.drawLine( s, w+1, s+a, w+1 );
                        draw2.drawLine( s+1-a, w+1, s+1, w+1 );

                        draw2.drawLine( s, w, s, w+a );
                        draw2.drawLine( s, w+1-a, s, w+1 );
                        draw2.drawLine( s+1, w, s+1, w+a );
                        draw2.drawLine( s+1, w+1-a, s+1, w+1 );
                    }
                }
            }
            // draw drop candidate
            if ( this.hasDropCandidate ) {
                draw2.setLineWidth( 3 ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                draw2.setStrokeColor_array(DC_highlight_dropSite);
                draw2.drawRect(this.drop_stage - (this.drop_insertBeforeTheGivenStage?0.5:0.0),this.drop_wire,1,1);


                let isUserHoveringOnNewQubit = ( this.drop_wire===this.circuit.numWires );
                draw2.setCoordinateSystemToPixels();
                let p_pixels = draw2.convertWorldSpaceUnitsToPixels(
                    new Vec2(
                        isUserHoveringOnNewQubit
                            ? this.drop_stage - (this.drop_insertBeforeTheGivenStage?0.5:0.0) // the text will snap to the same x coordinate as the drop target
                            : mouse_x_world, // the text will follow the mouse cursor's x coordinate
                        this.circuit.numWires
                    )
                );
                let m = 5; // margin, in pixels
                p_pixels.x += m;
                p_pixels.y += m;
                //if ( false ) {
                //    let rect = new Box2(
                //        new Vec2( p_pixels.x, p_pixels.y ),
                //        new Vec2( p_pixels.x + FC_SIZE, p_pixels.y + FC_SIZE ),
                //    );
                //    draw2.setFillColor_array( isUserHoveringOnNewQubit ? DC_highlight_icon : DC_background2 );
                //    draw2.fillRect(rect.min.x,rect.min.y,rect.width(),rect.height());
                //    draw2.setStrokeColor_array( DC_foreground );
                //    draw2.setLineWidth( 1 ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                //    draw2.drawRect(rect.min.x,rect.min.y,rect.width(),rect.height());
                //    let center = rect.center();
                //    let radius = 0.75 * FC_SIZE / 2;
                //    draw2.drawLine( center.x-radius, center.y, center.x+radius, center.y );
                //    draw2.drawLine( center.x, center.y-radius, center.x, center.y+radius );
                //    p_pixels.x += FC_SIZE + m;
                //}
                draw2.setFillColor_array( DC_highlight_icon );
                draw2.drawString(
                    p_pixels.x, p_pixels.y + FC_SIZE,  // left extremity of the baseline of the string (near the lower-left corner of the string)
                    (isUserHoveringOnNewQubit?"Drop here":"↓ Drag down lower ↓")+" to add new qubit",     // the string
                    FC_SIZE, // the desired height
                    TD_HORIZONTALLY_RIGHT
                );
                draw2.setCoordinateSystemToWorldSpaceUnits();
            }
        }

        // make sure that all the circuit per-stage state vectors and stats are up-to-date
        this.circuit.runIfNecessary();

        if ( DispOpt.showFinalLocalState ) {
            this.drawLocalState( FV_LS_x0, 0, this.circuit, this.circuit.numStages, false, 1.0 );
        }

        draw2.setStrokeColor_array(DC_foreground);

        if ( DispOpt.showFinalHalfMatrix ) {
            this.drawHalfMatrix( FV_HM_center_x0, FV_HM_center_y0, this.circuit, this.circuit.numStages, false );
        }

        if ( DispOpt.showLocalStatePerLayer || DispOpt.showStateVectorsPerLayer ) {

            // draw visualization of local state and/or state vectors, per layer
            draw2.setLineWidth(1);
            draw2.setStrokeColor_array(DC_foreground);
            if (
                0 <= mouse_x_world && mouse_x_world <= this.circuit.numStages
                && 0 <= mouse_y_world && mouse_y_world <= this.circuit.numWires
            ) {
                PLV_mostRecentForScrolling_mouse_x_world = mouse_x_world;
            }
            if ( true ) {
                // Imagine a linear function y=A*x+B where x is the (clamped) x position of the mouse in world space,
                // and y is the left-most x position of a rectangle encompassing the state vector visualizations for all the stages.
                // We are particularly interested in the values at
                //     x=0.5, where the mouse is in the middle of the 0th stage, and y is at a maximum;
                //     x=(numStages-0.5), where the mouse is in the middle of the last stage, and y is at a minimum.
                // BEGIN: find A and B

                //
                // This is the y value when x=x1=0.5
                let y1 = -( PLV_col_w + PLV_space_w/2 - 0.5 );
                // This is the y value when x=x2=(numStages-0.5)
                let y2 = -(PLV_total_w - PLV_col_w - PLV_space_w/2 - (this.circuit.numStages-0.5));
                // find the slope
                let A = this.circuit.numStages > 1 ? (y2-y1)/(this.circuit.numStages-1) : 0;
                // find the intercept
                let B = y1 - A*0.5;
                //
                // END

                let mxw_clamped = PLV_mostRecentForScrolling_mouse_x_world; // mxw_ means mouse_x_world_
                if ( mxw_clamped < 0.5 ) mxw_clamped = 0.5;
                else if ( mxw_clamped > this.circuit.numStages-0.5 ) mxw_clamped = this.circuit.numStages-0.5;

                if ( DispOpt.scrollPerLayerVisHorizontally ) {
                    // Use the linear function to find the left-most x position of the rectangle containing the state vector vis for all stages
                    PLV_x0 = A*mxw_clamped + B;
                }
                else {
                    PLV_x0 = -( PLV_total_w - this.circuit.numStages )/2;
                }

                PLV_SV_x0 = PLV_x0 + (PLV_col_w - SV_col_w)/2;
                PLV_LS_x0 = PLV_x0 + (PLV_col_w - LS_W)/2;

                PLV_stage = Math.floor(mxw_clamped);
                PLV_stage_fractionalPart = mxw_clamped - PLV_stage;
            }
            // draw2.drawRect( PLV_SV_x0, PLV_SV_y0, PLV_total_w, SV_total_h );
            let minStage = 0;
            let maxStage = this.circuit.numStages;
            if ( ! DispOpt.showVisOfAllLayers ) {
                minStage = Math.max(0,PLV_stage-1);
                maxStage = Math.min(PLV_stage+2,this.circuit.numStages);
            }


            for ( let pass = 1; pass <= 2; ++pass ) {
                for ( let stage = minStage; stage <= maxStage; ++stage ) {

                    let C = this.circuit;
                    let _x0 = PLV_x0 + stage*( PLV_col_w + PLV_space_w );
                    let _y0 = PLV_y0;

                    let alpha = 1;
                    if ( ! DispOpt.showVisOfAllLayers ) {
                        if ( stage === PLV_stage-1 ) {
                            alpha = 2*( 1-PLV_stage_fractionalPart )-1;
                        }
                        else if ( stage === PLV_stage+2 ) {
                            alpha = 2 * PLV_stage_fractionalPart -1;
                        }
                    }
                    draw2.setStrokeColor(DC_foreground[0],DC_foreground[1],DC_foreground[2],alpha);
                    draw2.setFillColor(DC_shadow[0],DC_shadow[1],DC_shadow[2],alpha);

                    if ( pass === 1 ) {
                        // draw triangular shadow
                        let shadow_left_x = ( DispOpt.showLocalStatePerLayer ? PLV_LS_x0 : PLV_SV_x0 ) + stage*( PLV_col_w + PLV_space_w );
                        let shadow_right_x = shadow_left_x + ( DispOpt.showLocalStatePerLayer ? LS_W : SV_col_w );
                        draw2.fillPolygon( [
                            new Vec2(shadow_left_x,_y0), new Vec2(shadow_right_x,_y0), // base of shadow
                            new Vec2(stage,C.numWires) // top of shadow
                        ]);
                    }

                    if ( alpha < 0.7 )
                        // don't bother drawing the rest of the StateVectorVisualization1,
                        // because it ends up interfering with other visual feedback
                        continue; // TODO fading: are we happy with this ? you could also try doing "alpha *= 2;" to make it fade faster, or have a threshold like "if ( alpha < 0.5 )", or increasing the horizontal spacing (PLV_space_w) between state vectors


                    if ( pass === 2 ) {
                        let drawDiffVis = DispOpt.show_diffvis===DispOpt.DIFFVIS_ALL || (DispOpt.show_diffvis===DispOpt.DIFFVIS_ONE && stage === PLV_stage);

                        if ( DispOpt.showLocalStatePerLayer )
                            this.drawLocalState( PLV_LS_x0 + stage*( PLV_col_w + PLV_space_w ), _y0, C, stage, drawDiffVis /*TODO_diff not yet used*/, alpha );

                        if ( DispOpt.showStateVectorsPerLayer ) {
                            let drawTextInsideCells = (DispOpt.showVisOfAllLayers || (stage === PLV_stage || stage === PLV_stage+1)) && (DispOpt.displayInsideBitstring || DispOpt.displayInsideProbability);
                            let drawTextOutsideCells = ((stage === C.numStages) || (! DispOpt.showVisOfAllLayers && (stage === PLV_stage+1))) && DispOpt.displayOutsideBitstring;
                            this.drawStateVector( PLV_SV_x0 + stage*( PLV_col_w + PLV_space_w ), PLV_SV_y0, C, stage, drawDiffVis, drawTextInsideCells, drawTextOutsideCells, this.highlighted_wire, alpha );
                        }
                    }

                } // for stage
            } // for pass
        }

        // draw tooltip for halfmatrix
        if ( DispOpt.showFinalHalfMatrix ) {
            // draw tooltip
            if ( this.highlighted_mode === CVH_FV_HALFMATRIX ) {
                this.drawHalfMatrixTooltip( FV_HM_center_x0, FV_HM_center_y0, this.circuit, this.circuit.numStages, this.highlighted_wire, this.highlighted_wire2 );
            }
        }

        // draw tooltip for Local State (LS)
        if ( this.highlighted_mode === CVH_FV_LOCALSTATE ) {
            this.drawLocalStateTooltip( FV_LS_x0, this.highlighted_wire, this.circuit, this.circuit.numStages, this.highlighted_wire, true );
        }
        else if ( this.highlighted_mode === CVH_PLV_LOCALSTATE ) {
            this.drawLocalStateTooltip( PLV_LS_x0 + this.highlighted_stage*( PLV_col_w + PLV_space_w ), PLV_y0 + this.highlighted_wire, this.circuit, this.highlighted_stage, this.highlighted_wire, false );
        }
    }
    // Only called if nothing is being dragged.
    drawTooltip(
        draw2,
        x_pixels, y_pixels
    ) {
        // XXX
        if ( this.highlighted_mode === CVH_NOTHING )
            return;

        let s = "";
        if ( this.highlighted_mode === CVH_FV_HALFMATRIX ) {
            if ( ! DispOpt.showOriginalHalfmatrixTooltip )
                return;

            let row = this.highlighted_wire;
            let col = this.highlighted_wire2;
            let C = this.circuit;
            let precision = 3;
            let numMetricsLeft = DispOpt.HM_numMetrics;

            if ( DispOpt.HM_showPurity ) { s += "Purity=" + StringUtil.numToString(C.pairwisePurities.get(row,col)._r,precision);                   numMetricsLeft--; if ( numMetricsLeft > 0 ) s += "; "; }
            if ( DispOpt.HM_showLinearEntropy ) { s += "L. Entropy=" + StringUtil.numToString(1-C.pairwisePurities.get(row,col)._r,precision);      numMetricsLeft--; if ( numMetricsLeft > 0 ) s += "; "; }
            if ( DispOpt.HM_showVonNeumannEntropy ) { s += "V.N. Entropy=" + StringUtil.numToString(C.pairwiseEntropies.get(row,col)._r,precision); numMetricsLeft--; if ( numMetricsLeft > 0 ) s += "; "; }
            if ( DispOpt.HM_showConcurrence ) { s += "Concurrence=" + StringUtil.numToString(C.pairwiseConcurrences.get(row,col)._r,precision);     numMetricsLeft--; if ( numMetricsLeft > 0 ) s += "; "; }
            if ( DispOpt.HM_showCorrelation ) { s += "Correlation=" + StringUtil.numToString(C.pairwiseCorrelations.get(row,col)._r,precision);     numMetricsLeft--; }
        }
        else if ( this.highlighted_mode === CVH_FV_LOCALSTATE ) {
            if ( ! DispOpt.showOriginalLSTooltip )
                return;
            s = "Purity=" + StringUtil.numToString( this.circuit.perQubitStats[this.circuit.numStages][this.highlighted_wire].purity._r, 3 );
        }
        else if ( this.highlighted_mode === CVH_PLV_LOCALSTATE ) {
            return;
        }
        else if ( this.highlighted_mode === CVH_PLV_STATEVECTOR ) {
            if ( this.highlighted_baseState < 0 )
                return;
            let amplitude = this.circuit.stateVectors[ this.highlighted_stage ].get(0,this.highlighted_baseState);
            let magnitude = amplitude.mag();
            let probability = magnitude * magnitude;
            let phase = amplitude.arg() / Math.PI * 180;
            if ( phase > 180 ) phase -= 360;
            s = StringUtil.intToBinaryString( this.highlighted_baseState, this.circuit.numWires )
                + " mag:" + StringUtil.numToString( magnitude )
                + " prob:" + StringUtil.numToString( probability )
                + " phase:" + StringUtil.numToString( phase ) + "°";
        }
        else if ( this.highlighted_mode === CVH_CIRCUIT ) {
            if ( this.highlighted_circuitPart !== null ) {
                if ( this.highlighted_circuitPart_parameter >= 0 /* a parameter is highlighted */ )
                    s = (this.dragMode === CV_DM_NOT_DRAGGING) ? "Ctrl+drag left-right to adjust; Shift+drag to snap" : "";
                else
                    s = this.highlighted_circuitPart.getTooltip();
            }
            else if ( this.highlighted_wire >= 0 && this.highlighted_wire < this.circuit.numWires )
                s = "qubit " + this.highlighted_wire;
            else return;
        }

        if ( s.length > 0 )
            drawTextLabelWithOutline( x_pixels, y_pixels, s, true, true, true, TOOLTIP_SIZE );
    }
    // Only called if something is being dragged.
    drawObjectBeingDragged(
        draw2,
        x_pixels, y_pixels,
        infoAboutObjectBeingDragged // an object of the form {obj:reference}
    ) {
    }
    // Returns a boolean
    isUnder( x_pixels, y_pixels, x_world, y_world ) {
        return this.getBoundingRect().containsPoint( new Vec2( x_world, y_world ) );
    }
    // XXX we are in the CircuitViewer class
    // Returns an object of the form { redraw:boolean, initiatesDragAndDrop:boolean, objectBeingDragged:reference }
    widget_mousePress(
        x_pixels, y_pixels, x_world, y_world,
        mouseButton, // one of MW_BUTTON_...
        buttonAndKeyState // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
    ) {
        if ( verboseEvents ) console.log(`entering widget_mousePress with dragMode===${this.dragMode} and mouseButton===${mouseButton}`);
        let ctrlMod = buttonAndKeyState & MW_KEY_CONTROL;
        let shiftMod = buttonAndKeyState & MW_KEY_SHIFT;

        let didUserPressOnACircuitPart = false;
        let didUserPressOnAParameter = false;
        if (
            this.highlighted_circuitPart !== null
            && this.highlighted_wire >= 0 && this.highlighted_stage >= 0
        ) {
            this.selected_circuitPart_isAnythingSelected = true;
            this.selected_circuitPart_wire = this.highlighted_wire;
            this.selected_circuitPart_stage = this.highlighted_stage;
            didUserPressOnACircuitPart = true;
            this.selected_circuitPart_parameter = this.highlighted_circuitPart_parameter;
            if ( this.selected_circuitPart_parameter >= 0 ) {
                didUserPressOnAParameter = true;
            }
        }
        else {
            this.selected_circuitPart_isAnythingSelected = false;
            this.selected_circuitPart_wire = -1;
            this.selected_circuitPart_stage = -1;
            this.selected_circuitPart_parameter = -1;
        }

        this.dragMode = CV_DM_DRAGGING_NOTHING;
        if ( didUserPressOnACircuitPart ) {
            if ( mouseButton === MW_BUTTON_LEFT ) {
                if ( ctrlMod && ! shiftMod && didUserPressOnAParameter )
                    this.dragMode = CV_DM_PARAMETER_DRAG;
                else if ( shiftMod && ! ctrlMod && didUserPressOnAParameter )
                    this.dragMode = CV_DM_PARAMETER_DRAG_WITH_SNAPPING;
                else if ( ! ctrlMod && ! shiftMod )
                    this.dragMode = CV_DM_TENTATIVE_DRAG_AND_DROP;
                this.drag_x0_pixels = x_pixels;
                this.drag_parameterValueAtStart = 0;
                if ( didUserPressOnAParameter && this.highlighted_circuitPart !== null && this.highlighted_circuitPart_parameter >= 0 ) {
                    this.drag_parameterValueAtStart = this.highlighted_circuitPart.paramValues[ this.highlighted_circuitPart_parameter ];
                }
                this.drag_cumulativeDelta_pixels = 0;
            }
            else if ( mouseButton === MW_BUTTON_MIDDLE ) {
                if ( verboseEvents ) console.log("widget_mousePress delete");
                this.dragMode = CV_DM_DELETE_CIRCUITPART;
            }
        }

        return { redraw: true, initiatesDragAndDrop: false,  objectBeingDragged: null };
    }
    // XXX we are in the CircuitViewer class
    // Returns an object of the form { redraw:boolean, acceptsDragAndDrop:boolean }
    widget_mouseRelease(
        x_pixels, y_pixels, x_world, y_world,
        mouseButton, // one of MW_BUTTON_...
        buttonAndKeyState, // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
        isPartOfDragAndDrop, // if true, the caller is managing events; if false, the widget is managing events
        infoAboutObjectBeingDragged // an object of the form {obj:reference}
    ) {
        if ( verboseEvents ) console.log(`entering widget_mouseRelease with dragMode===${this.dragMode}`);
        Util.assert( isPartOfDragAndDrop === (this.dragMode === CV_DM_DRAG_AND_DROP), "unexpected condition in widget_mouseRelease()" );
        if ( verboseEvents ) console.log(`isPartOfDragAndDrop===${isPartOfDragAndDrop}   dragMode===${this.dragMode}`);

        if ( this.dragMode === CV_DM_DRAG_AND_DROP ) {
            let returnValue = { redraw:true, acceptsDragAndDrop:this.hasDropCandidate };
            if ( infoAboutObjectBeingDragged !== null && this.hasDropCandidate ) {
                this.circuit.addCircuitPart(
                    infoAboutObjectBeingDragged.obj,
                    this.drop_wire,
                    this.drop_stage,
                    this.drop_insertBeforeTheGivenStage
                );
                // We will compactify() and startAnimation() later in widget_cleanUpAfterDragAndDrop()
            }
            this.clearDropCandidate();
            this.dragMode = CV_DM_NOT_DRAGGING;
            return returnValue;
        }
        else if ( this.dragMode === CV_DM_DELETE_CIRCUITPART ) {
            deleteCircuitPart( this.highlighted_wire, this.highlighted_stage );
        }

        this.dragMode = CV_DM_NOT_DRAGGING;
        return { redraw:true, acceptsDragAndDrop:false };
    }
    // Returns an object of the form {redraw:boolean}
    widget_mouseHover(
        x_pixels, y_pixels, x_world, y_world
    ) {
        this.clearDropCandidate();
        let returnValue = this.findHighlightedElements( x_world, y_world );
        if (
            this.highlighted_mode !== returnValue.mode
            || this.highlighted_wire !== returnValue.wire
            || this.highlighted_stage !== returnValue.stage
            || this.highlighted_circuitPart !== returnValue.circuitPart
            || this.highlighted_wire2 !== returnValue.wire2
            || this.highlighted_circuitPart_parameter != returnValue.circuitPart_parameter
            || this.highlighted_baseState != returnValue.baseState
        ) {
            this.highlighted_mode = returnValue.mode;
            this.highlighted_wire = returnValue.wire;
            this.highlighted_stage = returnValue.stage;
            this.highlighted_circuitPart = returnValue.circuitPart;
            this.highlighted_wire2 = returnValue.wire2;
            this.highlighted_circuitPart_parameter = returnValue.circuitPart_parameter;
            this.highlighted_baseState = returnValue.baseState;

            return {redraw:true};
        }
        return {redraw:false};
    }
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_mouseHoverLeave() {
        if ( this.highlighted_mode !== CVH_NOTHING ) {
            this.clearHighlighting();
            return {redraw:true};
        }
        return {redraw:false};
    }
    // XXX we are in the CircuitViewer class
    // Returns an object of the form {redraw:boolean, initiatesDragAndDrop:boolean, objectBeingDragged:reference}
    widget_mouseDrag(
        x_pixels, y_pixels, x_world, y_world,
        buttonAndKeyState, // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
        isPartOfDragAndDrop, // if true, the caller is managing events; if false, the widget is managing events
        infoAboutObjectBeingDragged // null for none, otherwise an object of the form { obj:reference, source:reference }
    ) {
        if ( verboseEvents ) console.log(`entering widget_mouseDrag with dragMode===${this.dragMode}`);
        // The framework might be in the middle of a drag-and-drop action
        // initiated by another widget, in which case we have to transition ourselves
        // into the corresponding mode.
        if ( isPartOfDragAndDrop ) {
            Util.assert( this.dragMode === CV_DM_NOT_DRAGGING || this.dragMode === CV_DM_DRAG_AND_DROP, "unexpected condition in widget_mouseDrag()" );
            this.dragMode = CV_DM_DRAG_AND_DROP;
        }
        else {
            Util.assert( this.dragMode !== CV_DM_DRAG_AND_DROP, "unexpected condition in widget_mouseDrag()" );
        }

        if ( verboseEvents ) console.log(`isPartOfDragAndDrop===${isPartOfDragAndDrop}   dragMode===${this.dragMode}`);

        if (
            this.dragMode === CV_DM_PARAMETER_DRAG
            || this.dragMode === CV_DM_PARAMETER_DRAG_WITH_SNAPPING
        ) {
            this.drag_cumulativeDelta_pixels = x_pixels - this.drag_x0_pixels;
            let paramInfo = this.highlighted_circuitPart.getParamInfo( this.highlighted_circuitPart_parameter );
            let newParamValue = this.drag_parameterValueAtStart + this.drag_cumulativeDelta_pixels * paramInfo.dragIncrement;
            if ( this.dragMode === CV_DM_PARAMETER_DRAG_WITH_SNAPPING ) {
                newParamValue = Math.round( newParamValue / paramInfo.snapIncrement ) * paramInfo.snapIncrement;
            }
            if ( newParamValue < paramInfo.minValue )
                newParamValue = paramInfo.minValue;
            else if ( newParamValue > paramInfo.maxValue )
                newParamValue = paramInfo.maxValue;
            this.highlighted_circuitPart.paramValues[ this.highlighted_circuitPart_parameter ] = newParamValue;
            this.circuit.stateVectorsAndStatsAreDirty = true;
            this.updateURLIfNecessary( false );

            return {redraw:true, initiatesDragAndDrop:false, objectBeingDragged:null};
        }
        else if ( this.dragMode === CV_DM_TENTATIVE_DRAG_AND_DROP ) {
            if ( verboseEvents ) console.log("widget_mouseDrag tentative");
            if ( this.highlighted_circuitPart !== null ) {
                let objectThatWillBeDragged = this.highlighted_circuitPart;
                //let objectThatWillBeDragged_wire = this.highlighted_wire;
                //let objectThatWillBeDragged_stage = this.highlighted_stage;
                this.circuit.clearCell(this.highlighted_wire,this.highlighted_stage);

                this.clearHighlighting();
                let result = this.findCellForDrop( x_world, y_world, objectThatWillBeDragged.getCircuitPartID() );
                this.hasDropCandidate = result.hasDropCandidate;
                this.drop_wire = result.wire;
                this.drop_stage = result.stage;
                this.drop_insertBeforeTheGivenStage = result.insertBeforeTheGivenStage;

                this.dragMode = CV_DM_DRAG_AND_DROP;

                return {
                    redraw: true,
                    initiatesDragAndDrop: true,
                    objectBeingDragged: objectThatWillBeDragged
                };
            }
            else {
                return {redraw:false, initiatesDragAndDrop:false, objectBeingDragged:null};
            }
        }
        else if ( this.dragMode === CV_DM_DRAG_AND_DROP ) {
            if ( verboseEvents ) console.log("widget_mouseDrag dnd");
            this.clearHighlighting();
            if ( infoAboutObjectBeingDragged !== null ) {
                let result = this.findCellForDrop( x_world, y_world, infoAboutObjectBeingDragged.obj.getCircuitPartID() );
                if (
                    this.hasDropCandidate !== result.hasDropCandidate
                    || this.drop_wire !== result.wire
                    || this.drop_stage !== result.stage
                    || this.drop_insertBeforeTheGivenStage !== result.insertBeforeTheGivenStage
                ) {
                    this.hasDropCandidate = result.hasDropCandidate;
                    this.drop_wire = result.wire;
                    this.drop_stage = result.stage;
                    this.drop_insertBeforeTheGivenStage = result.insertBeforeTheGivenStage;
                    return {redraw:true, initiatesDragAndDrop:false, objectBeingDragged:null};
                }
            }
            return {redraw:false, initiatesDragAndDrop:false, objectBeingDragged:null};
        }

        return {redraw:false, initiatesDragAndDrop:false, objectBeingDragged:null};
    }
    // XXX we are in the CircuitViewer class
    // Only invoked during drag-and-drop.
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_mouseDragLeave() {
        if ( this.hasDropCandidate ) {
            this.clearDropCandidate();
            return {redraw:true};
        }
        return {redraw:false};
    }
    // Called if this object was the source and/or sink of a drag-and-drop.
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean} XXX we are in the CircuitViewer class
    widget_cleanUpAfterDragAndDrop(wasSource,wasDestination) {
        // We want to do this regardless of whether we were the source or the destination or both.
        this.clearHighlighting();
        this.clearSelection();
        updateAfterChangeToCircuit();
        return {redraw:true};
    }
    recomputeGeometryOfVisualizations() {
        FV_LS_x0 = this.circuit.numStages + FV_MARGIN_LEFT;

        // Count how many metrics are visible.
        DispOpt.LS_numMetrics = 0;

        if ( DispOpt.LS_showPurity ) DispOpt.LS_numMetrics++;
        if ( DispOpt.LS_showLinearEntropy ) DispOpt.LS_numMetrics++;
        if ( DispOpt.LS_showVonNeumannEntropy ) DispOpt.LS_numMetrics++;
        if ( DispOpt.LS_showProbability ) DispOpt.LS_numMetrics++;
        if ( DispOpt.LS_showPhase ) DispOpt.LS_numMetrics++;
        LS_W = DispOpt.LS_numMetrics * 0.5;
        if ( LS_W < 0.5 ) LS_W = 0.5;

        FV_HM_center_x0 = this.circuit.numStages + FV_MARGIN_LEFT + ( DispOpt.showFinalLocalState ? LS_W : 0 ) + this.circuit.numWires / 2;
        FV_HM_center_y0 = this.circuit.numWires / 2;
        // Count how many metrics are visible.
        DispOpt.HM_numMetrics = 0;
        if ( DispOpt.HM_showPurity ) DispOpt.HM_numMetrics ++;
        if ( DispOpt.HM_showLinearEntropy ) DispOpt.HM_numMetrics ++;
        if ( DispOpt.HM_showVonNeumannEntropy ) DispOpt.HM_numMetrics ++;
        if ( DispOpt.HM_showConcurrence ) DispOpt.HM_numMetrics ++;
        if ( DispOpt.HM_showCorrelation ) DispOpt.HM_numMetrics ++;

        // PLV_SV_x0 = ... // this gets recomputed inside drawCircuitView()
        // PLV_stage = ... // this gets recomputed inside drawCircuitView()
        PLV_y0 = this.circuit.numWires + PLV_space_h_top;
        PLV_SV_y0 = this.circuit.numWires + PLV_space_h_top + ( DispOpt.showLocalStatePerLayer ? this.circuit.numWires + PLV_space_h : 0 );
        if ( ! DispOpt.allowMultipleColumns ) {
            SV_numRows = 2**this.circuit.numWires;
            SV_numCols = 1;
        }
        else {
            let N = 2**this.circuit.numWires;
            let ideal_num_cols = Math.sqrt( N / DispOpt.cell_aspectRatio );
            SV_numCols = 2 ** Math.floor(Math.log2( ideal_num_cols ));
            if ( SV_numCols < 1 ) SV_numCols = 1;
            SV_numRows = N / SV_numCols;
        }
        SV_numColBits = Math.round( Math.log2( SV_numCols ) );
        SV_numRowBits = Math.round( Math.log2( SV_numRows ) );
        const maxCellHeight = 1 / 3;
        const maxRatioOfHeightOfStateVectorVisToHeightOfCircuit = 2;
        SV_total_h = maxRatioOfHeightOfStateVectorVisToHeightOfCircuit * this.circuit.numWires;
        SV_cell_h = SV_total_h / SV_numRows;
        if ( SV_cell_h > maxCellHeight ) {
            SV_cell_h = maxCellHeight;
            SV_total_h = SV_numRows * SV_cell_h;
        }
        SV_cell_w = DispOpt.cell_aspectRatio * SV_cell_h;
        PLV_space_w = 3 * SV_cell_h; // SV_numCols * SV_cell_h;
        SV_col_w = SV_numCols * SV_cell_w;
        PLV_col_w = Math.max( DispOpt.showLocalStatePerLayer ? LS_W : 0, DispOpt.showStateVectorsPerLayer ? SV_col_w : 0 );
        PLV_total_w = this.circuit.numStages*( PLV_col_w + PLV_space_w ) + PLV_col_w;
    }
    updateURLIfNecessary( addToBrowsersUndoHistoryToo = true ) {
        let newValue = this.circuit.generateString();
        const urlParams = new URLSearchParams(window.location.search);
        const circuitParamValue = urlParams.get(URL_PARAM_CIRCUIT);
        if ( circuitParamValue === null || circuitParamValue !== newValue ) {
            urlParams.set(URL_PARAM_CIRCUIT, newValue);
            const newUrl = window.location.protocol + "//" + window.location.host + window.location.pathname + '?' + urlParams.toString().replace(/%22/g, '"').replace(/%7B/g, '{').replace(/%7D/g, '}').replace(/%5B/g, '[').replace(/%5D/g, ']').replace(/%3A/g, ':').replace(/%2C/g, ',').replace(/%5E/g, '^');
            if ( addToBrowsersUndoHistoryToo )
                window.history.pushState({path:newUrl},'',newUrl);
            else
                window.history.replaceState({path:newUrl}, '', newUrl);
            // console.log('url updated');

            updateWebpageContent( newValue );
        }
        // else console.log('no update to url necessary');
        return false;
    }
}


const verboseEvents = false; // for debugging


let canvas = document.getElementById("myCanvas");
let canvas_context = canvas.getContext("2d");
let draw2 = new Draw2(canvas);
const FONT_HEIGHT = 20;
draw2.setFontHeight( FONT_HEIGHT );
let toolbar = new Toolbar();
let global_circuit = new Circuit();

// construct a circuit
/*
circuit.addGate(0,CP_H,[]);
circuit.addGate(1,CP_X,[[0,true]]);
circuit.addSwapGate(1,3);
*/

let circuitViewer = new CircuitViewer( global_circuit );
let toolbarHeight_pixels = toolbar.getBoundingRect().height();

let floatingCheckbox1 = new FloatingCheckbox(DispOpt.showStateVectorsPerLayer,"Show state vectors per layer","Hide state vectors per layer",floatingCheckboxCallback,"showStateVectorsPerLayer");
let floatingCheckbox2 = new FloatingCheckbox(DispOpt.showLocalStatePerLayer,"Show local state per layer","Hide local state per layer",floatingCheckboxCallback,"showLocalStatePerLayer");
let floatingCheckbox3 = new FloatingCheckbox(DispOpt.showLocalStatePerLayer,"Show final local state","Hide final local state",floatingCheckboxCallback,"showFinalLocalState");
let floatingCheckbox4 = new FloatingCheckbox(DispOpt.showFinalHalfMatrix,"Show final half matrix","Hide final half matrix",floatingCheckboxCallback,"showFinalHalfMatrix");

function frameCircuit() {
    circuitViewer.frame( draw2, 0, toolbarHeight_pixels, canvas.width, canvas.height-toolbarHeight_pixels );
}

function displayOptionCheckboxCallback( event ) {
    const checkbox = event.target;
    const varName = checkbox.getAttribute('datavar');
    if (typeof DispOpt[varName] === 'boolean') {
        DispOpt[varName] = checkbox.checked;
        // console.log(`${varName} is now ${DispOpt[varName]}`);
        updateAfterChangeToDisplayOptions();
    }
    else console.log( "Unexpected type of datavar " + varName );
}

function displayOptionRadioButtonCallback( event ) {
    const radiobutton = event.target;
    const varName = radiobutton.getAttribute('datavar');
    const varValue = radiobutton.getAttribute('datavarvalue');
    DispOpt[varName] = DispOpt[varValue];
    // console.log(`${varName} is now ${DispOpt[varName]}`);
    updateAfterChangeToDisplayOptions();
}

function floatingCheckboxCallback( state, client_data ) {
    if (typeof DispOpt[client_data] === 'boolean') {
        DispOpt[client_data] = state;
        //console.log(`${client_data} is now ${DispOpt[client_data]}`);
        updateAfterChangeToDisplayOptions();
    }
    else console.log( "Unexpected type of datavar " + varName );
}

function initializeDisplayOptionWidgets() {
    document.querySelectorAll('input[type="checkbox"][datavar]').forEach(checkbox => {
        const varName = checkbox.getAttribute('datavar');
        if (typeof DispOpt[varName] === 'boolean') {
            checkbox.checked = DispOpt[varName];
        }
        else console.log( "Unexpected type of datavar " + varName );
        checkbox.addEventListener('change', displayOptionCheckboxCallback );
    });
    document.querySelectorAll('input[type="radio"][datavar]').forEach(radiobutton => {
        const varName = radiobutton.getAttribute('datavar');
        const varValue = radiobutton.getAttribute('datavarvalue');
        if ( DispOpt[varName] === DispOpt[varValue] ) {
            radiobutton.checked = true;
        }
        radiobutton.addEventListener('change', displayOptionRadioButtonCallback );
    });
}

const QUIRK_LINK_ID = 'quirkLink';
const QUIRK_URL = "https://algassert.com/quirk";
const QUIRK_URL_PREFIX = "https://algassert.com/quirk#circuit=";
const QASM_TEXT_ID = 'qasmText';
const URL_PARAM_CIRCUIT = 'circuit';


function updateWebpageContent( circuitDescribedInString ) {
    // update the quirk link and the OpenQASM text
    let quirkLinkElement = document.getElementById( QUIRK_LINK_ID );
    if (quirkLinkElement)
        quirkLinkElement.href = circuitDescribedInString==="" ? QUIRK_URL : QUIRK_URL_PREFIX + circuitDescribedInString;
    let qasmTextElement = document.getElementById( QASM_TEXT_ID )
    if (qasmTextElement)
        qasmTextElement.textContent = global_circuit.generateQASMString( false );
}

function initializeWithNewCircuit() {
    global_circuit.clear();

    // construct circuit from URL query string
    const urlParams = new URLSearchParams(window.location.search);
    const circuitParamValue = urlParams.get(URL_PARAM_CIRCUIT);
    if ( circuitParamValue !== null ) {
        global_circuit.constructFromString( circuitParamValue );

        updateWebpageContent( circuitParamValue );
    }
    else updateWebpageContent("");

    circuitViewer.recomputeGeometryOfVisualizations();
    frameCircuit();
}
initializeWithNewCircuit();

function clearCircuitButtonHandler() {
    global_circuit.clear();
    circuitViewer.updateURLIfNecessary();
    circuitViewer.recomputeGeometryOfVisualizations();
    frameCircuit();
    draw();
}

function expandCircuitButtonHandler() {
    const checkbox = document.getElementById('useGeneralizedGatesCheckbox');
    const useGeneralizedGates = checkbox.checked;
    //console.log("result: " + useGeneralizedGates );

    saveCurrentZoomAsInitialStateForAnimation();

    global_circuit.expandCircuit( useGeneralizedGates );
    circuitViewer.updateURLIfNecessary();
    circuitViewer.recomputeGeometryOfVisualizations();

    frameCircuit();
    saveCurrentZoomAsFinalStateForAnimation();
    // restoreInitialStateForAnimationAsCurrentZoom();
    startAnimation();
}

const maxQubitsAllowedForComputingSSREMagic = 6;
function printMagicButtonHandler() {
    let n = global_circuit.numWires;
    if ( n <= maxQubitsAllowedForComputingSSREMagic ) {
        let outputStateVector = global_circuit.stateVectors[ global_circuit.numStages ];
        let rho = Sim.computeDensityMatrix( n, outputStateVector );
        let time0 = (new Date()).getTime();
        let magic = Sim.computeSSREMagic( rho, /* useCache? */ n <= 5 );
        let time1 = (new Date()).getTime();
        let timeTaken = time1 - time0; // in milliseconds
        let max_magic = Math.log2(2**n + 1) - 1;
        console.log(`The output state of the circuit has SSRE magic = ${magic}, out of a theoretical max of ${max_magic} for ${n} qubits. Computed in roughly ${timeTaken} milliseconds.`);
    }
    else {
        console.log("Too many qubits to compute magic within a reasonable time. If you think this is too conservative, check the documentation for computeSSREMagic(), and change the constant maxQubitsAllowedForComputingSSREMagic in the source code.");
    }
}

// When the back/forward button is used:
window.addEventListener('popstate', (event) => {
    if ( verboseEvents ) console.log("popstate!!!"); // TODO_loading
    initializeWithNewCircuit();
    draw();
});

function draw() {
    // BEGIN: position the instances of FloatingCheckbox
    //
    let p1_world, p2_world, p3_world, p4_world; // lower right corner, in world space
    if ( DispOpt.showLocalStatePerLayer ) {
        if ( DispOpt.showStateVectorsPerLayer ) {
            p1_world = new Vec2( PLV_x0, PLV_y0+global_circuit.numWires+PLV_space_h+SV_total_h );
        }
        else {
            p1_world = new Vec2( PLV_x0, PLV_y0+global_circuit.numWires );
        }
        p2_world = new Vec2( PLV_x0, PLV_y0+global_circuit.numWires );
    }
    else {
        if ( DispOpt.showStateVectorsPerLayer ) {
            p1_world = new Vec2( PLV_x0, PLV_y0+SV_total_h );
        }
        else {
            p1_world = new Vec2( -0.5, global_circuit.numWires );
        }
        p2_world = new Vec2( -0.5, global_circuit.numWires );
    }
    if ( DispOpt.showFinalLocalState ) {
        if ( DispOpt.showFinalHalfMatrix ) {
            p4_world = new Vec2( FV_HM_center_x0, 0 );
        }
        else {
            p4_world = new Vec2( FV_LS_x0+LS_W, 0 );
        }
        p3_world = new Vec2( FV_LS_x0+LS_W, 0 );
    }
    else {
        if ( DispOpt.showFinalHalfMatrix ) {
            p4_world = new Vec2( FV_HM_center_x0, 0 );
        }
        else {
            p4_world = new Vec2( global_circuit.numStages+0.5, 0 );
        }
        p3_world = new Vec2( global_circuit.numStages+0.5, 0 );
    }
    let m = 5;
    let p_pixels = draw2.convertWorldSpaceUnitsToPixels( p1_world );
    floatingCheckbox1.setPosition( p_pixels.x-FC_SIZE-m, p_pixels.y-FC_SIZE );
    p_pixels = draw2.convertWorldSpaceUnitsToPixels( p2_world );
    floatingCheckbox2.setPosition( p_pixels.x-FC_SIZE-m, p_pixels.y-FC_SIZE );
    if ( floatingCheckbox2.y+FC_SIZE+m > floatingCheckbox1.y )
        floatingCheckbox2.y = floatingCheckbox1.y-FC_SIZE-m;
    p_pixels = draw2.convertWorldSpaceUnitsToPixels( p3_world );
    floatingCheckbox3.setPosition( p_pixels.x-FC_SIZE, p_pixels.y-FC_SIZE-m );
    p_pixels = draw2.convertWorldSpaceUnitsToPixels( p4_world );
    floatingCheckbox4.setPosition( p_pixels.x-FC_SIZE, p_pixels.y-FC_SIZE-m );
    if ( floatingCheckbox3.x+FC_SIZE+m > floatingCheckbox4.x )
        floatingCheckbox3.x = floatingCheckbox4.x-FC_SIZE-m;
    //
    // END

    draw2.clear(DC_background[0],DC_background[1],DC_background[2]);
    draw2.setCoordinateSystemToWorldSpaceUnits();
    circuitViewer.drawCircuitView(draw2);
    draw2.setCoordinateSystemToPixels();
    toolbar.draw(draw2);
    floatingCheckbox1.draw(draw2);
    floatingCheckbox2.draw(draw2);
    floatingCheckbox3.draw(draw2);
    floatingCheckbox4.draw(draw2);
    if ( infoAboutObjectBeingDragged.source === null ) {
        const offset = TOOLTIP_SIZE; // a hack
        toolbar.drawTooltip(draw2,mouse_x,mouse_y+TOOLTIP_SIZE+offset);
        circuitViewer.drawTooltip(draw2,mouse_x,mouse_y-offset);
        floatingCheckbox1.drawTooltip(draw2,mouse_x,mouse_y-offset);
        floatingCheckbox2.drawTooltip(draw2,mouse_x,mouse_y-offset);
        floatingCheckbox3.drawTooltip(draw2,mouse_x,mouse_y-offset);
        floatingCheckbox4.drawTooltip(draw2,mouse_x,mouse_y-offset);
    }
    else {
        // XXX
        infoAboutObjectBeingDragged.source.drawObjectBeingDragged(draw2,mouse_x,mouse_y,infoAboutObjectBeingDragged);
        if ( infoAboutObjectBeingDragged.obj !== null )
            draw2.drawImage( infoAboutObjectBeingDragged.obj.getImage(), mouse_x, mouse_y, TB_ICON_SIZE, TB_ICON_SIZE );
    }
}

// This has been replaced with allImagesLoadedCallback()
//
//// https://stackoverflow.com/questions/951021/what-is-the-javascript-version-of-sleep
//let sleepSetTimeout_id;
//function sleep(ms) {
//    clearTimeout(sleepSetTimeout_id);
//    return new Promise(resolve => sleepSetTimeout_id = setTimeout(resolve, ms));
//}
//async function sleep_then_draw() {
//    await sleep(50); // give time for the icons to "load"
//    draw();
//}
//sleep_then_draw();


function frameButtonHandler() {
    frameCircuit();
    draw();
}

function animatedFrameButtonHandler() {
    saveCurrentZoomAsInitialStateForAnimation();
    frameCircuit();
    saveCurrentZoomAsFinalStateForAnimation();
    startAnimation();
}

function updateAfterChangeToDisplayOptions() {
    saveCurrentZoomAsInitialStateForAnimation();
    circuitViewer.recomputeGeometryOfVisualizations();
    frameCircuit();
    saveCurrentZoomAsFinalStateForAnimation();
    restoreInitialStateForAnimationAsCurrentZoom();
    startAnimation();
}

const ANIMATION_DURATION = 0.5; // in seconds
const ANIMATION_FRAME_RATE = 25; // in frames per second
let animationTimeout_id;
let isAnimationActive = false;
let animationParameter; // varies from 0.0 to 1.0 during animation
let anim_offsetx_initial;
let anim_offsety_initial;
let anim_scalefactor_initial;
let anim_offsetx_final;
let anim_offsety_final;
let anim_scalefactor_final;

function saveCurrentZoomAsInitialStateForAnimation() {
    anim_offsetx_initial = draw2.offsetX_pixels;
    anim_offsety_initial = draw2.offsetY_pixels;
    anim_scalefactor_initial = draw2.scaleFactorInWorldSpaceUnitsPerPixel;
}
function restoreInitialStateForAnimationAsCurrentZoom() {
    draw2.offsetX_pixels = anim_offsetx_initial;
    draw2.offsetY_pixels = anim_offsety_initial;
    draw2.scaleFactorInWorldSpaceUnitsPerPixel = anim_scalefactor_initial;
}
function saveCurrentZoomAsFinalStateForAnimation() {
    anim_offsetx_final = draw2.offsetX_pixels;
    anim_offsety_final = draw2.offsetY_pixels;
    anim_scalefactor_final = draw2.scaleFactorInWorldSpaceUnitsPerPixel;
}

function startAnimation() {
    animationParameter = 0;
    if ( isAnimationActive ) {
        // clear the current animation before starting a new one
        clearInterval( animationTimeout_id );
    }
    animationTimeout_id = setInterval( advanceAnimation, 1000 / ANIMATION_FRAME_RATE );
    isAnimationActive = true;
}
function advanceAnimation() {
    animationParameter += 1.0 / ( ANIMATION_DURATION * ANIMATION_FRAME_RATE );
    if ( animationParameter >= 1.0 ) {
        animationParameter = 1;
        clearInterval( animationTimeout_id );
        isAnimationActive = false;
    }
    //console.log(`advancing ${animationParameter}`);
    let U = animationParameter;
    let oneMinusU = 1-U;
    draw2.offsetX_pixels = oneMinusU*anim_offsetx_initial + U*anim_offsetx_final;
    draw2.offsetY_pixels = oneMinusU*anim_offsety_initial + U*anim_offsety_final;
    draw2.scaleFactorInWorldSpaceUnitsPerPixel = anim_scalefactor_initial * ((anim_scalefactor_final/anim_scalefactor_initial)**U);
    draw();
}

function updateAfterChangeToCircuit() {
    circuitViewer.circuit.compactify();
    saveCurrentZoomAsInitialStateForAnimation();
    circuitViewer.recomputeGeometryOfVisualizations();
    frameCircuit();
    saveCurrentZoomAsFinalStateForAnimation();
    restoreInitialStateForAnimationAsCurrentZoom();
    startAnimation();
    circuitViewer.updateURLIfNecessary();
}

function deleteCircuitPart( wire, stage ) {
    if ( wire >= 0 && stage >= 0 ) {
        circuitViewer.circuit.clearCell( wire, stage );
    }
    circuitViewer.clearHighlighting();
    circuitViewer.clearSelection();

    updateAfterChangeToCircuit();
}

// XXX
const DRAG_MODE_NOT_DRAGGING = 0;
const DRAG_MODE_MANAGED_BY_WIDGET = 1; // the widget interprets the drag as it sees fit
const DRAG_MODE_DRAG_AND_DROP = 2; // the framework implements drag-and-drop between widgets with this
const DRAG_MODE_TRANSLATE = 3;
const DRAG_MODE_ZOOM = 4;
const DRAG_MODE_DRAGGING_NOTHING = 5;
let currentDragMode = DRAG_MODE_NOT_DRAGGING;

// The MEB_ prefix means MouseEvent.button
const MEB_BUTTON_LEFT = 0;
const MEB_BUTTON_MIDDLE = 1;
const MEB_BUTTON_RIGHT = 2;


// This contains an 'OR'ing of MW_BUTTON_... and MW_KEY_... values.
let global_buttonAndKeyState = 0;


let mouse_x=0, mouse_y=0;
let mouse_x_world = 0, mouse_y_world = 0;

let widgetUnderMouse = null; // could be toolbar or circuitViewer or a floatingCheckbox... or null

let infoAboutObjectBeingDragged = { obj: null, source: null /* could be toolbar or circuitViewer or null */ };

// Returns a modified copy of sourceValue where one of the bits is turned on or off.
// The bit to modify is identified by bitMask, which must contain a single 1 bit at the desired location.
// The value to set the bit to is given by the boolean targetBitValue.
// Examples:
//     setBit( sourceValue, 4, true ) returns sourceValue with the 3rd least-significant bit turned on;
//     setBit( sourceValue, 8, false ) returns sourceValue with the 4th least-significant bit turned off
function setBit( sourceValue, bitMask, targetBitValue ) {
    return targetBitValue
        ? ( sourceValue | bitMask ) // turn on the bit
        : ( sourceValue & ~bitMask ); // turn off the bit
}

function mouseDownHandler(e) {
    e.preventDefault();   // disable middle-click auto-scroll

    let canvas_rectangle = canvas.getBoundingClientRect();
    mouse_x = e.clientX - canvas_rectangle.left;
    mouse_y = e.clientY - canvas_rectangle.top;
    let x_world = draw2.convertPixelsToWorldSpaceUnitsX( mouse_x );
    let y_world = draw2.convertPixelsToWorldSpaceUnitsY( mouse_y );

    let mw_buttonThatChanged;

    switch ( e.button ) {
    case MEB_BUTTON_LEFT:
        global_buttonAndKeyState |= MW_BUTTON_LEFT;
        mw_buttonThatChanged = MW_BUTTON_LEFT;
        break;
    case MEB_BUTTON_MIDDLE:
        global_buttonAndKeyState |= MW_BUTTON_MIDDLE;
        mw_buttonThatChanged = MW_BUTTON_MIDDLE;
        break;
    case MEB_BUTTON_RIGHT:
        global_buttonAndKeyState |= MW_BUTTON_RIGHT;
        mw_buttonThatChanged = MW_BUTTON_RIGHT;
        break;
    }
    global_buttonAndKeyState = setBit( global_buttonAndKeyState, MW_KEY_CONTROL, e.ctrlKey );
    global_buttonAndKeyState = setBit( global_buttonAndKeyState, MW_KEY_SHIFT, e.shiftKey );
    if ( verboseEvents ) console.log("buttonAndKeyState === "+global_buttonAndKeyState.toString(2));

    if ( currentDragMode === DRAG_MODE_NOT_DRAGGING ) {
        currentDragMode = DRAG_MODE_DRAGGING_NOTHING;
        if ( e.button === MEB_BUTTON_RIGHT ) {
            if ( e.shiftKey ) {
                currentDragMode = DRAG_MODE_TRANSLATE;
            }
            else if ( e.ctrlKey ) {
                currentDragMode = DRAG_MODE_ZOOM;
            }
        }
        else if ( e.button === MEB_BUTTON_LEFT || e.button === MEB_BUTTON_MIDDLE ) {
            infoAboutObjectBeingDragged.source = null;
            infoAboutObjectBeingDragged.obj = null;
            let returnValue = null;
            if ( widgetUnderMouse!==null ) {
                currentDragMode = DRAG_MODE_MANAGED_BY_WIDGET;
                returnValue = widgetUnderMouse.widget_mousePress( mouse_x, mouse_y, x_world, y_world, mw_buttonThatChanged, global_buttonAndKeyState );
                if ( returnValue.initiatesDragAndDrop ) {
                    infoAboutObjectBeingDragged.source = widgetUnderMouse;
                    infoAboutObjectBeingDragged.obj = returnValue.objectBeingDragged;
                    currentDragMode = DRAG_MODE_DRAG_AND_DROP;
                }
                if ( returnValue.redraw ) draw();
            }
        }
    }
}
function mouseUpHandler(e) {
    let canvas_rectangle = canvas.getBoundingClientRect();
    mouse_x = e.clientX - canvas_rectangle.left;
    mouse_y = e.clientY - canvas_rectangle.top;
    let x_world = draw2.convertPixelsToWorldSpaceUnitsX( mouse_x );
    let y_world = draw2.convertPixelsToWorldSpaceUnitsY( mouse_y );

    let mw_buttonThatChanged;

    switch ( e.button ) {
    case MEB_BUTTON_LEFT:
        global_buttonAndKeyState &= ~MW_BUTTON_LEFT;
        mw_buttonThatChanged = MW_BUTTON_LEFT;
        break;
    case MEB_BUTTON_MIDDLE:
        global_buttonAndKeyState &= ~MW_BUTTON_MIDDLE;
        mw_buttonThatChanged = MW_BUTTON_MIDDLE;
        break;
    case MEB_BUTTON_RIGHT:
        global_buttonAndKeyState &= ~MW_BUTTON_RIGHT;
        mw_buttonThatChanged = MW_BUTTON_RIGHT;
        break;
    }
    global_buttonAndKeyState = setBit( global_buttonAndKeyState, MW_KEY_CONTROL, e.ctrlKey );
    global_buttonAndKeyState = setBit( global_buttonAndKeyState, MW_KEY_SHIFT, e.shiftKey );
    if ( verboseEvents ) console.log("buttonAndKeyState === "+global_buttonAndKeyState.toString(2));

    let areAnyButtonsDown = (global_buttonAndKeyState & (MW_BUTTON_LEFT | MW_BUTTON_MIDDLE | MW_BUTTON_RIGHT)) !== 0;

    if ( ! areAnyButtonsDown ) {
        if ( currentDragMode === DRAG_MODE_TRANSLATE ) {
        }
        else if ( currentDragMode === DRAG_MODE_ZOOM ) {
        }
        else if ( currentDragMode === DRAG_MODE_MANAGED_BY_WIDGET ) {
            // We want the button up event to be sent to the widget that the drag started on,
            // even if the cursor is no longer over that widget.
            if ( widgetUnderMouse !== null ) {
                let returnValue = widgetUnderMouse.widget_mouseRelease(
                    mouse_x, mouse_y, x_world, y_world,
                    mw_buttonThatChanged,
                    global_buttonAndKeyState,
                    false,
                    null
                );
                currentDragMode = DRAG_MODE_NOT_DRAGGING;
                if ( returnValue.redraw ) draw();
            }
        }
        else if ( currentDragMode === DRAG_MODE_DRAG_AND_DROP ) {
            let returnValue = null;
            let dragAndDropSource = infoAboutObjectBeingDragged.source;
            let dragAndDropDestination = widgetUnderMouse;
            if ( widgetUnderMouse !== null ) {
                returnValue = widgetUnderMouse.widget_mouseRelease(
                    mouse_x, mouse_y, x_world, y_world,
                    mw_buttonThatChanged,
                    global_buttonAndKeyState,
                    true,
                    infoAboutObjectBeingDragged.source!==null ? infoAboutObjectBeingDragged : null
                );
            }
            if ( dragAndDropSource!==null && dragAndDropSource===dragAndDropDestination ) {
                dragAndDropSource.widget_cleanUpAfterDragAndDrop(true,true);
            }
            else {
                if ( dragAndDropSource!==null ) {
                    dragAndDropSource.widget_cleanUpAfterDragAndDrop(true,false);
                }
                if ( dragAndDropDestination!==null ) {
                    dragAndDropDestination.widget_cleanUpAfterDragAndDrop(false,true);
                }
            }
            infoAboutObjectBeingDragged.source = null;
            infoAboutObjectBeingDragged.obj = null;
            currentDragMode = DRAG_MODE_NOT_DRAGGING;
            if ( returnValue!==null && returnValue.redraw ) {
                draw();
            }
        }
        currentDragMode = DRAG_MODE_NOT_DRAGGING;
    }
}
function mouseHoverAndDragHandler(e) {
    let previous_mouse_x = mouse_x;
    let previous_mouse_y = mouse_y;
    let canvas_rectangle = canvas.getBoundingClientRect();
    mouse_x = e.clientX - canvas_rectangle.left;
    mouse_y = e.clientY - canvas_rectangle.top;
    let x_world = draw2.convertPixelsToWorldSpaceUnitsX( mouse_x );
    let y_world = draw2.convertPixelsToWorldSpaceUnitsY( mouse_y );
    mouse_x_world = x_world;
    mouse_y_world = y_world;

    let delta_x = mouse_x - previous_mouse_x;
    let delta_y = mouse_y - previous_mouse_y;

    global_buttonAndKeyState = setBit( global_buttonAndKeyState, MW_KEY_CONTROL, e.ctrlKey );
    global_buttonAndKeyState = setBit( global_buttonAndKeyState, MW_KEY_SHIFT, e.shiftKey );
    if ( verboseEvents ) console.log("buttonAndKeyState === "+global_buttonAndKeyState.toString(2));

    if ( currentDragMode === DRAG_MODE_TRANSLATE ) {
        draw2.translate( delta_x, delta_y );
    }
    else if ( currentDragMode === DRAG_MODE_ZOOM ) {
        const zoomFactorPerPixelDragged = 1.005;
        draw2.zoomIn( zoomFactorPerPixelDragged ** delta_x );
    }
    else if ( currentDragMode === DRAG_MODE_MANAGED_BY_WIDGET ) {
        if ( verboseEvents ) console.log("framework drag managed by widget");
        // We want the drag event to be sent to the widget that the drag started on,
        // even if the cursor is no longer over that widget.
        // Hence, we don't generate any leave events.
        // But we do need to be ready to transition to drag-and-drop mode,
        // since some widgets only decide if a drag-and-drop starts after the first drag event.
        if ( widgetUnderMouse !== null ) {
            let returnValue = widgetUnderMouse.widget_mouseDrag(
                mouse_x, mouse_y, x_world, y_world,
                global_buttonAndKeyState,
                false,
                null
            );
            if ( returnValue.initiatesDragAndDrop ) {
                if ( verboseEvents ) console.log("framework drag: dnd initiated");
                infoAboutObjectBeingDragged.source = widgetUnderMouse;
                infoAboutObjectBeingDragged.obj = returnValue.objectBeingDragged;
                currentDragMode = DRAG_MODE_DRAG_AND_DROP;
            }
        }
    }
    else if (
        currentDragMode === DRAG_MODE_NOT_DRAGGING            // hover
        || currentDragMode === DRAG_MODE_DRAG_AND_DROP
    ) {
        if ( verboseEvents && currentDragMode === DRAG_MODE_DRAG_AND_DROP) console.log("framework drag dnd");
        let newObjectUnderMouse = null;
        if ( toolbar.isUnder( mouse_x, mouse_y, x_world, y_world ) )
            newObjectUnderMouse = toolbar;
        else if ( circuitViewer.isUnder( mouse_x, mouse_y, x_world, y_world ) )
            newObjectUnderMouse = circuitViewer;
        if ( floatingCheckbox1.isUnder( mouse_x, mouse_y, x_world, y_world ) )
            newObjectUnderMouse = floatingCheckbox1;
        else if ( floatingCheckbox2.isUnder( mouse_x, mouse_y, x_world, y_world ) )
            newObjectUnderMouse = floatingCheckbox2;
        else if ( floatingCheckbox3.isUnder( mouse_x, mouse_y, x_world, y_world ) )
            newObjectUnderMouse = floatingCheckbox3;
        else if ( floatingCheckbox4.isUnder( mouse_x, mouse_y, x_world, y_world ) )
            newObjectUnderMouse = floatingCheckbox4;
        if ( newObjectUnderMouse !== widgetUnderMouse ) {
            if ( widgetUnderMouse !== null ) {
                // generate leave event
                if ( currentDragMode === DRAG_MODE_NOT_DRAGGING )
                    widgetUnderMouse.widget_mouseHoverLeave();
                else
                    widgetUnderMouse.widget_mouseDragLeave(); // only invoked during drag-and-drop
            }
            widgetUnderMouse = newObjectUnderMouse;
        }
        let returnValue;
        if ( widgetUnderMouse !== null ) {
            if ( currentDragMode === DRAG_MODE_NOT_DRAGGING ) { // hover
                returnValue = widgetUnderMouse.widget_mouseHover( mouse_x, mouse_y, x_world, y_world );
            }
            else if ( currentDragMode === DRAG_MODE_DRAG_AND_DROP ) {
                returnValue = widgetUnderMouse.widget_mouseDrag(
                    mouse_x, mouse_y, x_world, y_world,
                    global_buttonAndKeyState,
                    true,
                    infoAboutObjectBeingDragged.source!==null ? infoAboutObjectBeingDragged : null
                );
            }
        }
    }
    draw();
}

function keyDownHandler(e) {
    const ArrowUp = 38;
    const ArrowDown = 40;
    const ArrowLeft = 37;
    const ArrowRight = 39;

    if ( verboseEvents ) console.log("keyCode: " + e.keyCode + ", " + (e.ctrlKey ? "Ctrl ":"") + (e.shiftKey ? "Shift ":"") );
    if (e.key === 'Delete') {
        if ( verboseEvents ) console.log("delete key was pressed");
        deleteCircuitPart( circuitViewer.selected_circuitPart_wire, circuitViewer.selected_circuitPart_stage );
    }
    else if ( e.keyCode === ArrowUp || e.keyCode === ArrowDown || e.keyCode === ArrowLeft || e.keyCode === ArrowRight ) {
        if ( circuitViewer.selected_circuitPart_isAnythingSelected ) {
            let circuitPart = circuitViewer.circuit.getCellContents( circuitViewer.selected_circuitPart_wire, circuitViewer.selected_circuitPart_stage );
            if ( circuitPart.isParametric() ) {
                if ( circuitViewer.selected_circuitPart_parameter >= 0 ) {
                    if ( e.keyCode === ArrowUp ) {
                        circuitViewer.selected_circuitPart_parameter = ( circuitViewer.selected_circuitPart_parameter - 1 + circuitPart.getNumParameters() ) % circuitPart.getNumParameters();
                    }
                    else if ( e.keyCode === ArrowDown ) {
                        circuitViewer.selected_circuitPart_parameter = ( circuitViewer.selected_circuitPart_parameter + 1 ) % circuitPart.getNumParameters();
                    }
                    else if ( e.keyCode === ArrowLeft || e.keyCode === ArrowRight ) {
                        if ( e.ctrlKey || e.shiftKey ) {
                            let paramInfo = circuitPart.getParamInfo( circuitViewer.selected_circuitPart_parameter );
                            let newParamValue = circuitPart.paramValues[ circuitViewer.selected_circuitPart_parameter ];
                            if ( e.shiftKey /* we are snapping */ ) {
                                let newParamValue2 = Math.round( newParamValue / paramInfo.snapIncrement ) * paramInfo.snapIncrement;
                                if ( newParamValue2 === newParamValue )
                                    newParamValue2 += ( e.keyCode === ArrowRight ? 1 : -1 )*paramInfo.snapIncrement;
                                newParamValue = newParamValue2;
                            }
                            else {
                                newParamValue += ( e.keyCode === ArrowRight ? 1 : -1 )*paramInfo.dragIncrement;
                            }
                            if ( newParamValue < paramInfo.minValue )
                                newParamValue = paramInfo.minValue;
                            else if ( newParamValue > paramInfo.maxValue )
                                newParamValue = paramInfo.maxValue;
                            circuitPart.paramValues[ circuitViewer.selected_circuitPart_parameter ] = newParamValue;
                            circuitViewer.circuit.stateVectorsAndStatsAreDirty = true;
                            circuitViewer.updateURLIfNecessary( false );
                        }
                    }
                }
                else {
                    circuitViewer.selected_circuitPart_parameter = 0;
                }
            }

        }
    }
    draw();
}


function updateSizeOfCanvas() {
    // const myCanvas = document.getElementById("myCanvas");
    // canvas.width = window.innerWidth - 40;
    canvas.width = document.documentElement.clientWidth - 20; // avoids including width of vertical scrollbar
    draw2.resize(canvas.width,canvas.height);
    draw2.setFontHeight( FONT_HEIGHT ); // after resizing the canvas, its context is reset, so we must redo this
    frameCircuit();
}

function respondToResize() {
    updateSizeOfCanvas();
    draw();
}

function initializeStuffInTheDOM() {
    initializeDisplayOptionWidgets();

    canvas.addEventListener('mousedown',mouseDownHandler);
    canvas.addEventListener('mouseup',mouseUpHandler);
    canvas.addEventListener('mousemove',mouseHoverAndDragHandler);
    canvas.oncontextmenu = function(e) { e.preventDefault(); return false; }; // disable the right-click menu
    canvas.addEventListener('auxclick', function(e) { e.preventDefault(); return false; }); // don't know if this is necessary
    document.onkeydown = keyDownHandler;

    document.getElementById('copyQASMButton').addEventListener('click', () => {
      let text = document.getElementById('qasmText').textContent;
      navigator.clipboard.writeText(text);
    });

    updateSizeOfCanvas();
    if ( areAllImagesLoaded )
        draw();
}

window.addEventListener('load', initializeStuffInTheDOM ); // do this on a load event so the widgets have a chance to get created first
window.addEventListener('resize', respondToResize);
if ( verboseEvents ) console.log("We are rerunning!"); // TODO_loading

function allImagesLoadedCallback() {
    areAllImagesLoaded = true;
    draw();
}

</script>
</body>
</html>


