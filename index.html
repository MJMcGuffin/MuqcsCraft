
<html>

<head>
<title>MuqcsCraft</title>
<meta charset="utf-8"/>
<style type="text/css">
   label:hover, button:hover, a:link:hover, a:visited:hover { background-color: #bbeeff; }
   blockquote { margin-bottom: 0; margin-top: 0; }
</style>


<script language="JavaScript">
   function toggleDisplay(stuffToToggle,elementThatExpandsStuff,elementThatCollapsesStuff) {
      if ( stuffToToggle.style.display == 'none' ) {
         stuffToToggle.style.display = '';
         elementThatExpandsStuff.style.display = 'none';
         elementThatCollapsesStuff.style.display = '';
      }
      else {
         stuffToToggle.style.display = 'none';
         elementThatExpandsStuff.style.display = '';
         elementThatCollapsesStuff.style.display = 'none';
      }
   }
</script>



</head>

<body>

<table>
  <tr>
    <td>
        <label><input id="displayOptionsOverlayCheckbox" type='checkbox' onclick='let div = document.getElementById("displayOptions"); if (this.checked) { let canvas_rect = document.getElementById("myCanvas").getBoundingClientRect(); div.style.backgroundColor = "rgba(192,224,255,0.75)"; div.style.position = "fixed"; div.style.top = canvas_rect.top; div.style.left = canvas_rect.left; } else { div.style.backgroundColor = div.style.position = div.style.top = div.style.left = ""; }'>Overlay<br/>Display Options</label>
    <td>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
    <td>
        Welcome to <b>MuqcsCraft</b>, an <a href="https://github.com/MJMcGuffin/MuqcsCraft">open-source</a> graphical simulator and visualizer for quantum circuits,
        <br/>built on top of the <a href="https://github.com/MJMcGuffin/muqcs.js">Muqcs (McGuffin's Useless Quantum Circuit Simulator)</a> library.
</table>






<!-- canvas id="myCanvas" width="900" height="750" style="border:2px solid #000000;" -->
<canvas id="myCanvas" width="1200" height="800" style="border:2px solid #000000;">
</canvas>

<p>
Use <b>Left mouse button</b> to drag-and-drop a gate.
<br/>
Some gates have parameters. To change a parameter, use Ctrl+left mouse button and drag left-right,
or use Shift+left mouse button and drag left-right to snap the parameter to nice values.
You can also click on a parameter to select it, and then use
Ctrl+left arrow, Ctrl+right arrow keys to adjust,
Shift+left arrow, Shift+right arrow keys to snap.

<p>
To <b>delete a gate</b>, you can
(1) left-click on the gate to select it, and then hit the Delete key;
or (2) drag the gate off the circuit and drop it outside;
or (3) press+release over the gate with the <b>Middle mouse button</b>  (like in <a href="https://algassert.com/quirk">Quirk</a>).

<p>
To <b>UNDO</b>, hit the Back button in your web browser.
The state of the circuit is encoded in the query string of the browser's URL (like in Quirk),
hence circuits can be bookmarked and shared as hyperlinks in plain text.

<p>
Additional options:
<span id='g1e'>[<a href="javascript:toggleDisplay(g1,g1e,g1c)">Show...</a>]</span>
<span id='g1c' style="display:none">[<a href="javascript:toggleDisplay(g1,g1e,g1c)">Hide</a>]</span>

<blockquote>
    <span id='g1' style="display:none">
    <p>
    Camera controls: <b>Shift+Right mouse button</b> drag to translate; <b>Ctrl+Right mouse button</b> drag left-right to zoom.
    <br/>
    <button onclick="frameButtonHandler()">Frame</button>
    <button onclick="animatedFrameButtonHandler()">Animated Frame</button>

    <p>
    <button onclick="clearCircuitButtonHandler()">Clear Circuit</button>
    Hit the Back button in your browser to Undo.

    <p>
    <button onclick="expandCircuitButtonHandler()">Expand Circuit</button>
    Replaces certain gates with equivalent sequences of other gates so that their effects can be visualized on the state vector more easily, at the cost of making the circuit deeper.
    If generalized gates are used, then fewer layers need to be added in the expansion.
    See our paper for details.
    Hit the Back button in your browser to Undo.
    <br>
    <label><input type='checkbox' id='useGeneralizedGatesCheckbox'>Use generalized gates in the expansion</label> to produce a shorter expansion.

    <p>
    <button onclick="printMagicButtonHandler()">Print Magic</button> Prints <a href="https://scholar.google.com/scholar?q=leone+Stabilizer+Renyi+Entropy">Second Stabilizer Rényi Entropy</a> of the output state to the console.

    </span>
</blockquote>

<div id="displayOptions">
<p>
Display options:

<blockquote>

Local State
<blockquote>
   <!--
   <label><input type='checkbox' datavar="showFinalLocalState">▶Show final local state</label> <br/>
   <label><input type='checkbox' datavar="showLocalStatePerLayer">▶Show local state per layer</label>
   <br/>
   -->
   For each local state... <br/>
   <label><input type='checkbox' datavar="LS_showPurity">Show Purity</label>
   <label><input type='checkbox' datavar="LS_showLinearEntropy">Show Linear Entropy (= 1-Purity)</label>
   <label><input type='checkbox' datavar="LS_showVonNeumannEntropy">Show Von Neumann Entropy</label>
   <label><input type='checkbox' datavar="LS_showProbability">Show Probability</label>
   <label><input type='checkbox' datavar="LS_showPhase">Show Phase</label>
</blockquote>

Half Matrix
<blockquote>
   <!-- <label><input type='checkbox' datavar="showFinalHalfMatrix">▶Show Final Half Matrix</label> <br/> -->
   In each cell of the Half Matrix, show... <br/>
   <blockquote>
       <label><input type='radio' name="radioGroup4" datavar="HM_cellContents" datavarvalue="HM_BARCHART">barchart</label><br/>
       <blockquote>
           For each pair of qubits... <br/>
           <label><input type='checkbox' datavar="HM_showPurity">Show Purity</label>
           <label><input type='checkbox' datavar="HM_showLinearEntropy">Show Linear Entropy (= 1-Purity)</label>
           <label><input type='checkbox' datavar="HM_showVonNeumannEntropy">Show von Neumann Entropy</label>
           <label><input type='checkbox' datavar="HM_showConcurrence">Show Concurrence</label>
           <label><input type='checkbox' datavar="HM_showCorrelation">Show Correlation</label>
       </blockquote>
       <label><input type='radio' name="radioGroup4" datavar="HM_cellContents" datavarvalue="HM_RECT_GLYPHS">rectangle glyphs</label>
   </blockquote>
</blockquote>

State Vectors
<blockquote>
   <!-- <label><input type='checkbox' datavar="showStateVectorsPerLayer">▶Show state vectors per layer</label> <br/> -->
   <label><input type='checkbox' datavar="allowMultipleColumns">Enable wrapping (multiple columns) within each state vector</label>
   <label><input type='checkbox' datavar="displayOutsideBitstring">Show bitstrings outside cells</label>
   <br/>
   Show cells as ...
   <blockquote>
       <label><input type='radio' name="radioGroup2" datavar="cell_aspectRatio" datavarvalue="CELL_ASPECTRATIO_SQUARE">squares</label><br/>
       <label><input type='radio' name="radioGroup2" datavar="cell_aspectRatio" datavarvalue="CELL_ASPECTRATIO_RECTANGULAR">rectangles</label>
       <blockquote>
           <label><input type='checkbox' datavar="displayInsideBitstring">Show bitstrings inside cells</label>
           <label><input type='checkbox' datavar="displayInsideProbability">Show probabilities inside cells</label>
       </blockquote>
   </blockquote>
   The length of the bar in each cell is<br/>
   <blockquote>
       <label><input type='radio' name="radioGroup3" datavar="barFunction" datavarvalue="BARFUNCTION_PROBABILITY">proportional to probability</label><br/>
       <label><input type='radio' name="radioGroup3" datavar="barFunction" datavarvalue="BARFUNCTION_MAGNITUDE">proportional to magnitude of amplitude</label><br/>
       <label><input type='radio' name="radioGroup3" datavar="barFunction" datavarvalue="BARFUNCTION_LOG_PROBABILITY">linear function of log<sub>2</sub> of probability</label><br/>
   </blockquote>
</blockquote>

Visualizations Per Layer
<span id='g2e'>[<a href="javascript:toggleDisplay(g2,g2e,g2c)">Show...</a>]</span>
<span id='g2c' style="display:none">[<a href="javascript:toggleDisplay(g2,g2e,g2c)">Hide</a>]</span>
<blockquote>
   <span id='g2' style="display:none">
   <label><input type='checkbox' datavar="showVisOfAllLayers">Show all layers</label> <br/>
   <label><input type='checkbox' datavar="scrollPerLayerVisHorizontally">Scroll horizontally when mouse hovers over circuit</label> <br/>
   Show difference visualization on<br/>
   <blockquote>
       <label><input type='radio' name="radioGroup1" datavar="show_diffvis" datavarvalue="DIFFVIS_NONE">no layers</label><br/>
       <label><input type='radio' name="radioGroup1" datavar="show_diffvis" datavarvalue="DIFFVIS_ONE">one layer</label><br/>
       <label><input type='radio' name="radioGroup1" datavar="show_diffvis" datavarvalue="DIFFVIS_ALL">all layers</label><br/>
   </blockquote>
   </span>
</blockquote>

</blockquote>

<br/>

</div> <!-- displayOptions -->


Export options:
<span id='g3e'>[<a href="javascript:toggleDisplay(g3,g3e,g3c)">Show...</a>]</span>
<span id='g3c' style="display:none">[<a href="javascript:toggleDisplay(g3,g3e,g3c)">Hide</a>]</span>

<blockquote>
    <span id='g3' style="display:none">
    Export to Quirk:
    <blockquote>
    <a id="quirkLink" href="">View this circuit in Quirk</a>
    (some gates may be omitted or not work)
    </blockquote>

    Export to IBM:

    <blockquote>

    <a href="https://quantum.cloud.ibm.com/composer">Open IBM Quantum Composer</a> <!-- previously https://quantum.ibm.com/composer/ -->
    <br/>
    OpenQASM code that you can paste into IBM Quantum Composer to get the same circuit (note that not all gates are supported by IBM Quantum Composer):
    <br/>
    <pre id="qasmText"></pre>
    <button id="copyQASMButton">Copy OpenQASM code</button>
    (some gates may be omitted or not work)

    </blockquote>

    </span>
</blockquote>




<p>
Predefined circuits:
<span id='g4e'>[<a href="javascript:toggleDisplay(g4,g4e,g4c)">Show...</a>]</span>
<span id='g4c' style="display:none">[<a href="javascript:toggleDisplay(g4,g4e,g4c)">Hide</a>]</span>

<blockquote>
    <span id='g4' style="display:none">
    Bell states [<a href="https://en.wikipedia.org/wiki/Bell_state">reference</a>] <br/>
        <blockquote>
            There are four Bell states: Φ+, Φ-, Ψ+, Ψ-.
            The first three are called triplet states.
            Consider <a href='?circuit={"cols":[["H"],["•","X"]]}'>this circuit</a> that generates a Φ+ state
            whose qubits are maximally correlated.
            How does the correlation between the qubits change if we
            <a href='?circuit={"cols":[["H"],["•","X"],["X^¼","X^¼"]]}'>add X<sup>0.25</sup></a> gates at the end of both qubits?
            And what if we
            <a href='?circuit={"cols":[["H"],["•","X"],["X^¼","X^¼"],["X^¼","X^¼"]]}'>do that again</a>?
            <br/>
            Now try <a href='?circuit={"cols":[["H","X"],["•","X"],[1,"Z"]]}'>this circuit</a> that generates a Ψ- state, also called a singlet state.
            How does the correlation between the qubits change if we
            add X<sup>0.25</sup> gates at the end of both qubits?
        </blockquote>
    <a href='?circuit={"cols":[["H"],["•","X"],[1,"•","X"]]}'>GHZ state</a> [<a href="https://en.wikipedia.org/wiki/Greenberger%E2%80%93Horne%E2%80%93Zeilinger_state">reference</a>] <br/>
    <a href='?circuit={"cols":[["H"],["•","X"],[1,"•","X"],[1,1,"•","X"]]}'>GHZ-4 state</a> <br/>
    <a href='?circuit={"cols":[["H",1,"Y^¼","X"],["•","X"],[1,"•","X"],[1,1,"•","X"]]}'>Variant of GHZ-4</a> <br/>
    <a href='?circuit={%22cols%22:[[{%22id%22:%22Ryft%22,%22arg%22:%221.9106332362490184%22}],[%22%E2%80%A2%22,%22H%22],[1,%22%E2%80%A2%22,%22X%22],[%22%E2%80%A2%22,%22X%22],[%22X%22]]}'>W state</a> [<a href="https://en.wikipedia.org/wiki/W_state">reference</a>] <br/>
    <a href='?circuit={"cols":[["H",1,1,"H"],["•","X",1,"•"],["X",1,1,"X"],["•",1,"X","•"],["X",1,"•"],[1,1,"•","X"]]}'>W-4 state</a> adapted from <a href="https://quantumcomputing.stackexchange.com/questions/4350/general-construction-of-w-n-state">here</a>  <br/>
    <a href='?circuit={"cols":[["H","Y^¼"],["•","X"],["Y^¼"],["•","X"]]}'>partial entanglement followed by partial disentanglement (1)</a> <br/>
    <a href='?circuit={"cols":[["H",1,"Y^¼"],["•","X"],[1,"•","X"],[1,1,"•","X"],[1,"•","X"]]}'>partial entanglement followed by partial disentanglement (2)</a> <br/>
    <a href='?circuit={"cols":[["Y^¼"],["•",1,"X"],["H"],[1,"X","•"],[1,1,"X"],[1,"H","•"],[1,1,"X"],["•","X","•"],[1,1,"X"],["•",1,"•","X"],[1,"•","•",1,"X"]]}'>variant of Werner state</a> based on Figure A1 in <a href="https://scholar.google.com/scholar?q=Bell+Diagonal+and+Werner+State+Generation+Entanglement+Non-Locality+Steering+and+Discord+on+the+IBM+Quantum+Computer">Riedel Garding et al. 2021</a><br/>
    <a href='?circuit={"cols":[["Y^¼","Y^¼","Y^¼","Y^¼","Y^¼","Y^¼"]]}'>circuit generating |H>^(⊗6) magic state</a> with SSRE magic 2.490<br/>
    <a href='?circuit={%22cols%22:[[{%22id%22:%22Y^ft%22,%22arg%22:%220.3040867239846964%22},{%22id%22:%22Y^ft%22,%22arg%22:%220.3040867239846964%22},{%22id%22:%22Y^ft%22,%22arg%22:%220.3040867239846964%22},{%22id%22:%22Y^ft%22,%22arg%22:%220.3040867239846964%22},{%22id%22:%22Y^ft%22,%22arg%22:%220.3040867239846964%22},{%22id%22:%22Y^ft%22,%22arg%22:%220.3040867239846964%22}],[{%22id%22:%22Z^ft%22,%22arg%22:%220.25%22},{%22id%22:%22Z^ft%22,%22arg%22:%220.25%22},{%22id%22:%22Z^ft%22,%22arg%22:%220.25%22},{%22id%22:%22Z^ft%22,%22arg%22:%220.25%22},{%22id%22:%22Z^ft%22,%22arg%22:%220.25%22},{%22id%22:%22Z^ft%22,%22arg%22:%220.25%22}]]}'>circuit generating |T>^(⊗6) magic state</a> with SSRE 3.510<br/>
    <a href='?circuit={%22cols%22:[[{%22id%22:%22Ryft%22,%22arg%22:%220.9553166181245093%22},{%22id%22:%22Ryft%22,%22arg%22:%220.9553166181245093%22},{%22id%22:%22Ryft%22,%22arg%22:%220.9553166181245093%22},{%22id%22:%22Ryft%22,%22arg%22:%220.9553166181245093%22},{%22id%22:%22Ryft%22,%22arg%22:%220.9553166181245093%22},{%22id%22:%22Ryft%22,%22arg%22:%220.9553166181245093%22}],[{%22id%22:%22Rzft%22,%22arg%22:%220.7853981633974483%22},{%22id%22:%22Rzft%22,%22arg%22:%220.7853981633974483%22},{%22id%22:%22Rzft%22,%22arg%22:%220.7853981633974483%22},{%22id%22:%22Rzft%22,%22arg%22:%220.7853981633974483%22},{%22id%22:%22Rzft%22,%22arg%22:%220.7853981633974483%22},{%22id%22:%22Rzft%22,%22arg%22:%220.7853981633974483%22}]]}'>alternative circuit generating |T>^(⊗6) magic state</a> with SSRE 3.510<br/>

    <a href='?circuit={"cols":[["H","H","H","H","H","H"],["•","Z^¼"],[1,"•","Z^¼"],[1,1,"•","Z^¼"],[1,1,1,"•","Z^¼"],[1,1,1,1,"•","Z^¼"]]}'>circuit with cascading CT gates</a> with SSRE magic 2.848<br/>
    <a href='?circuit={"cols":[["H","H","H","H","H","H"],["•","•","Z"],[1,1,1,"•","•","Z"],[1,"•","•","Z"],["Z",1,1,1,"•","•"],[1,1,"•","•","Z"],["•","Z",1,1,1,"•"]]}'>circuit with cyclic CCZ gates</a> with SSRE magic 3.696<br/>
    <a href='?circuit={"cols":[["H","H","H","H","H","H"],["•","•","Z^¼"],[1,1,1,"•","•","Z^¼"],[1,"•","•","Z^¼"],["Z^¼",1,1,1,"•","•"],[1,1,"•","•","Z^¼"],["•","Z^¼",1,1,1,"•"],["•","•","Z^¼"],[1,1,1,"•","•","Z^¼"],[1,"•","•","Z^¼"],["Z^¼",1,1,1,"•","•"],[1,1,"•","•","Z^¼"],["•","Z^¼",1,1,1,"•"],["•","•","Z^¼"],[1,1,1,"•","•","Z^¼"],[1,"•","•","Z^¼"],["Z^¼",1,1,1,"•","•"],[1,1,"•","•","Z^¼"],["•","Z^¼",1,1,1,"•"]]}'>circuit with cyclic CCT gates</a> with SSRE magic 3.920<br/>

    Different ways to implement Grover's algorithm. Each one shows 1 or 2 layers that initialize, then the oracle, then the diffusion operator. Challenge: show that these are all equivalent.
        <blockquote>
        <a href='?circuit={"cols":[["H","H","H","H"],["•","◦","•","Z"],["H","H","H","H"],[1,1,1,"X"],["◦","◦","◦","Z"],[1,1,1,"X"],["H","H","H","H"]]}'>Grover example 1</a><br/>
        <a href='?circuit={"cols":[["H","H","H","H"],["•","◦","•","Z"],["H","H","H","H"],["X","X","X","X"],["•","•","•","Z"],["X","X","X","X"],["H","H","H","H"]]}'>Grover example 2</a><br/>
        <a href='?circuit={"cols":[["H","H","H","H"],["•","◦","•","Z"],["H","H","H","H"],["X","X","X","X"],[1,1,1,"H"],["•","•","•","X"],[1,1,1,"H"],["X","X","X","X"],["H","H","H","H"]]}'>Grover example 3</a><br/>
        <a href='?circuit={"cols":[["X","X","X","X"],["H"],[1,"H"],[1,1,"H"],[1,1,1,"H"],["•","◦","•","Z"],["H"],[1,"H"],[1,1,"H"],["•","•","•","X"],[1,1,"H"],[1,"H"],["H"]]}'>Grover example 4</a><br/>
        </blockquote>

    Puzzles:
        <blockquote>
        Design a circuit that entangles, and then disentangles, two qubits.
            <blockquote>
            <a href='?circuit={"cols":[["H"],["•","X"],["•","X"]]}'>example 1</a> <br/>
            <a href='?circuit={"cols":[["H"],["•","X"],["X","•"]]}'>example 2</a> <br/>
            </blockquote>
        Design a circuit that only <em>partially</em> entangles two qubits.
            <blockquote>
            <a href='?circuit={"cols":[["H","Y^¼"],["•","X"]]}'>example 1</a> <br/>
            <a href='?circuit={"cols":[["H"],["•","Y^¼"]]}'>example 2</a> <br/>
            <a href='?circuit={"cols":[["X^½","X^½"],["•","Z^½"]]}'>example 3</a> <br/>
            </blockquote>
        Design a circuit on 2 qubits, using as few gates as possible, that results in the 4 base states (00, 01, 10, 11) having 4 distinct probabilities. <br/>
            <blockquote>
            <a href='?circuit={"cols":[["X^¼","X^¼"],["Y^¼"]]}'>candidate solution 1</a> <br/>
            <a href='?circuit={"cols":[["H"],["•","Y^¼"]]}'>candidate solution 2</a> <br/>
            </blockquote>
        Design a circuit that results in some of the base states having probabilities that follow a geometric sequence, for example,
            a base state with probability 50%, another with a probability of 25%, another with 12.5%, etc.
            <blockquote>
            <a href='?circuit={"cols":[["H"],["•","H"],[1,"•","H"],[1,1,"•","H"]]}'>candidate solution</a><br/>
            </blockquote>
        Design a circuit on 4 qubits that results in the same amplitude on all 16 base states,
        except for one base state whose phase is opposite to the others.
        This opposing phase, in effect, "tags" the base state as different from the others, and can simulate an oracle in Grover's algorithm.
            <blockquote>
            First, do this for the state 1111, so its phase is opposite all the others,
            but all amplitudes have the same magnitude.
                <a href='?circuit={"cols":[["H","H","H","H"],["•","•","•","Z"]]}'>candidate solution 1</a>,
                <a href='?circuit={"cols":[["H","H","H","H"],["•","Z","•","•"]]}'>candidate solution 2</a>,
                <a href='?circuit={"cols":[["H","H","H","H"],[1,1,1,"H"],["•","•","•","X"],[1,1,1,"H"]]}'>candidate solution 3</a>
                <br/>
            Then modify the circuit so that state 1011 has its phase opposite all the others.
                <a href='?circuit={"cols":[["H","H","H","H"],["•","•","◦","Z"]]}'>candidate solution 1</a>,
                <a href='?circuit={"cols":[["H","H","H","H"],["•","Z","◦","•"]]}'>candidate solution 2</a>,
                <a href='?circuit={"cols":[["H","H","H","H"],[1,1,"X"],["•","•","•","Z"],[1,1,"X"]]}'>candidate solution 3</a>
                <br/>
            Then try to do it for 0100.
                <a href='?circuit={"cols":[["H","H","H","H"],["◦","◦","Z","◦"]]}'>candidate solution 1</a>
                <br/>
            Then try for 0000.
                <a href='?circuit={"cols":[["H","H","H","H"],["Z","◦","◦","◦"],["X"]]}'>candidate solution 1</a>
                <br/>
            </blockquote>
        Design circuits to produce examples of each of the states in the set {pure, partially mixed, maximally mixed}×{product state, separable, partially entangled, maximally entangled}<br/>
        </blockquote>
    </span>
</blockquote>

<p>
<a href="https://github.com/MJMcGuffin/muqcs.js?tab=readme-ov-file#matrix-definitions">List of definitions of matrices</a> for quantum gates








<br/>

<br/>




<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/13.0.2/math.js"></script>

<script>

// CONVENTIONs
//
// Assume that, in a quantum circuit with n qubits, the qubits are numbered
// from top to bottom as 0 to (n-1), respectively, and furthermore that the
// top qubit is the least significant bit (LSB), and the bottom is the most
// significant bit (MSB).  For example, if there are 3 qubits labeled q0, q1, q2,
// from top to bottom, these might store (q2,q1,q0) = (0,1,1) to encode 3
// or (q2,q1,q0) = (1,0,0) to encode 4.  Given these assumptions, there are
// two ways to simulate the circuit, described below, that correspond to
// different matrices and different orderings for tensor products.
// Sometimes the terms "big-endian" or "little-endian" are used to refer
// to choices related to this, but I haven't found clear definitions
// or consistent usage of these terms.
//
// Common software convention:
// - Tensor products are done in order of decreasing bit significance.
//   https://quantumcomputing.stackexchange.com/questions/8244/big-endian-vs-little-endian-in-qiskit
//   seems to confirm that Qiskit works this way.
// - In a 2-qubit circuit, if we have a 2-qubit gate where q0 is a control
//   bit and q1 has a conditionally applied operation with 2x2 matrix [a b; c d],
//   the 4x4 matrix for the gate would be [1 0 0 0; 0 a 0 b; 0 0 1 0; 0 c 0 d],
//   which is endian-reversed with how 4x4 matrices are usually presented in
//   textbooks on quantum computing.
//   See https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations.html#Basis-vector-ordering-in-Qiskit
// - In a 3-qubit circuit, the state vector would contain 8 elements,
//   and the 2nd of these would correspond to (q2,q1,q0) = (0,0,1),
//   which is more natural for reading.  This appears to match the
//   presentation of output from Quirk and IBM Quantum Composer.
//   Quirk's doc/README.md file ( https://github.com/Strilanc/Quirk/blob/master/doc/README.md )
//   states "Kets are big-endian. |00101> is 5, not 20",
//   and https://algassert.com/post/1707 further discusses this.
//
// Textbook convention:
// - Tensor products are done in order of increasing bit significance.
//   This seems to match when
//   https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations.html#Basis-vector-ordering-in-Qiskit
//   states "Within the physics community, the qubits of a multi-qubit systems
//   are typically ordered with the first qubit on the left-most side of the
//   tensor product and the last qubit on the right-most side."
// - The same 4x4 matrix mentioned earlier, with q0 acting as a control bit,
//   would now be [1 0 0 0; 0 1 0 0; 0 0 a b; 0 0 c d] which is how they
//   are usually presented in textbooks on quantum computing.
// - In a 3-qubit circuit, the state vector would contain 8 elements, and
//   the 2nd of these would correspond to (q0,q1,q2) = (0,0,1).
//   Such a vector would have to be endian-reversed for more natural reading.
//
// We could just implement one of the above conventions in the code,
// but I found it instructive to try to implement both and have a global flag
// to switch between the two.
//
let usingTextbookConvention = false; // note that the code has not been fully tested with usingTextbookConvention = true


let defaultDecimalPrecision = 3;
let precisionForApproximateComparison = 0.01;


class Util {
    static assert( condition, message ) {
        if ( ! condition ) {
            console.log( "ASSERTION ERROR: " + message );
            console.trace(); // causes line numbers to be printed
        }
    }
    // Let n be a power of 2. This returns the reverse of i in binary, with respect to n.
    // For example, if n===16, the reverse of 1 is 8, the reverse of 2 is 4, the reverse of 3 is 12,
    // and the reverse of 0, 6, 9, and 15 leaves each of those numbers unchanged.
    static reverseEndianness(i,n) {
        Util.assert( 0<=i && i<n && 1<=n, `Util.reverseEndianness(): unexpected condition, i===${i}, n===${n}`);
        let result = 0;
        let bit = 1;
        let reversed_bit = n >> 1;
        while ( bit < n ) {
            if ( i & bit )
                result |= reversed_bit;
            bit <<= 1;
            reversed_bit >>= 1;
        }
        Util.assert( bit === n/*this should happen because n should be a power of 2*/, `Util.reverseEndianness(): unexpected condition, n===${n}`);
        return result;
    }
    // Returns angle in [0,2 pi] of the given point in the cartesian plane measured counterclockwise+ with respect to x+
    static angleIn2D(x,y) {
        let hypotenuse = Math.sqrt(x*x+y*y);
        let angle = 0;
        if ( hypotenuse > 0 ) {
            let sine = y / hypotenuse;
            if ( sine>= 1 ) angle = Math.PI/2;
            else if ( sine<=-1) angle = -Math.PI/2;
            else angle = Math.asin(sine);

            if ( x < 0 ) angle = Math.PI - angle;
            if ( angle < 0 ) angle += 2*Math.PI; // ensures angle is in [0,2*M_PI]
        }
        return angle;
    }
    // returns true if the given numbers are approximately equal, within the given tolerance
    static approximatelyEqual(a,b,tolerance=precisionForApproximateComparison,printMessage=true) {
        Util.assert(typeof(a)==="number" && typeof(b)==="number", "Util.approximatelyEqual(): unknown type");
        let delta = Math.abs( a - b );
        if ( delta > tolerance ) {
            if ( printMessage ) {
                console.log(`Util.approximatelyEqual(): difference of ${delta} found`);
            }
            return false;
        }
        return true;
    }
}

class StringUtil {
    static numToString( x, decimalPrecision = defaultDecimalPrecision ) {
        let s1 = x.toString();
        let s2 = x.toFixed(decimalPrecision);
        if ( s1.length < s2.length ) return s1;
        else return s2;
    }
    // returns the given string, reversed
    static reverseString(s) {
        let r = "";
        for ( let j = s.length-1; j >= 0; j-- )
            r += s[j];
        return r;
    }
    // returns s repeated n times
    static repeatString(s,n) {
        let r = "";
        for ( let j = 0; j < n; j++ )
            r += s;
        return r;
    }
    // converts an integer to a binary string, padding with zeros at the front
    static intToBinaryString( i, desiredWidth ) {
        let binaryString = i.toString(2/*base 2 for binary*/);
        return StringUtil.repeatString('0',desiredWidth-binaryString.length) + binaryString; // pad with '0's
    }
    // returns number of times the character c occurs in string s
    static countInString(s,c) {
        let r = 0;
        for ( let j = s.length-1; j >= 0; j-- )
            if ( s[j]===c )
                r ++;
        return r;
    }
    // Returns a single multiline string containing the given strings
    // concatenated horizontally and centered vertically.
    // Assumes that none of the given strings are jagged,
    // i.e., assumes that for each given string, all its lines are the same length.
    //
    // For example, calling with arguments ("x = ", "[0,0,1,1]", " * ", "[0]\n[1]\n[0]\n[1]")
    // causes a return of the string
    //    "                [0]\n"
    //   +"x = [0,0,1,1] * [1]\n"
    //   +"                [0]\n"
    //   +"                [1]"
    //
    static concatMultiline(...args) {
        let w = []; // widths of given strings
        let h = []; // heights of given strings
        let max_height = 0;
        for (let s of args) {
            let s2 = s.split('\n');
            h.push( s2.length );
            if ( s2.length > max_height ) max_height = s2.length;
            w.push( s2[0].length );
        }
        let returnValue = "";
        for ( let row = 0; row < max_height; ++row ) {
            for (let stringIndex = 0; stringIndex < args.length; stringIndex ++ ) {
                let s = args[ stringIndex ];
                let rowWithinString = Math.round( row - max_height/2 + h[ stringIndex ]/2 );
                if ( rowWithinString < 0 || rowWithinString >= h[ stringIndex ] ) {
                    // use spaces
                    returnValue += StringUtil.repeatString(' ', w[ stringIndex ] );
                }
                else {
                    //console.log("rowWithinString = " + rowWithinString + ", s =" + s + "END" );
                    returnValue += s.split('\n')[rowWithinString];
                }
            }
            if ( row < max_height-1 )
                returnValue += '\n';
        }
        return returnValue;
    }
}

// Stores a complex number, with real and imaginary components.
class Complex {
    constructor( re = 0, im = 0 ) {
        this._r = re;
        this._i = im;
    }
    toString( decimalPrecision = defaultDecimalPrecision ) {
        if ( this._r === 0 ) {
            if ( this._i === 0 ) {
               return "0";
            }
            else {
               return StringUtil.numToString(this._i,decimalPrecision) + "i";
            }
        }
        else {
            if ( this._i === 0 ) {
               return StringUtil.numToString(this._r,decimalPrecision);
            }
            else {
               let rs = StringUtil.numToString(this._r,decimalPrecision);
               let is = StringUtil.numToString(this._i,decimalPrecision) + "i";
               return is[0]==='-' ? ( rs+is ) : ( rs + "+" + is );
            }
        }
    }
    // returns a deep copy of the complex number
    copy() {
        return new Complex( this._r, this._i );
    }
    negate() {
        return new Complex( - this._r, - this._i );
    }
    conjugate() {
        return new Complex( this._r, - this._i );
    }
    mag() { // magnitude, also known as absolute value or modulus
        return Math.sqrt( this._r * this._r + this._i * this._i );
    }
    magSquared() { // magnitude squared
        return this._r * this._r + this._i * this._i;
    }
    arg() { // argument, also called phase, i.e. the angle of the complex number; always in [0,2 pi]
        return Util.angleIn2D( this._r, this._i );
    }


    // Returns the sum of the two given complex numbers.
    static sum(c1,c2) {
        return new Complex( c1._r+c2._r, c1._i+c2._i );
    }
    // Returns the difference of the two given complex numbers.
    static diff(c1,c2) {
        return new Complex( c1._r-c2._r, c1._i-c2._i );
    }
    // Returns the product of the two given numbers.
    static mult(c1,c2) {
        if ( c1 instanceof Complex ) {
            if ( c2 instanceof Complex ) {
                return new Complex( c1._r*c2._r - c1._i*c2._i, c1._r*c2._i + c1._i*c2._r );
            }
            return new Complex( c1._r * c2, c1._i * c2 );
        }
        else if ( c2 instanceof Complex ) {
            return new Complex( c1 * c2._r, c1 * c2._i );
        }
        return c1 * c2;
    }
    // returns true if the given numbers are approximately equal, within the given tolerance
    static approximatelyEqual(a,b,tolerance=precisionForApproximateComparison,printMessage=true) {
        Util.assert(a instanceof Complex && b instanceof Complex, "Complex.approximatelyEqual(): unknown type");
        let delta = Complex.diff(a,b).mag();
        if ( delta > tolerance ) {
            if ( printMessage ) {
                console.log(`Complex.approximatelyEqual(): difference of ${delta} found`);
            }
            return false;
        }
        return true;
    }
}
Complex.i = new Complex(0,1);


// This is a complex matrix, i.e., a matrix containing complex numbers.
// To save on overhead, the complex numbers are stored as consecutive pairs of numbers in a floating point number array.
class CMatrix {
    // allocates space in memory containing zeros
    allocate( numRows, numCols ) {
        this._rows = numRows;
        this._cols = numCols;
        this._m = new Float32Array(
            numRows * numCols
            * 2 // because we're storing a real and imaginary component for each matrix element
        );
    }
    constructor( numRows, numCols ) {
        Util.assert( numRows > 0 && numCols > 0, "CMatrix.constructor(): invalid size requested" );
        this.allocate( numRows, numCols );
    }
    // Gets the value in a cell.
    // row and column indices are zero-based.
    // returns a complex number.
    get(row,col) {
        let j = ( row * this._cols + col )*2;
        return new Complex( this._m[j], this._m[j+1] );
    }
    // Sets the value in a cell.
    // row and column indices are zero-based.
    // The value passed in can be a (real) number or a complex number.
    set(row,col,value) {
        let j = ( row * this._cols + col )*2;
        if ( typeof(value)==='number' ) {
            this._m[j  ] = value; // real component
            this._m[j+1] = 0;
        }
        else if ( typeof(value)==='object' && value instanceof Complex ) {
            this._m[j  ] = value._r;
            this._m[j+1] = value._i;
        }
        else Util.assert(false,"CMatrix.set(): unknown type");
    }
    // Returns a deep copy of the matrix
    copy() {
        let M = new CMatrix( this._rows, this._cols );
        M._m.set( this._m ); // this copies the contents of one to the other
        return M;
    }
    // Returns the transpose of the matrix
    transpose() {
        let M = new CMatrix( this._cols, this._rows );
        for ( let r = 0; r < this._rows; ++r ) {
            for ( let c = 0; c < this._cols; ++c ) {
                M.set( c, r, this.get(r,c) );
            }
        }
        return M;
    }
    conjugate() {
        let M = new CMatrix( this._rows, this._cols );
        for ( let r = 0; r < this._rows; ++r ) {
            for ( let c = 0; c < this._cols; ++c ) {
                M.set( r, c, this.get(r,c).conjugate() );
            }
        }
        return M;
    }
    // Returns the transpose of the matrix, also known as adjoint matrix or transjugate
    conjugateTranspose() {
        let M = new CMatrix( this._cols, this._rows );
        for ( let r = 0; r < this._rows; ++r ) {
            for ( let c = 0; c < this._cols; ++c ) {
                M.set( c, r, this.get(r,c).conjugate() );
            }
        }
        return M;
    }
    // Returns a complex number equal to the trace (i.e., sum of diagonal elements) of a square matrix
    trace() {
        Util.assert( this._rows === this._cols, "CMatrix.trace(): matrix is not square" );
        let returnValue = new Complex();
        for ( let r = 0; r < this._rows; ++r ) {
            returnValue = Complex.sum( returnValue, this.get(r,r) );
        }
        return returnValue;
    }
    reverseEndianness( actuallyReverseThings=true ) { // should only be called on a row vector, column vector, or matrix whose dimensions are powers of 2
        if ( ! actuallyReverseThings )
            return this; // never mind
        let M = new CMatrix( this._rows, this._cols );
        for ( let r = 0; r < this._rows; ++r ) {
            let r2 = Util.reverseEndianness(r,this._rows);
            for ( let c = 0; c < this._cols; ++c ) {
                let c2 = Util.reverseEndianness(c,this._cols);
                M.set( r2, c2, this.get(r,c) );
            }
        }
        return M;
    }
    // Returns a multiline string, e.g.,
    // a 4x2 matrix might yield "[0,1+2i]\n[1,1   ]\n[0,2i  ]\n[1,0   ]"
    toString(
        // this syntax allows for something similar to named parameters
        { binaryPrefixes=false, decimalPrecision=defaultDecimalPrecision, suppressZeros=true/*makes large binary matrices easier to read*/, charToReplaceSuppressedZero='_' }={}
    ) {
        let arrayOfPrefixStrings = [];
        if ( binaryPrefixes ) {
            let targetWidth = Math.ceil( Math.log2(this._rows) );
            for ( let r = 0; r < this._rows; ++r ) {
                let binaryString = StringUtil.intToBinaryString( r, targetWidth );
                if ( usingTextbookConvention )
                    binaryString = '|' + StringUtil.reverseString( binaryString ) + '>';
                else
                    binaryString = '|' + binaryString + '>';
                arrayOfPrefixStrings.push( binaryString );
            }
        }
        let arrayOfArraysOfStrings = [];
        for ( let r = 0; r < this._rows; ++r ) {
            arrayOfArraysOfStrings.push( [] );
            for ( let c = 0; c < this._cols; ++c ) {
                arrayOfArraysOfStrings[r].push( this.get(r,c).toString(decimalPrecision) );
            }
        }
        let maxMaxWidth = 0;
        for ( let c = 0; c < this._cols; ++c ) {
            let maxWidth = 0;
            for ( let r = 0; r < this._rows; ++r ) {
                let w = arrayOfArraysOfStrings[r][c].length;
                if ( w > maxWidth ) {
                    maxWidth = w;
                    if ( maxWidth > maxMaxWidth ) maxMaxWidth = maxWidth;
                }
            }
            // now we know the max width for this column, so we can pad with spaces
            for ( let r = 0; r < this._rows; ++r ) {
                let w = arrayOfArraysOfStrings[r][c].length;
                arrayOfArraysOfStrings[r][c] += StringUtil.repeatString(' ',maxWidth-w);
            }
        }
        // now we have finished padding all the strings with spaces
        // so we can build the multiline string
        let returnValue = '';
        for ( let r = 0; r < this._rows; ++r ) {
            if ( binaryPrefixes )
                returnValue += arrayOfPrefixStrings[r];
            returnValue += '[';
            for ( let c = 0; c < this._cols; ++c ) {
                if ( suppressZeros && maxMaxWidth===1 && arrayOfArraysOfStrings[r][c]==='0' )
                    returnValue += charToReplaceSuppressedZero;
                else
                    returnValue += arrayOfArraysOfStrings[r][c];
                if ( c < this._cols-1 )
                    returnValue += ',';
            }
            returnValue += ']';
            if ( r < this._rows-1 )
                returnValue += '\n';
        }
        return returnValue;
    }


    // Returns the sum of the two given matrices.
    static sum(a,b) {
        Util.assert(a instanceof CMatrix && b instanceof CMatrix,"CMatrix.sum(): wrong type");
        Util.assert(a._rows === b._rows && a._cols === b._cols, "CMatrix.sum(): incompatible dimensions" );
        let M = a.copy();
        for ( let j = M._m.length-1; j >= 0; j-- )
            M._m[j] += b._m[j];
        return M;
    }

    // Returns the difference of the two given matrices.
    static diff(a,b) {
        Util.assert(a instanceof CMatrix && b instanceof CMatrix,"CMatrix.diff(): wrong type");
        Util.assert(a._rows === b._rows && a._cols === b._cols, "CMatrix.diff(): incompatible dimensions" );
        let M = a.copy();
        for ( let j = M._m.length-1; j >= 0; j-- )
            M._m[j] -= b._m[j];
        return M;
    }
    // Returns the product of the two given matrices,
    // or of a matrix with a scalar.
    static mult( a, b ) {
        Util.assert(a instanceof CMatrix || b instanceof CMatrix,"CMatrix.mult(): wrong type");

        if ( !( a instanceof CMatrix ) ) {
            // swap a and b, so that a will be the matrix and b the scalar
            let tmp = b;
            b = a;
            a = tmp;
        }

        if ( typeof(b)==='number' ) {
            let M = a.copy();
            for ( let j = M._m.length-1; j >= 0; j-- )
                M._m[j] *= b;
            return M;
        }
        else if ( b instanceof Complex ) {
            let M = new CMatrix(a._rows,a._cols);
            for ( let r = 0; r < M._rows; r++ ) {
                for ( let c = 0; c < M._cols; c++ ) {
                    let product = Complex.mult(a.get(r,c),b);
                    M.set(r,c,product);
                }
            }
            return M;
        }
        else if ( b instanceof CMatrix ) {
            Util.assert(a._cols === b._rows, "CMatrix.mult(): matrices have incompatible dimensions" );
            let M = new CMatrix(a._rows,b._cols);
            for ( let r = 0; r < M._rows; r++ ) {
                for ( let c = 0; c < M._cols; c++ ) {
                    let dotProduct = new Complex();
                    for ( let k = 0; k < a._cols; ++k ) {
                        // TODO this line creates 4 instances of Complex that ultimately aren't
                        // needed; this could be optimized by expanding and inlining the math ops.
                        dotProduct = Complex.sum(dotProduct,Complex.mult(a.get(r,k),b.get(k,c)));
                    }
                    M.set(r,c,dotProduct);
                }
            }
            return M;
        }
        else Util.assert(false,"CMatrix.mult(): unknown type");
    }
    // The kronecker product, or tensor product, of two matrices.
    static tensor(a,b,isReversed=false) {
        Util.assert(a instanceof CMatrix && b instanceof CMatrix,"CMatrix.tensor(): wrong type");
        if ( isReversed ) {
            let tmp = a;
            a = b;
            b = tmp;
        }
        let numRows = a._rows * b._rows;
        let numCols = a._cols * b._cols;
        let M = new CMatrix(numRows,numCols);
        for ( let ar = 0; ar < a._rows; ar++ ) {
            for ( let br = 0; br < b._rows; br++ ) {
                for ( let ac = 0; ac < a._cols; ac++ ) {
                    for ( let bc = 0; bc < b._cols; bc++ ) {
                        M.set(
                            ar*b._rows + br,
                            ac*b._cols + bc,
                            Complex.mult( a.get(ar,ac), b.get(br,bc) )
                        );
                    }
                }
            }
        }
        return M;
    }
    // Imagine you want to form the product of many matrices m1 x m2 x ... mN
    // You can obtain this product by calling the below routine with argument [m1,m2,...,mN]
    //
    // Since matrix multiplication is associative, we have a choice of computing the product
    // starting with whatever matrices we like.
    // It turns out to be more efficient to compute the product of smaller matrices first.
    // So, this routine searches through the given list for the consecutive pair
    // of smallest matrices, replaces them with their product, and repeats.
    static naryMult( list ) {
        Util.assert( list.length>0 && list[0] instanceof CMatrix, "CMatrix.naryMult(): invalid input" );
        // let totalCost = 0;
        while ( list.length > 1 ) {
            let lowestCost = 0;
            let indexForLowestCost = -1;
            for ( let i = 0; i < list.length-1; ++i ) {
                // compute the cost of computing the product of the ith and (i+1)th matrices
                let cost = list[i]._rows * list[i]._cols * list[i+1]._cols;
                if ( indexForLowestCost < 0 || cost < lowestCost ) {
                    lowestCost = cost;
                    indexForLowestCost = i;
                }
            }
            // Replace the lowest-cost pair of matrices with a single matrix
            let a = list[ indexForLowestCost ];
            let b = list[ indexForLowestCost + 1 ];
            // replace the ith and (i+1)th matrices with their product
            list.splice( indexForLowestCost, 2, CMatrix.mult(a,b) );
            // totalCost += lowestCost;
        }
        // console.log("totalCost: " + totalCost);
        return list[0];
    }
    // Imagine you want to form the tensor product of many matrices m1 x m2 x ... mN
    // You can obtain this product by calling the below routine with argument [m1,m2,...,mN]
    //
    // Since the tensor product is associative, we have a choice of computing the product
    // starting with whatever matrices we like.
    // It turns out to be more efficient to compute the product of smaller matrices first.
    // So, this routine searches through the given list for the consecutive pair
    // of smallest matrices, replaces them with their product, and repeats.
    static naryTensor( list, isReversed=false ) {
        Util.assert( list.length>0 && list[0] instanceof CMatrix, "CMatrix.naryTensor(): invalid input" );
        if ( isReversed ) {
            list.reverse();
        }
        // let totalCost = 0;
        while ( list.length > 1 ) {
            let lowestCost = 0;
            let indexForLowestCost = -1;
            for ( let i = 0; i < list.length-1; ++i ) {
                // compute the cost of computing the product of the ith and (i+1)th matrices
                let cost = list[i]._rows * list[i]._cols * list[i+1]._rows * list[i+1]._cols;
                if ( indexForLowestCost < 0 || cost < lowestCost ) {
                    lowestCost = cost;
                    indexForLowestCost = i;
                }
            }
            // Replace the lowest-cost pair of matrices with a single matrix
            let a = list[ indexForLowestCost ];
            let b = list[ indexForLowestCost + 1 ];
            // replace the ith and (i+1)th matrices with their product
            list.splice( indexForLowestCost, 2, CMatrix.tensor(a,b) );
            // totalCost += lowestCost;
        }
        // console.log("totalCost: " + totalCost);
        return list[0];
    }
    // TODO This should be improved using exponentiation by squaring or binary exponentiation, and something similar could be done for a power() method that raises a matrix to a given exponent
    static tensorPower( matrix, exponent ) {
        Util.assert( exponent>0 && matrix instanceof CMatrix, "CMatrix.naryTensor(): invalid input" );
        let list = [];
        for ( let i = 0; i < exponent; ++i ) {
            list.push( matrix );
        }
        return CMatrix.naryTensor( list );
    }

    // If the caller needs to know Trace(A * B),
    // this subroutine saves time by only computing the diagonal elements of the matrix product.
    // This is equivalent to taking the transpose of one of the matrices,
    // doing element-wise multiplication, and adding up all the elements in the resulting matrix.
    //
    static traceOfMatrixProduct( A, B ) {
        Util.assert(A._cols === B._rows, "CMatrix.traceOfMatrixProduct(): matrices have incompatible dimensions" );
        Util.assert(A._rows === B._cols, "CMatrix.traceOfMatrixProduct(): matrix product is not square, hence trace is not defined" );
        let product_size = A._rows;
        let returnValue = new Complex();
        for ( let ii = 0; ii < product_size; ii++ ) {
            let dotProduct = new Complex();
            for ( let k = 0; k < A._cols; ++k ) {
                // TODO this line creates 4 instances of Complex that ultimately aren't
                // needed; this could be optimized by expanding and inlining the math ops.
                dotProduct = Complex.sum(dotProduct,Complex.mult(A.get(ii,k),B.get(k,ii)));
            }
            returnValue = Complex.sum( returnValue, dotProduct );
        }
        return returnValue;
    }

    // returns true if the given matrices are approximately equal, within the given tolerance
    static approximatelyEqual(a,b,tolerance=precisionForApproximateComparison,printMessage=true) {
        Util.assert(a instanceof CMatrix && b instanceof CMatrix,"CMatrix.approximatelyEqual(): wrong type");
        Util.assert(a._rows === b._rows && a._cols === b._cols, "CMatrix.approximatelyEqual(): incompatible dimensions" );
        for ( let j = a._m.length-1; j >= 0; j-- ) { // check each component
            let delta = Math.abs( a._m[j] - b._m[j] );
            if ( delta > tolerance ) {
                if ( printMessage ) {
                    console.log(`CMatrix.approximatelyEqual(): difference of ${delta} found`);
                }
                return false;
            }
        }
        return true;
    }


    // Creates and returns a matrix by copying the contents of the given array of arrays,
    // which can contain numbers or complex numbers.
    // Assumes that the given array is not jagged.
    static create( arrayOfArrays ) {
        let numRows = arrayOfArrays.length;
        let numCols = arrayOfArrays[0].length;
        let M = new CMatrix( numRows, numCols );
        for ( let j = 0; j < numRows; ++j ) {
            for ( let k = 0; k < numCols; ++k ) {
                M.set( j, k, arrayOfArrays[j][k] );
            }
        }
        return M;
    }
    // Creates a nx1 size matrix
    static createColVector( array ) {
        return this.create( array.map( x => [ x ] ) );
    }
    // Creates a 1xn size matrix
    static createRowVector( array ) {
        return this.create( [ array ] );
    }
    // Returns an identity matrix of the given size
    static identity( numRows ) {
        let M = new CMatrix( numRows, numRows );
        for ( let k = 0; k < numRows; ++k )
            M.set(k,k,1);
        return M;
    }
}

class Sim { // Simulator

    static GlobalPhase( angleInDegrees ) {
        let angleInRadians = angleInDegrees / 180.0 * Math.PI;
        let globalPhaseChange = new Complex( Math.cos(angleInRadians), Math.sin(angleInRadians) );
        return CMatrix.create([[globalPhaseChange,0],[0,globalPhaseChange]]);
    }
    // Note that
    //     Phase(angle) * GlobalPhase( -angle/2 ) = RZ( angle )
    //     Phase(angle) = RZ( angle ) * GlobalPhase( angle/2 )
    static Phase( angleInDegrees ) {
        let angleInRadians = angleInDegrees / 180.0 * Math.PI;
        let phaseChange = new Complex( Math.cos(angleInRadians), Math.sin(angleInRadians) );
        return CMatrix.create([[1,0],[0,phaseChange]]);
    }
    // Pauli X exponential, equal to X^k where k is the input parameter
    static XE( parameter ) {
        let angleInRadians = parameter * Math.PI;
        let phaseChange = new Complex( 0.5 * Math.cos(angleInRadians), 0.5 * Math.sin(angleInRadians) );
        let a = Complex.sum( new Complex(0.5,0), phaseChange );
        let b = Complex.diff( new Complex(0.5,0), phaseChange );
        return CMatrix.create([[a,b],[b,a]]);
    }
    // Pauli Y exponential, equal to Y^k where k is the input parameter
    static YE( parameter ) {
        let angleInRadians = parameter * Math.PI;
        let phaseChange = new Complex( 0.5 * Math.cos(angleInRadians), 0.5 * Math.sin(angleInRadians) );
        let a = Complex.sum( new Complex(0.5,0), phaseChange );
        let b = Complex.mult( new Complex(0,1), Complex.diff( phaseChange, new Complex(0.5,0) ) );
        let c = b.negate();
        return CMatrix.create([[a,b],[c,a]]);
    }
    // Pauli Z exponential, equal to Z^k where k is the input parameter
    static ZE( parameter ) {
        let angleInRadians = parameter * Math.PI;
        let phaseChange = new Complex( Math.cos(angleInRadians), Math.sin(angleInRadians) );
        return CMatrix.create([[1,0],[0,phaseChange]]);
    }
    // Returns a 2x2 matrix that rotates around an axis of the Bloch sphere.
    // With a 180 degree angle, this is equivalent to a Pauli X gate (also called NOT gate)
    // but differs by a global phase.
    // More particularly, the following print statements should output the same thing:
    //   console.log(CMatrix.mult(Sim.RX(180),Sim.GlobalPhase(90)).toString());
    //   console.log(Sim.X.toString());
    //
    static RX( angleInDegrees ) {
        let angleInRadians = angleInDegrees / 180.0 * Math.PI;
        let halfAngle = angleInRadians / 2;
        let sine = Math.sin( halfAngle );
        let cosine = Math.cos( halfAngle );
        return CMatrix.create( [
            [ new Complex(cosine,0), new Complex(0,-sine) ],
            [ new Complex(0,-sine),  new Complex(cosine,0) ],
        ] );
    }
    // Returns a 2x2 matrix that rotates around an axis of the Bloch sphere.
    // With a 180 degree angle, this is equivalent to a Pauli Y gate
    // but differs by a global phase.
    // More particularly, the following print statements should output the same thing:
    //   console.log(CMatrix.mult(Sim.RY(180),Sim.GlobalPhase(90)).toString());
    //   console.log(Sim.Y.toString());
    //
    static RY( angleInDegrees ) {
        let angleInRadians = angleInDegrees / 180.0 * Math.PI;
        let halfAngle = angleInRadians / 2;
        let sine = Math.sin( halfAngle );
        let cosine = Math.cos( halfAngle );
        return CMatrix.create( [
            [ new Complex(cosine,0), new Complex(-sine,0) ],
            [ new Complex(sine,0),  new Complex(cosine,0) ],
        ] );
    }
    // Returns a 2x2 matrix that rotates around an axis of the Bloch sphere.
    // With a 180 degree angle, this is equivalent to a Pauli Z gate
    // but differs by a global phase.
    // More particularly, the following print statements should output the same thing:
    //   console.log(CMatrix.mult(Sim.RZ(180),Sim.GlobalPhase(90)).toString());
    //   console.log(Sim.Z.toString());
    //
    static RZ( angleInDegrees ) {
        let angleInRadians = angleInDegrees / 180.0 * Math.PI;
        let halfAngle = angleInRadians / 2;
        let sine = Math.sin( halfAngle );
        let cosine = Math.cos( halfAngle );
        return CMatrix.create( [
            [ new Complex(cosine,-sine), new Complex(0,0) ],
            [ new Complex(0,0),  new Complex(cosine,sine) ],
        ] );
    }
    // This rotates around the given vector by an angle in radians equal to the magnitude of the given vector.
    // This way of encoding the angle in the vector of the axis of rotation might seem strange,
    // but it means that the output is continuous in all 3 input variables and therefore easier to optimize,
    // which would not be the case with a parametrization where the angle is separate from the vector components of the axis.
    // (To see why, consider the latter parametrization, and imagine what would happen as the input shifts
    // from (ax,ay-epsilon,az,angle) to (ax,ay+epsilon,az,angle).
    // This would result in a 180 degree change of axis direction and a discontinuous change in output.
    // The same kind of change of axis direction in the first parametrization would require the angle to pass through zero,
    // avoiding a discontinuity in the output.)
    //
    // For the definition of the matrix, see
    //     https://arxiv.org/abs/2104.14875
    //     Hiroshi C. Watanabe, Rudy Raymond, Yu-ya Ohnishi, Eriko Kaminishi, Michihiko Sugawara
    //     Optimizing Parameterized Quantum Circuits with Free-Axis Selection
    // in particular equation (1) on page 4.
    // See also the documentation for the RVGate in Qiskit
    //     https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.RVGate
    // although, at the time of writing, that documentation contains typos.
    // See also the source code for the RVGate in Qiskit
    //     https://github.com/Qiskit/qiskit/blob/stable/0.46/qiskit/circuit/library/generalized_gates/rv.py
    //
    // If (ax,ay,az) is proportional to (1,0,0), or to (0,1,0), or to (0,0,1),
    // the result is equivalent to RX, RY, or RZ, respectively.
    static RotFreeAxis( ax, ay, az ) {
        let magSquared = ax*ax + ay*ay + az*az;
        if ( magSquared === 0 ) {
            return Sim.I;
        }
        let angleInRadians = Math.sqrt( magSquared );
        ax /= angleInRadians;
        ay /= angleInRadians;
        az /= angleInRadians;
        let halfAngle = angleInRadians / 2;
        let sine = Math.sin( halfAngle );
        let cosine = Math.cos( halfAngle );
        return CMatrix.create( [
            [ new Complex(cosine,-az*sine), new Complex(-ay*sine,-ax*sine) ],
            [ new Complex(ay*sine,-ax*sine),  new Complex(cosine,az*sine) ],
        ] );
    }
    static RotFreeAxisAngle( ax, ay, az, angleInDegrees ) { // rotates around the given axis by the given angle
        let angleInRadians = angleInDegrees / 180.0 * Math.PI;
        let magSquared = ax*ax + ay*ay + az*az;
        if ( magSquared === 0 || angleInDegrees === 0 ) {
            return Sim.I;
        }
        let k = angleInRadians / Math.sqrt( magSquared );
        return Sim.RotFreeAxis( ax * k, ay * k, az * k );
    }

    // BEGIN: These are for non-standard gates proposed by McGuffin
    //
    // Generalized Z
    static Z_G( angle1InDegrees, angle2InDegrees ) {
        let angle1InRadians = angle1InDegrees / 180.0 * Math.PI;
        let angle2InRadians = angle2InDegrees / 180.0 * Math.PI;
        let phaseChange1 = new Complex( Math.cos(angle1InRadians), Math.sin(angle1InRadians) );
        let phaseChange2 = new Complex( Math.cos(angle2InRadians), Math.sin(angle2InRadians) );
        return CMatrix.create([[phaseChange1,0],[0,phaseChange2]]);
    }
    // Generalized Y
    static Y_G( angle1InDegrees, angle2InDegrees ) {
        let angle1InRadians = angle1InDegrees / 180.0 * Math.PI;
        let angle2InRadians = angle2InDegrees / 180.0 * Math.PI;
        let phaseChange1 = new Complex( Math.cos(angle1InRadians), Math.sin(angle1InRadians) );
        let phaseChange2 = new Complex( Math.cos(angle2InRadians), Math.sin(angle2InRadians) );
        return CMatrix.create([[0,phaseChange2],[phaseChange1,0]]);
    }
    // Generalized Hadamard
    static H_G( angle1InDegrees, angle2InDegrees ) {
        let angle1InRadians = angle1InDegrees / 180.0 * Math.PI;
        let angle2InRadians = angle2InDegrees / 180.0 * Math.PI;
        let phaseChange1 = new Complex( Math.SQRT1_2*Math.cos(angle1InRadians), Math.SQRT1_2*Math.sin(angle1InRadians) );
        let phaseChange2 = new Complex( Math.SQRT1_2*Math.cos(angle2InRadians), Math.SQRT1_2*Math.sin(angle2InRadians) );
        return CMatrix.create([[ phaseChange1, phaseChange2 ],[ phaseChange1, phaseChange2.negate() ]]);
    }
    //
    // END

    // Returns a matrix for swapping wires i and j in a quantum circuit with n wires.
    // i and j are zero-based, i.e., they are between 0 and (n-1).
    // The matrix that is returned has size (2**n)x(2**n)
    static SWAP(i,j,n) {
        Util.assert( 0<=i && i<n && 0<=j && j<n, "Sim.SWAP(): invalid indices" );
        Util.assert( i!=j, "Sim.SWAP(): indices are unexpectedly equal" );
        let matrixSize = 2 ** n;
        if ( i === j ) {
            return CMatrix.identity( matrixSize );
        }
        let M = new CMatrix( matrixSize, matrixSize );

        if ( usingTextbookConvention ) {
            // inverting the wire indices like this is equivalent to calling reverseEndianness() on the matrix just before returning it, but this is more efficient
            i = n-1 - i;
            j = n-1 - j;
        }

        // define stuff for operating on bits
        let mask_i = 1 << i;
        let mask_j = 1 << j;
        let antimask = ~( mask_i | mask_j );

        for ( let r = 0; r < matrixSize; ++r ) {
            let c = r;

            // BEGIN: swap the ith and jth bits of c
            let extracted_bit_i = c & mask_i;
            let extracted_bit_j = c & mask_j;
            c &= antimask; // turns off bits i and j
            if ( extracted_bit_i !== 0 ) c |= mask_j; // turns on bit j
            if ( extracted_bit_j !== 0 ) c |= mask_i; // turns on bit i
            // END

            M.set(r,c,1);
        }
        return M;
    }
    // Given a 4x4 matrix, which operates on two qubits q0 and q1,
    // this routine modifies it so that it will operate on the ith and jth qubits
    // of an n-qubit circuit.
    // The matrix that is returned has size (2**n)x(2**n)
    // For example, passing in arguments (m,1,0,2)
    // returns an 'upside-down' version of the original matrix.
    static expand4x4ForNWires(m/*a 4x4 matrix*/,i,j,n/*number of qubits in the circuit*/) {
        Util.assert( 0<=i && i<n && 0<=j && j<n && i!=j, "Sim.expand4x4ForNWires(): invalid indices" );
        Util.assert( m._rows===m._cols && m._rows===4, "Sim.expand4x4ForNWires(): invalid size" );

        // Step 1: turn the matrix upside down, if necessary
        let m1 = null;
        if ( i > j ) {
            //
            //              +----+                +---+
            //        q_0 --|    |--     q_0 --X--|   |--X--
            //              | m1 |    =        |  | m |  |
            //        q_1 --|    |--     q_1 --X--|   |--X--
            //              +----+                +---+
            //
            //              +----+                +---+
            // q_i' = q_j --|    |--     q_j --X--|   |--X--
            //              | m1 |    =        |  | m |  |
            // q_j' = q_i --|    |--     q_i --X--|   |--X--
            //              +----+                +---+
            //
            m1 = CMatrix.naryMult([ Sim.SWAP_2, m, Sim.SWAP_2 ]);
            let tmp = i;
            i = j;
            j = tmp;
            Util.assert(i<j,"Sim.expand4x4ForNWires(): unexpected condition");
        }
        else {
            m1 = m.copy();
        }

        // Step 2: account for wires in between i and j
        let m2 = null;
        let numInnerWires = j-i-1;
        if ( numInnerWires > 0 ) {
            //
            //       q_0 --+----+--           q_0 -----+----+-----
            //             |    |                      | m1 |
            //       q_1 --|    |--           q_1 --X--+----+--X--
            //             |    |                   |          |
            //       ... --|    |--           ... --|----------|--
            //             | m2 |    =              |          |
            //             |    |             ...
            //             |    |                   |          |
            //       ... --|    |--           ... --|----------|--
            //             |    |                   |          |
            //   q_{j-i} --+----+--       q_{j-i} --X----------X--
            //
            let swapStep = CMatrix.tensor( Sim.SWAP(0,numInnerWires,numInnerWires+1), Sim.I, usingTextbookConvention );
            m2 = CMatrix.naryMult( [
                swapStep,
                CMatrix.tensor( CMatrix.identity(2**numInnerWires), m1, usingTextbookConvention ),
                swapStep
            ] );
        }
        else {
            m2 = m1;
        }

        // Step 3: if there are wires before i, and/or after j,
        // we must perform a tensor product with an appropriately sized identity matrix,
        // either before and/or after m2, respectively.
        // Rather than do these tensor products separately here,
        // we put the relevant matrices in a list and let naryTensor()
        // perform the tensor products in the optimal associative order.
        //
        let listOfMatrices = [ m2 ];
        let numWiresBefore = i;
        if ( numWiresBefore > 0 ) {
            listOfMatrices.push( CMatrix.identity(2**numWiresBefore) ); // add to end of list
        }
        let numWiresAfter = n-1-j;
        if ( numWiresAfter > 0 ) {
            listOfMatrices.unshift( CMatrix.identity(2**numWiresAfter) ); // insert at beginning of list
        }
        let m3 = CMatrix.naryTensor( listOfMatrices, usingTextbookConvention  );

        return m3;
    }

    // Returns the product of (I⊗... ⊗I⊗U⊗I⊗...⊗I) and |stateVector>,
    // where I is the 2×2 identity matrix, U is a given 2×2 matrix,
    // |stateVector> is a (2^n)×1 column vector, and the return value is
    // another column vector of the same size.
    // The tensor product in parentheses has n factors, and would
    // result in a matrix of size (2^n)×(2^n) if evaluated explicitly.
    // U is at a position in the tensor product given by i_w,
    // with i_w=0 or i_w=n-1 indicating that U
    // is the right-most or left-most factor, respectively.
    // The algorithm avoids explicitly computing the tensor product
    // in parentheses, and takes O(2^n) time.
    // Control bits and anti-control bits limit the effect of U
    // to a subset of the amplitudes in |stateVector>.
    //
    // Imagine the state vector partitioned into contiguous blocks of equal size,
    // with each block partitioned into two half blocks.
    // The below code steps through the blocks, and within each block, for each i,
    // it will take the ith amplitude of the first half block and the ith amplitude
    // of the second half block, store those two amplitudes in a temporary vector
    // (this is the "collect" step, since it collects the amplitudes into the temporary vector),
    // apply the 2x2 matrix to that temporary vector, and store the resulting amplitudes
    // back in the ith positions of the half blocks (the "scatter" step).
    //
    // The below code is similar to the code in Quirk ( https://github.com/Strilanc/Quirk/ ,
    // src/math/Matrix.js , applyToStateVectorAtQubitWithControls() )
    // and also similar to the pseudocode in Figure 6.1 of the book by Viamontes et al.
    // (Viamontes, G. F., Markov, I. L., & Hayes, J. P. (2009) "Quantum circuit simulation")
    // Viamontes et al. call this algorithm "qubit-wise multiplication".
    //
    // To compare with Quirk's version of the code, it helps to know that Quirk's source code
    // calls the tempVector a 'chunk', and it uses different names for several variables,
    // listed below.  Also, our version has indices and sizes of things in complex numbers
    // (i.e., in amplitudes), whereas Quirk's corresponding quantities are in floats and
    // are therefore doubled.
    //
    //     Some quantities in our code, and the corresponding quantities in Quirk's code:
    //         sizeOfHalfBlock (in complex numbers) is (strideLength (in floats))/2
    //         sizeOfBlock (in complex numbers) is (strideChunkSize (in floats))/2
    //         indexOfStartOfBlock (in complex numbers) is (strideChunkStart (in floats))/2
    //         offsetWithinBlock (in complex numbers) is (strideOffset (in floats))/2
    //
    // Viamontes et al., Figure 6.1, appears to be the same algorithm. The inner "for" loop
    // in it performs the "collect" step, and the line of code immediately following,
    // which uses slice notation (res[a:...:gap]), performs the "scatter" step.
    // The 'gap' variable in Viamontes et al.'s version is sizeOfHalfBlock in our code.
    // However, Viamontes et al., Figure 6.1 also contains errors: it mentions a
    // "group_factor" that is undefined, and contains a stray closing brace.
    // There are other things about it that are confusing which I haven't
    // fully analyzed.  Finally, Viamontes et al.'s version has no support for control bits.
    //
    static qubitWiseMultiply(
        U, // a 2x2 matrix
        i_w, // index of wire on which to apply U, 0 <= i_w <= n-1
        n, // number of qubits in the circuit, 1 <= n
        stateVector, // the state vector to transform; a matrix of size (2**n)x1, i.e. a column vector
        listOfControlBits = [] // a list of pairs of the form [wire_index, flag] where 0<=wire_index<n and flag is true for a control bit and false for an anti-control bit
    ) {
        let sizeOfStateVector = 1 << n;
        Util.assert( 0<=i_w && i_w<n, "Sim.qubitWiseMultiply(): invalid index" );
        Util.assert( U._rows===U._cols && U._rows===2, "Sim.qubitWiseMultiply(): invalid size" );
        Util.assert( stateVector._rows===sizeOfStateVector && stateVector._cols===1, "Sim.qubitWiseMultiply(): state vector has invalid size" );

        let inclusionMask = 0;
        let desiredValueMask = 0;
        for ( let iter of listOfControlBits ) {
            let [wireIndex,flag] = iter;
            if ( usingTextbookConvention )
                wireIndex = n-1 - wireIndex;
            let bit = 1 << wireIndex;
            inclusionMask |= bit;
            if ( flag )
                desiredValueMask |= bit;
        }

        if ( usingTextbookConvention )
            i_w = n-1 - i_w;
        let tempVector = new CMatrix(2,1);
        let sizeOfHalfBlock = 1 << i_w; // could be 1, 2, 4, ...
        let sizeOfBlock = sizeOfHalfBlock << 1; // could be 2, 4, 8 ...
        let result = stateVector.copy();
        for ( let indexOfStartOfBlock = 0; indexOfStartOfBlock < sizeOfStateVector; indexOfStartOfBlock += sizeOfBlock ) {
            for ( let offsetWithinBlock = 0; offsetWithinBlock < sizeOfHalfBlock; offsetWithinBlock ++ ) {
                Util.assert( indexOfStartOfBlock | offsetWithinBlock === indexOfStartOfBlock + offsetWithinBlock, "Sim.qubitWiseMultiply(): unexpected numbers" );
                let i1 = indexOfStartOfBlock | offsetWithinBlock; // equivalent to a sum
                if ( (i1 & inclusionMask) !== desiredValueMask )
                    continue;

                Util.assert( i1 | sizeOfHalfBlock === i1 + sizeOfHalfBlock, "Sim.qubitWiseMultiply(): unexpected numbers" );
                let i2 = i1 | sizeOfHalfBlock; // equivalent to a sum

                // Collect inputs into a small contiguous vector.
                tempVector.set( 0, 0, stateVector.get( i1, 0 ) );
                tempVector.set( 1, 0, stateVector.get( i2, 0 ) );

                let transformedVector = CMatrix.mult( U, tempVector );

                // Scatter outputs.
                result.set( i1, 0, transformedVector.get( 0, 0 ) );
                result.set( i2, 0, transformedVector.get( 1, 0 ) );
            }
        }
        return result;
    }

    static qubitWiseMultiply_multiQubitGate(
        k, // number of wires covered by U, 1 <= k
        U, // a square matrix of size 2^k x 2^k, 1 <= k
        i_w, // index of first wire on which to apply U, 0 <= i_w <= n-k
        n, // number of qubits in the circuit, 1 <= k <= n
        stateVector, // the state vector to transform; a matrix of size (2**n)x1, i.e. a column vector
        listOfControlBits = [] // a list of pairs of the form [wire_index, flag] where 0<=wire_index<n and flag is true for a control bit and false for an anti-control bit
    ) {
        let sizeOfStateVector = 1 << n;
        Util.assert( 1<=k && k<=n, "Sim.qubitWiseMultiply_multiQubitGate(): invalid index" );
        Util.assert( 0<=i_w && i_w<=n-k, "Sim.qubitWiseMultiply_multiQubitGate(): invalid index" );
        Util.assert( U._rows===U._cols && U._rows===(1<<k), "Sim.qubitWiseMultiply_multiQubitGate(): invalid size" );
        Util.assert( stateVector._rows===sizeOfStateVector && stateVector._cols===1, "Sim.qubitWiseMultiply_multiQubitGate(): state vector has invalid size" );

        let inclusionMask = 0;
        let desiredValueMask = 0;
        for ( let iter of listOfControlBits ) {
            let [wireIndex,flag] = iter;
            if ( usingTextbookConvention )
                wireIndex = n-1 - wireIndex;
            let bit = 1 << wireIndex;
            inclusionMask |= bit;
            if ( flag )
                desiredValueMask |= bit;
        }

        if ( usingTextbookConvention )
            i_w = n-1 - i_w;
        let tempVector = new CMatrix( 1 << k, 1 );
        let sizeOfSubBlock = 1 << i_w; // could be 1, 2, 4, ...
        let sizeOfBlock = sizeOfSubBlock << k;
        let result = stateVector.copy();
        for ( let indexOfStartOfBlock = 0; indexOfStartOfBlock < sizeOfStateVector; indexOfStartOfBlock += sizeOfBlock ) {
            for ( let offsetWithinBlock = 0; offsetWithinBlock < sizeOfSubBlock; offsetWithinBlock ++ ) {
                Util.assert( indexOfStartOfBlock | offsetWithinBlock === indexOfStartOfBlock + offsetWithinBlock, "Sim.qubitWiseMultiply_multiQubitGate(): unexpected numbers" );
                let i1 = indexOfStartOfBlock | offsetWithinBlock; // equivalent to a sum
                if ( (i1 & inclusionMask) !== desiredValueMask )
                    continue;

                // Collect inputs into a small contiguous vector.
                let i2 = i1;
                for ( let i3 = 0; i3 < tempVector._rows; i3 ++ ) {
                    tempVector.set( i3, 0, stateVector.get( i2, 0 ) );
                    i2 += sizeOfSubBlock;
                }

                let transformedVector = CMatrix.mult( U, tempVector );

                // Scatter outputs.
                i2 = i1;
                for ( let i3 = 0; i3 < tempVector._rows; i3 ++ ) {
                    result.set( i2, 0, transformedVector.get( i3, 0 ) );
                    i2 += sizeOfSubBlock;
                }
            }
        }
        return result;
    }

    // Returns the given state vector |stateVector> after swapping wires i and j.
    // In other words, implements a SWAP gate on qubits i and j.
    // Avoids computing an explicit swap matrix of size (2**n)x(2**n), saving much memory and time.
    // Takes O(2^n) time.
    // Control bits and anti-control bits limit the effect of the SWAP
    // to a subset of the amplitudes in |stateVector>.
    static applySwap(
        i_w, j_w, // indices of wires to swap, 0 <= i_w <= n-1, 0 <= j_w <= n-1
        n, // number of qubits in the circuit, 1 <= n
        stateVector, // the state vector to transform; a matrix of size (2**n)x1, i.e. a column vector
        listOfControlBits = [] // a list of pairs of the form [wire_index, flag] where 0<=wire_index<n and flag is true for a control bit and false for an anti-control bit
    ) {
        let sizeOfStateVector = 1 << n;
        Util.assert( 0<=i_w && i_w<n && 0<=j_w && j_w<n, "Sim.applySwap(): invalid indices" );
        Util.assert( i_w!=j_w, "Sim.applySwap(): indices are unexpectedly equal" );
        Util.assert( stateVector._rows===sizeOfStateVector && stateVector._cols===1, "Sim.applySwap(): state vector has invalid size" );

        let result = stateVector.copy();
        if ( i_w === j_w ) {
            return result;
        }

        let inclusionMask = 0;
        let desiredValueMask = 0;
        for ( let iter of listOfControlBits ) {
            let [wireIndex,flag] = iter;
            if ( usingTextbookConvention )
                wireIndex = n-1 - wireIndex;
            let bit = 1 << wireIndex;
            inclusionMask |= bit;
            if ( flag )
                desiredValueMask |= bit;
        }

        if ( usingTextbookConvention ) {
            i_w = n-1 - i_w;
            j_w = n-1 - j_w;
        }
        if ( i_w > j_w ) {
            let tmp = i_w;
            i_w = j_w;
            j_w = tmp;
        }

        // define stuff for operating on bits
        let antimask_i = ~( 1 << i_w );
        let mask_j = 1 << j_w;

        for ( let k = 0; k < sizeOfStateVector; k ++ ) {
            if ( (k & inclusionMask) !== desiredValueMask )
                continue;

            let ithBitOfK = (k >> i_w) & 1;
            if ( ithBitOfK===1 ) {
                let jthBitOfK = (k >> j_w) & 1;

                // If the ith and jth bits are both 0 or both 1, we don't need to swap rows.
                // If the two bits have different values, we do want to swap rows k1 and k2.
                // But we don't want to swap those rows twice.
                // So we only swap when we encounter the case where the ith bit is 1 and the jth is 0.

                if ( jthBitOfK===0 ) {
                    let k2 = ( k & antimask_i ) | mask_j; // turn off bit i_w, turn on bit j_w
                    // swap the (k)th and (k2)th amplitudes
                    result.set(k2,0,stateVector.get(k,0));
                    result.set(k,0,stateVector.get(k2,0));
                }
            }
        }
        return result;
    }

    // Returns the given number i with its bits rearranged,
    // so that the 0th (least significant) bit of i is in position a[0],
    // the 1st bit of i is in position a[1], etc.
    // Negative positions in the array a are ignored.
    // Examples:
    // rearrangeBits(i,[1,0]) returns the two least-significant bits of i, swapped, and none of the other bits.
    // rearrangeBits(i,[0,1,2])) returns only the three least-significant bits of i, with their positions unchanged.
    // rearrangeBits(i,[3,0,1,2])) returns only the four least-significant bits of i,
    // shifted left (to one position more significant) and wrapped around.
    static rearrangeBits( i, a /* an array of new positions */ ) {
        let returnValue = 0;
        for ( let position = 0; position < a.length; position ++ ) {
            if ( a[position] >= 0 )
                returnValue |= ( (i >> position) & 1 ) << a[position];
        }
        return returnValue;
    }

    // Consider a 16x16 density matrix M defined for 4 qubits, numbered 0 to 3.
    // The caller could do
    //     partialTrace( 4, M,true,null, [0,1], true );
    // to trace out qubits 0 and 1, keeping 2 and 3, and returning a 4x4 matrix.
    // Or, the caller could do
    //     partialTrace( 4, M,true,null, [2,3], false );
    // which would be equivalent.
    //
    static partialTrace(
        n, // number of qubits

        inputMatrix, // a matrix of size (2**n)x(2**n)
        isInputMatrixHermitian, // If true (which it should be if we are dealing with a density matrix), then this enables the partial trace to save time.

        // If the client has a state vector psi, from which they will compute a density matrix M to pass in to us,
        // computing and storing this M is hugely expensive (O(4^n)) for large n.
        // So instead, the client can pass in their state vector psi here,
        // and the partial trace will compute each required (row,col)th entry of M
        // on the fly as psi[row]*psi[col].conjugate().
        // Even though this will make the partial trace a bit slower,
        // the time and memory saved by having the client not compute M is more than worth it.
        inputStateVector, // If non-null, it's assumed to be (2^n)x1, and inputMatrix is ignored.

        qubitArray, // an array of values in the range 0 to n-1, each representing a qubit
        arraySpecifiesQubitsToTraceOut, // if false, the array specifies the qubits to keep (i.e., marginal qubits)

        useLookupTable = true // Enables partial trace to go faster; should only be false for performance testing.
    ) {
        let twoN = 2**n;
        Util.assert(
            ( inputMatrix!==null && inputMatrix._rows===twoN && inputMatrix._cols===twoN )
            || ( inputStateVector!==null && inputStateVector._rows===twoN && inputStateVector._cols===1 ),
            "Sim.partialTrace(): input has invalid size"
        );
        Util.assert( 0 <= qubitArray.length && qubitArray.length <= n, "Sim.partialTrace(): array of qubit indices has invalid size" );

        if ( inputStateVector !== null ) {
            // Since we will use a state vector to compute entries of the input matrix on the fly,
            // the input matrix is a density matrix hence hermitian.
            isInputMatrixHermitian = true;
        }

        const _qubitArray = [...new Set(qubitArray)].sort((a, b) => a - b); // remove duplicates, and sort in ascending order
        Util.assert( (_qubitArray.length===0) || (0 <= _qubitArray[0] && _qubitArray[_qubitArray.length-1] < n), "Sim.partialTrace(): invalid qubit index" );

        // Compute an array of complementary indices, containing all the indices in [0,n-1] that are not already in _qubitArray
        let _arrayOfOtherQubits = [];
        let array_index = 0;
        for ( let index = 0; index < n; index ++ ) {
            if ( array_index < _qubitArray.length ) {
                if ( index < _qubitArray[ array_index ] ) {
                    _arrayOfOtherQubits.push( index );
                }
                else if ( index === _qubitArray[ array_index ] ) {
                    array_index ++;
                }
            }
            else {
                _arrayOfOtherQubits.push( index );
            }
        }
        Util.assert( _qubitArray.length + _arrayOfOtherQubits.length === n, "Sim.partialTrace(): error computing complementary set of indices" );


        let qubitsToTraceOut = [];
        let qubitsToKeep = []; // the marginal qubits
        if ( arraySpecifiesQubitsToTraceOut ) {
            qubitsToTraceOut = _qubitArray;
            qubitsToKeep = _arrayOfOtherQubits;
        }
        else {
            qubitsToKeep = _qubitArray;
            qubitsToTraceOut = _arrayOfOtherQubits;
        }


        let numQubitsToTraceOut = qubitsToTraceOut.length;
        let numQubitsToKeep = qubitsToKeep.length;
        Util.assert( numQubitsToTraceOut + numQubitsToKeep === n, "Sim.partialTrace(): unexpected condition" ); // sanity check
        // This is 2^numQubitsToTraceOut == the dimension of the space being traced out
        let tracedDimension = 1 << numQubitsToTraceOut;
        // This is 2^numQubitsToKeep == the dimension of the resulting matrix
        let resultDimension = 1 << numQubitsToKeep;
        let outputMatrix = new CMatrix(resultDimension,resultDimension);

        let lookupTable = [];
        if ( useLookupTable ) {
            for ( let tmp = 0; tmp < resultDimension; tmp ++ ) {
                lookupTable[ tmp ] = Sim.rearrangeBits( tmp, qubitsToKeep );
            }
        }

        for (
            let shared_bits = 0; // bits common to input_row and input_col
            shared_bits < tracedDimension;
            shared_bits ++
        ) {
            let shared_bits_rearranged = Sim.rearrangeBits( shared_bits, qubitsToTraceOut );
            for ( let output_row = 0; output_row < resultDimension; output_row ++ ) {
                let input_row = shared_bits_rearranged | ( useLookupTable ? lookupTable[ output_row ] : Sim.rearrangeBits( output_row, qubitsToKeep ) );
                for ( let output_col = 0; output_col <= (isInputMatrixHermitian?output_row:resultDimension-1) ; output_col ++ ) {
                    let input_col = shared_bits_rearranged | ( useLookupTable ? lookupTable[ output_col ] : Sim.rearrangeBits( output_col, qubitsToKeep ) );
                    // The next line, in pseudocode, could be written more simply as
                    //    outputMatrix[output_row,output_col] += inputMatrix[input_row,input_col]
                    outputMatrix.set( output_row, output_col, Complex.sum(
                        outputMatrix.get(output_row,output_col),
                        (inputStateVector!==null)
                            ? Complex.mult( inputStateVector.get(input_row,0), inputStateVector.get(input_col,0).conjugate() )
                            : inputMatrix.get(input_row,input_col)
                    ));
                }
            }
        }
        if ( isInputMatrixHermitian ) {
            // We've only computed the lower triangular half (including the diagonal)
            // of the output matrix.
            // Now we copy and conjugate (not including the diagonal) to the upper triangular half.
            for ( let output_row = 1; output_row < resultDimension; output_row ++ ) {
                for ( let output_col = 0; output_col < output_row; output_col ++ ) {
                    outputMatrix.set( output_col, output_row, outputMatrix.get(output_row,output_col).conjugate() );
                }
            }
        }
        return outputMatrix;
    }

    // returns an array of n 2x2 matrices, where element i in the array is the 2x2 reduced density matrix for qubit i, 0 <= i < n
    static computeAll2x2ReducedDensityMatrices(
        n, // number of qubits
        stateVector // (2^n)x1 column vector
    ) {
        Util.assert( stateVector._rows===(2**n) && stateVector._cols===1, "Sim.computeAll2x2ReducedDensityMatrices(): state vector has invalid size" );
        let returnValue = [];
        let reducedDensityMatrix = null;
        for ( let i = 0; i < n; i ++ ) {
            reducedDensityMatrix = Sim.partialTrace(
                n, // number of qubits
                null, // full density matrix
                true, // is hermitian ?
                stateVector,
                [ i ],
                false
            );
            Util.assert( reducedDensityMatrix._rows===2 && reducedDensityMatrix._cols===2, "Sim.computeAll2x2ReducedDensityMatrices(): unexpected size of matrix" );
            returnValue.push( reducedDensityMatrix );
        }
        return returnValue;
    }
    static indexInArrayOfAllPairs(i,j) {
        if ( i===j || i<0 || j<0 )
            return -1;
        if ( i > j ) {
            // swap, to ensure i < j
            let tmp = j;
            j = i;
            i = tmp;
        }
        return j*(j-1)/2+i;
    }
    // Returns an array of (n(n-1)/2) 4x4 matrices,
    // where the 4x4 reduced density matrix for qubits i,j (0 <= i < j < n)
    // has index given by indexInArrayOfAllPairs(i,j)
    static computeAll4x4ReducedDensityMatrices(
        n, // number of qubits
        stateVector // (2^n)x1 column vector
    ) {
        Util.assert( stateVector._rows===(2**n) && stateVector._cols===1, "Sim.computeAll4x4ReducedDensityMatrices(): state vector has invalid size" );
        Util.assert( Sim.indexInArrayOfAllPairs(0,1)===0 && Sim.indexInArrayOfAllPairs(1,0)===0, "Sim.computeAll4x4ReducedDensityMatrices(): unexpected condition 1" );
        let returnValue = [];
        let reducedDensityMatrix = null;

        for ( let j = 1; j < n; j ++ ) {
            for ( let i = 0; i < j; i ++ ) {
                Util.assert( Sim.indexInArrayOfAllPairs(i,j)===returnValue.length, "Sim.computeAll4x4ReducedDensityMatrices(): unexpected condition 2" );
                reducedDensityMatrix = Sim.partialTrace(
                    n, // number of qubits
                    null, // full density matrix
                    true, // is hermitian ?
                    stateVector,
                    [ i, j ],
                    false
                );
                Util.assert( reducedDensityMatrix._rows===4 && reducedDensityMatrix._cols===4, "Sim.computeAll4x4ReducedDensityMatrices(): unexpected size of matrix" );
                returnValue.push( reducedDensityMatrix );
            }
        }
        Util.assert( Sim.indexInArrayOfAllPairs(n-2,n-1)===returnValue.length-1 && Sim.indexInArrayOfAllPairs(n-1,n-2)===returnValue.length-1, "Sim.computeAll4x4ReducedDensityMatrices(): unexpected condition 3" );
        return returnValue;
    }

    // Returns a matrix of size (2**n)x(2**n)
    // Requires time O(4^n) and memory O(4^n)
    static computeDensityMatrix(
        n, // number of qubits in the circuit
        stateVector // a matrix of size (2**n)x1, i.e. a column vector
    ) {
        Util.assert( stateVector._rows===(2**n) && stateVector._cols===1, "Sim.computeDensityMatrix(): state vector has invalid size" );
        return CMatrix.mult( stateVector, stateVector.conjugateTranspose() );
    }

    // returns an object containing statistics
    static computeStatsFor2x2DensityMatrix(
        dm // a 2x2 density matrix for a single qubit
    ) {
        Util.assert( dm._rows===2 && dm._cols===2, "Sim.computeStatsFor2x2DensityMatrix(): matrix is not 2x2");
        /*
        Assume the local state of the qubit is pure and therefore can be expressed as
           |psi> = alpha |0> + e^(i phase) (1-alpha^2)^0.5 |1>
                 = cos(theta/2) |0> + e^(i phase) sin(theta/2) |1>
        where alpha is nonnegative real, theta is in [0,pi], phase is in [0,2pi]
        Note that we're assuming that we could apply a global phase to make the complex amplitude in front of |0> nonnegative real.
        Then, in the Bloch sphere space, we will have
           x = (sin theta)(cos phase)
           y = (sin theta)(sin phase)
           z = (cos theta)
        and the 2x2 density matrix for the qubit will be

           |psi><psi| = [ cos(theta/2)             ] * [ cos(theta/2)   e^(-i phase) sin(theta/2) ]
                        [ e^(i phase) sin(theta/2) ]

                      = [ cos^2(theta/2)                          e^(-i phase) sin(theta/2) cos(theta/2) ]
                        [ e^(i phase) sin(theta/2) cos(theta/2)   sin^2(theta/2)                         ]

                      = [ (1+cos theta)/2                                     (cos phase - i sin phase)((1-cos^2(theta))^0.5)/2 ]
                        [ (cos phase + i sin phase)((1-cos^2(theta))^0.5)/2   (1-cos theta)/2                                   ]

                      = [ (1+z)/2                                  (cos phase - i sin phase)(sin theta)/2 ]
                        [ (cos phase + i sin phase)(sin theta)/2   (1-z)/2                                ]

                      = [ (1+z)/2       (x - i y)/2 ]
                        [ (x + i y)/2   (1-z)/2     ]

        which hints at how to recover x, y, z from the entries of the 2x2 matrix.
        It turns out that, even if the qubit is in a mixed state,
        its 2x2 reduced density matrix has the same form as the last expression above.
        See Nielsen and Chuang, page 105, exercise 2.72, about "Bloch sphere for mixed states".
        The general form for a 2x2 density matrix, even for a mixed state, is (1/2)(I_2 + x X + y Y + z Y),
        where I_2 is the 2x2 identity matrix, (x,y,z) are the coordinates of the Bloch vector, (X,Y,Z) are the Pauli matrices,
        and the diagonal elements of the density matrix are real-valued and sum to 1, and the off-diagonal elements are conjugate.
        Another way to compute the coordinates is to use these identities:
            x = <psi|X|psi> = Tr( rho X )
            y = <psi|Y|psi> = Tr( rho Y )
            z = <psi|Z|psi> = Tr( rho Z )
        */

        let [ar, ai, br, bi, cr, ci, dr, di] = dm._m;
        Util.assert(
            // Diagonal elements should be real-valued probabilities that sum to 1
            Util.approximatelyEqual(ai,0) && Util.approximatelyEqual(di,0) && Util.approximatelyEqual(ar+dr,1)
            && ar >= 0 && dr >= 0
            // Off-diagonal elements should be conjugates
            && Util.approximatelyEqual(br,cr) && Util.approximatelyEqual(bi,-ci),
            "Sim.computeStatsFor2x2DensityMatrix(): unexpected condition"
        );
        let x = br + cr;
        let y = ci - bi;
        let z = ar - dr;
        let radius = Math.sqrt(x*x + y*y + z*z);
        let phase = Util.angleIn2D(x,y);
        let theta = Util.angleIn2D(z,Math.sqrt(x*x+y*y));
        let probabilityOfOne = dr; // = (1-z)/2;
        let purity = CMatrix.mult( dm, dm ).trace();
        let cosine_theta_over_2 = Math.cos(theta/2);
        let sine_theta_over_2 = Math.sin(theta/2);
        let psi_amplitude_0 = new Complex( cosine_theta_over_2, 0 );
        let psi_amplitude_1 = new Complex( Math.cos(phase)*sine_theta_over_2, Math.sin(phase)*sine_theta_over_2 );

        let vonNeumannEntropy = 0; // will be in the range [0,1]
        let lambda = Sim.eigendecomposition( dm );
        if ( lambda === null ) {
            // the eigendecomposition failed
            const ERROR_VALUE = -0.1;
            vonNeumannEntropy = ERROR_VALUE;
        }
        else {
            for ( let i = 0; i < lambda.length; ++i ) {
                if ( lambda[i] > 0 )
                    vonNeumannEntropy -= lambda[i] * Math.log2( lambda[i] );
            }
        }

        return {
            x:x, y:y, z:z, radius:radius, phase:phase, theta:theta, // these specify the Bloch vector
            probabilityOfOne:probabilityOfOne,
            purity:purity,
            linearEntropy:(1-purity._r),
            vonNeumannEntropy:vonNeumannEntropy,
            psi_amplitude_0:psi_amplitude_0, psi_amplitude_1:psi_amplitude_1
        };
    }
    // returns an array of objects, one for each qubit
    static analyzeEachQubit(
        n, // number of qubits in the circuit
        arrayOfAll2x2ReducedDensityMatrices
    ) {
        Util.assert( arrayOfAll2x2ReducedDensityMatrices.length===n, "Sim.analyzeEachQubit(): array of matrices has invalid size" );

        let results = [];
        for ( let i = 0; i < n; ++i ) {
            let RDM = arrayOfAll2x2ReducedDensityMatrices[ i ];
            let S = Sim.computeStatsFor2x2DensityMatrix( RDM );
            S.reducedDensityMatrix = RDM;
            results.push( S );
        }
        return results;
    }
    static printAnalysisOfEachQubit(
        n, // number of qubits in the circuit
        stateVector // a matrix of size (2**n)x1, i.e. a column vector
    ) {
        if ( n > 7 ) return; // too many qubits
        Util.assert( stateVector._rows===(2**n) && stateVector._cols===1, "Sim.printAnalysisOfEachQubit(): state vector has invalid size" );
        let DM = Sim.computeDensityMatrix( n, stateVector );
        console.log("Density matrix is\n" + DM.toString({decimalPrecision:2}) + "\nwith trace " + DM.trace() + " and purity " + (CMatrix.mult(DM,DM)).trace() );
        let arrayOfAll2x2ReducedDensityMatrices = Sim.computeAll2x2ReducedDensityMatrices( n, stateVector );
        let stats = Sim.analyzeEachQubit( n, arrayOfAll2x2ReducedDensityMatrices );
        for ( let i = 0; i < n; ++i ) {
            let RDM = stats[i].reducedDensityMatrix;
            console.log(StringUtil.concatMultiline(`Reduced density matrix for qubit ${i} is `, RDM.toString(), " with trace " + RDM.trace() + " and purity " + (CMatrix.mult(RDM,RDM)).trace() ));
        }
        for ( let i = 0; i < n; ++i ) {
            let S = stats[i];
            let phaseInDegrees = S.phase / Math.PI * 180;
            let thetaInDegrees = S.theta / Math.PI * 180;
            console.log(
                `q${i}: (`
                    +"x="+StringUtil.numToString(S.x)+",y="+StringUtil.numToString(S.y)+",z="+StringUtil.numToString(S.z)
                +") ("
                    +"r="+StringUtil.numToString(S.radius)+","
                    +"phase="+StringUtil.numToString(S.phase)+"rad="+StringUtil.numToString(phaseInDegrees)+"deg,"
                    +"theta="+StringUtil.numToString(S.theta)+"rad="+StringUtil.numToString(thetaInDegrees)+"deg"
                +"), probability(|1>)=" + StringUtil.numToString(S.probabilityOfOne)
                +", purity=" + S.purity.toString()
                +", (" + S.psi_amplitude_0.toString() + ")|0>+(" + S.psi_amplitude_1.toString() + ")|1>"
            );
        }
    }

    // Returns a matrix of size (n)x(n), whose upper triangular half contains correlation values for pairs of qubits.
    // Each cell (row=i,column=j) of the matrix contains a real number in [-1,1] describing the correlation between qubits i,j
    // (where i>j).
    // The values -1, 0, +1 correspond to perfectly inverse correlation (i.e., when measured, qubits i,j always have opposite values),
    // uncorrelated, and perfectly positive correlation (i.e., when measured, the two qubits are always equal), respectively.
    // The diagonal and lower triangular half of the returned matrix contain zeros.
    // 
    // 
    // 
    // How to compute the correlation between two qubits:
    // 
    // Consider two qubits X and Y, each of which is measured to have
    // a value of either L (for Low) or H (for High).
    // (Later, we will consider (L,H)=(-1,+1) or (L,H)=(0,1).)
    // Define the four probabilities
    //     a = P((X,Y)=(L,L)) = P(X=L and Y=L)
    //     b = P((X,Y)=(L,H))
    //     c = P((X,Y)=(H,L))
    //     d = P((X,Y)=(H,H))
    // 
    // where a+b+c+d=1.
    // https://en.wikipedia.org/wiki/Correlation
    // explains that
    // 
    //     correlation(X,Y)
    //       = covariance(X,Y) / (sigma_X sigma_Y)
    //       = ( E(XY) - E(X)E(Y) ) / (sigma_X sigma_Y)
    // 
    // where sigma_X = sqrt(E(X^2) - E(X)^2)
    // and similarly for sigma_Y.
    // Thus
    //     covariance(X,Y)
    //       = E(XY) - E(X)E(Y)
    //       = aLL + bLH + cHL + dHH - ((a+b)L+(c+d)H) ((a+c)L+(b+d)H)
    //       = aLL+bLH+cHL+dHH - (aL+bL+cH+dH)(aL+cL+bH+dH)
    //       = aLL+bLH+cHL+dHH - (aaLL+abLL+acLL+bcLL + abLH+acLH+2adLH+bbLH+bdLH+ccLH+cdLH + bcHH+bdHH+cdHH+ddHH)
    // 
    // If we set (L,H)=(-1,+1), then sigma_X = sigma_Y = 1,
    // and
    //     covariance(X,Y)
    //       = a-b-c+d - (aa+ab+ac+bc - ab-ac-2ad-bb-bd-cc-cd + bc+bd+cd+dd)
    //       = a-b-c+d - (aa+2bc -2ad-bb-cc +dd)
    //       = a+d-b-c - (aa+dd+2bc-2ad-bb-cc)
    //     correlation(X,Y)
    //       = a+d-b-c - (aa+dd+2bc-2ad-bb-cc)
    // Recall that a=1-b-c-d. Substituting, we find
    //     correlation(X,Y)
    //       = (1-b-c-d)+d-b-c - ((1-b-c-d)^2+dd+2bc-2(1-b-c-d)d-bb-cc)
    //       = 1-2b-2c - ((1-b-c-d)^2+dd+2bc -2(d-bd-cd-dd) -bb-cc)
    //       = 1-2b-2c+2d +bb-2bc-2bd+cc-2cd-3dd - ((1-b-c-d)^2) 
    //       = 1-2b-2c+2d +bb-2bc-2bd+cc-2cd-3dd - (1-2b-2c-2d+bb+2bc+2bd+cc+2cd+dd)
    //       = 4d -4bc-4bd-4cd-4dd
    //       = 4(d-bd-cd-dd -bc)
    //       = 4((1-b-c-d)d -bc)
    //       = 4(ad-bc)    [1]
    // 
    // As a sanity check, set (L,H)=(0,1),
    // then sigma_X = sigma_Y = sqrt(0.5-0.5^2)=0.5,
    // and
    //     covariance(X,Y) = d - (bc+bd+cd+dd)
    //     correlation(X,Y)
    //       = (d - (bc+bd+cd+dd))/(0.5 0.5)
    //       = 4 (d - (bc+bd+cd+dd))
    //       = 4 (d - dd - bc - bd - cd)
    //       = 4( d - bc - (b+c+d)d )
    //       = 4( d - bc - (1-a)d )
    //       = 4( ad - bc )   [2]
    // We see that equation [2] is equivalent to [1].
    // 
    // As another sanity check, consider
    // the symmetrical situation
    // a=d and b=c, and define p=a=d.
    // Then b=c=0.5-p, and [2] yields
    //     correlation(X,Y)
    //       = 4( p^2 - (0.5-p)^2 )
    //       = 4( p^2 - 0.25+p-p^2 )
    //       = 4( -0.25+p )
    //       = 4p - 1
    // which yields -1,0,1, for p=0,0.25,0.5, respectively,
    // as expected.
    // 
    // As another sanity check, consider
    // the case b=c=0 (hence a+d=1).
    // Then [2] yields
    //     correlation(X,Y)
    //       = 4ad
    // which reaches a maximum of 1 when a=d=0.5.
    // Alternatively, consider the case a=d=0
    // (hence b+c=1), then [2] yields
    //     correlation(X,Y) = -4bc
    // which has a minimum of -1 when b=c=0.5
    // 
    // As another sanity check, consider the case
    // where X and Y are independent, with
    // probabilities
    //     p = P(X=H)
    //     q = P(Y=H)
    // Then P(X=L)=(1-p), P(Y=L)=(1-q),
    // a=(1-p)(1-q), b=(1-p)q, c=p(1-q), d=pq,
    // and we find
    //     correlation(X,Y)
    //       = 4( (1-p)(1-q)pq - (1-p)qp(1-q) )
    //       = 0
    // as expected.
    // 
    static computePairwiseQubitCorrelations(
        n, // number of qubits in the circuit
        stateVector // a matrix of size (2**n)x1, i.e. a column vector
    ) {
        Util.assert( stateVector._rows===(2**n) && stateVector._cols===1, "Sim.computePairwiseQubitCorrelations(): state vector has invalid size" );

        // compute the probability of each base state
        let baseStateProbabilities = new CMatrix( stateVector._rows, 1 );
        for ( let i=0; i < stateVector._rows; ++i ) baseStateProbabilities.set( i, 0, stateVector.get(i,0).mag()**2 );

        let result = new CMatrix(n,n);
        for ( let i=0; i <= n-2; ++i ) {
            for ( let j=i+1; j <= n-1; ++j ) {

                // p[bit_i][bit_j] is the probability of measuring (bit_i) at the ith bit and (bit_j) at the jth bit,
                // where bit_i, bit_j are each either 0 or 1
                let p = [ [ 0, 0 ], [ 0, 0 ] ];

                for ( let k=0; k < baseStateProbabilities._rows; ++k ) {
                    let bit_i = (k>>i) & 1;
                    let bit_j = (k>>j) & 1;
                    p[ bit_i ][ bit_j ] += baseStateProbabilities.get(k,0)._r;
                }
                let correlation = 4*( p[0][0]*p[1][1] - p[0][1]*p[1][0] );
                result.set( i, j, correlation );
                //console.log(`${i},${j}: `+StringUtil.numToString(p[0][0])+"+"+StringUtil.numToString(p[0][1])+"+"+StringUtil.numToString(p[1][0])+"+"+StringUtil.numToString(p[1][1])+"="+StringUtil.numToString(p[0][0]+p[0][1]+p[1][0]+p[1][1])+", diff="+StringUtil.numToString(correlation));
            }
        }
        //console.log("Pairwise correlations appear in upper triangular half:\n" + result.toString());
        return result;
    }

    // Attempts to perform an eigendecomposition of the given complex square matrix,
    // assuming that the resulting eigenvalues should all be real nonnegative, and returns these in an array.
    // If the eigendecomposition fails, this returns null.
    static eigendecomposition( matrix ) {
        Util.assert( matrix._rows===matrix._cols && matrix._rows > 1, "Sim.eigendecomposition(): matrix has invalid size" );
        let N = matrix._rows;

        // To use the mathjs library to find eigenvalues, we must convert the matrix to a format that mathjs understands
        let m2 = math.zeros(N,N);
        for ( let row = 0; row < N; ++row ) {
            for ( let col = 0; col < N; ++col ) {
                let entry = matrix.get(row,col);
                m2.set( [row,col], math.complex(entry._r,entry._i) );
            }
        }
        //console.log(`matrix ${i},${j} is \n` + m.toString() );
        //console.log("In mathjs format, the matrix is " + m2.toString());
        let E;
        try {
            // I tried increasing precision to as much as 0.01, but this still sometimes fails.
            E = math.eigs(m2,{eigenvectors: false, precision: 0.0001}).values._data;
                // .sort((a,b)=>b-a);
            //console.log(`Eigenvalues are ` + E.toString());
        } catch (error) {
            console.log("Sim.eigendecomposition() failed: ", error);
            console.log(`    Matrix was \n` + matrix.toString() );
            console.log("    In mathjs format, the matrix was " + m2.toString());
            console.log("    Error.values:" + error.values);
            return null;
        }
        let lambda = [];
        for ( let i = 0; i < E.length; i++) {
            lambda[i] = math.re(E[i]); // only keep the real part
            Util.assert( lambda[i] > -0.01, "Sim.eigendecomposition(): unexpected negative eigenvalue" );
            if ( lambda[i] < 0 ) lambda[i] = 0; // convert slightly negative real numbers to zero
        }
        return lambda;
    }

    // Returns a matrix of size (n)x(n), whose upper triangular half contains concurrence values for pairs of qubits.
    // Each cell (row=i,column=j) of the matrix contains a real number in [0,1] describing the concurrence between qubits i,j
    // (where i>j).
    //
    // The computation here is based on
    //    equations 1 and 2 in
    //    https://scholar.google.com/scholar?q=coffmann+kundu+wootters+Distributed+entanglement
    // which also matches the implementation in
    //    https://docs.quantum.ibm.com/api/qiskit/0.24/qiskit.quantum_info.concurrence
    //    https://github.com/Qiskit/qiskit/blob/stable/0.16/qiskit/quantum_info/states/measures.py
    //       (lines 208-213 at the end of the concurrence() routine)
    // More discussion is at
    //    https://physics.stackexchange.com/questions/46443/what-is-the-motivation-for-the-definition-of-concurrence-in-quantum-information
    static computePairwiseQubitConcurrences(
        n, // number of qubits in the circuit
        arrayOfAll4x4ReducedDensityMatrices
    ) {
        Util.assert( arrayOfAll4x4ReducedDensityMatrices.length===(n*(n-1)/2), "Sim.computePairwiseQubitConcurrences(): array of matrices has invalid size" );

        let result = new CMatrix(n,n);
        let Y_tensor_Y = CMatrix.tensor(Sim.Y,Sim.Y);
        for ( let i=0; i <= n-2; ++i ) {
            for ( let j=i+1; j <= n-1; ++j ) {

                let rdm = arrayOfAll4x4ReducedDensityMatrices[ Sim.indexInArrayOfAllPairs(i,j) ];
                //console.log(`reduced density matrix ${i},${j} is \n` + rdm.toString() );
                let spin_flipped_rdm = CMatrix.naryMult([ Y_tensor_Y, rdm.conjugate(), Y_tensor_Y ]);
                let m = CMatrix.mult( rdm, spin_flipped_rdm );

                let lambda = Sim.eigendecomposition( m );
                if ( lambda === null ) {
                    // the eigendecomposition failed
                    const ERROR_VALUE = -0.1;
                    result.set( i, j, ERROR_VALUE );
                    continue;
                }

                // take square roots
                for ( let i = 0; i < lambda.length; i++) {
                    lambda[i] = Math.sqrt( lambda[i] );
                }

                let diffOfLambdas = lambda[3] - lambda[2] - lambda[1] - lambda[0];
                //console.log("    diff of lambdas:" + diffOfLambdas );

                let concurrence = (diffOfLambdas<0) ? 0 : diffOfLambdas;
                result.set( i, j, concurrence );
            }
        }
        //console.log("Pairwise concurrences appear in upper triangular half:\n" + result.toString());
        return result;
    }

    // Returns a matrix of size (n)x(n), whose upper triangular half contains purity values for pairs of qubits.
    // Each cell (row=i,column=j) of the matrix contains a real number in [0.25,1] describing the purity for qubits i,j
    // (where i>j).
    // (In general, when considering n qubits, the purity computed from their 2^n x 2^n reduced density matrix
    // is in the range [1/2^n,1])
    //
    static computePairwiseQubitPurity(
        n, // number of qubits in the circuit
        arrayOfAll4x4ReducedDensityMatrices
    ) {
        Util.assert( arrayOfAll4x4ReducedDensityMatrices.length===(n*(n-1)/2), "Sim.computePairwiseQubitPurity(): array of matrices has invalid size" );

        let result = new CMatrix(n,n);
        for ( let i=0; i <= n-2; ++i ) {
            for ( let j=i+1; j <= n-1; ++j ) {

                let rdm = arrayOfAll4x4ReducedDensityMatrices[ Sim.indexInArrayOfAllPairs(i,j) ];
                //console.log(`reduced density matrix ${i},${j} is \n` + rdm.toString() );
                result.set( i, j, (CMatrix.mult(rdm,rdm)).trace() );
            }
        }
        //console.log("Pairwise purities appear in upper triangular half:\n" + result.toString());
        return result;
    }

    // Returns a matrix of size (n)x(n), whose upper triangular half contains entropy values for pairs of qubits.
    // Each cell (row=i,column=j) of the matrix contains a real number in [0,2] describing the entropy for qubits i,j
    // (where i>j).
    // (In general, when considering n qubits, the von Neumann entropy computed from their 2^n x 2^n reduced density matrix
    // is in the range [0,n])
    //
    // See
    //     https://quantumcomputing.stackexchange.com/questions/28708/how-is-the-von-neumann-entropy-of-a-state-defined-from-its-eigendecomposition
    //
    static computePairwiseQubitVonNeumannEntropy(
        n, // number of qubits in the circuit
        arrayOfAll4x4ReducedDensityMatrices
    ) {
        Util.assert( arrayOfAll4x4ReducedDensityMatrices.length===(n*(n-1)/2), "Sim.computePairwiseQubitVonNeumannEntropy(): array of matrices has invalid size" );

        let result = new CMatrix(n,n);
        for ( let i=0; i <= n-2; ++i ) {
            for ( let j=i+1; j <= n-1; ++j ) {

                let rdm = arrayOfAll4x4ReducedDensityMatrices[ Sim.indexInArrayOfAllPairs(i,j) ];
                //console.log(`reduced density matrix ${i},${j} is \n` + rdm.toString() );

                let lambda = Sim.eigendecomposition( rdm );
                if ( lambda === null ) {
                    // the eigendecomposition failed
                    const ERROR_VALUE = -0.1;
                    result.set( i, j, ERROR_VALUE );
                    continue;
                }

                let entropy = 0;
                for ( let i = 0; i < lambda.length; ++i ) {
                    if ( lambda[i] > 0 )
                        entropy -= lambda[i] * Math.log2( lambda[i] );
                }
                //console.log(`  entropy is ${entropy}`);
                result.set( i, j, entropy );
            }
        }
        //console.log("Pairwise Von Neumann entropies appear in upper triangular half:\n" + result.toString());
        return result;
    }

    // Computes the Second Stabilizer Rényi Entropy (SSRE) magic for a given density matrix.
    // This measure quantifies magic (non-stabilizerness)
    // by measuring how spread out the state's density matrix
    // is when expanded in the basis of Pauli operators.
    // For N qubits, SSRE = -log_2(1/2^N ∑_P (Tr(rho P))^4) where P iterates over all Pauli-string matrices of length N.
    //
    // Returns a value between 0 and log_2(2^N + 1) - log_2(2) = log_2(2^N + 1) - 1
    //
    // In tests on my 2022 laptop, it returns in less than a second for N <= 6, if the cache is used.
    //
    // The runtime of the algorithm is O(16^N), because there are 4^N pauli strings of length N to consider,
    //     and for each pauli string, we must compute the trace of a matrix product
    //     where the matrices have size (2^N)x(2^N).
    //     Normally, the matrix product itself would take time O(2^(3N)) (assuming naive matrix multiplication),
    //     but since we only need the trace of the matrix product,
    //     we can merely find the diagonal elements of the matrix product,
    //     so finding the trace of the matrix product takes O(2^(2N)) time.
    //     Multiplying 4^N pauli strings by O(2^(2N)) yields a total time of O(2^(4N)) = O(16^N)
    //
    // Using the cache can result in a roughly 2x or 3x performance increase.
    // Using the cache for a given N requires storing 16^(N+1) bytes, or 1 megabyte for N=4, 256 megabytes for N=6.
    //     This is because there are 4^N pauli strings, each one resulting in a pauli matrix that is (2^N)x(2^N),
    //     each element requiring 8 bytes for the real and 8 bytes for the imaginary component,
    //     so (4^N)x(2^N)x(2^N)x16 = 16^(N+1) storage for the entire cache of pauli matrices of length N.
    // So the cache should be used whenever N <= 5 and maybe even for N=6.
    //
    // Using the stack improves performance by about 10-15%, based on my tests.
    //
    // If the caller asks for both the cache and the stack to be used,
    // the stack will only increase performance during the first call when the cache is populated;
    // on subsequent calls, the cache is used and the stack makes no difference.
    //
    // The computation is based on
    //     Leone, Oliviero, Hamma (2022) "Stabilizer rényi entropy"  https://scholar.google.com/scholar?q=leone+Stabilizer+Renyi+Entropy
    //         equation 3
    //         and the paragraph below equation 3
    //         but NOT on equation 7
    //     and
    //     Niroula et al. (2024) "Phase transition in magic with random quantum circuits"  https://scholar.google.com/scholar?q=niroula+Phase+transition+in+magic+with+random+quantum+circuits
    //         section 2, second paragraph
    // Note that Leone et al. (2022) provide an example with an exact expression on page 2, 2nd paragraph after equation 5:
    //     the SSRE magic of |H>^(⊗N) is (1-alpha)^(-1) (N log(2^(1-alpha)+1)-N)
    //     Setting alpha=2, the expression reduces to N(2-log2(3))
    //     which leads to this way to test the routine:
    //        for ( let n = 1; n <= 7; n++ ) {
    //            let stateVector = CMatrix.tensorPower( Sim.ket_H_magic_state, n );
    //            let rho = Sim.computeDensityMatrix( n, stateVector );
    //            let magic = Sim.computeSSREMagic( rho );
    //            console.log(`n=${n}; computed: ${magic}; predicted: ${n*(2-Math.log2(3))}`);
    //        }
    //
    static computeSSREMagic( densityMatrix, useCache=false, useStack=true ) {
        // Verify the density matrix is square with dimensions that are powers of 2
        Util.assert(densityMatrix._rows === densityMatrix._cols, "Sim.computeSSREMagic(): density matrix must be square");
        const dim = densityMatrix._rows;
        const N = Math.log2(dim);
        Util.assert(Math.pow(2, N) === dim, "Sim.computeSSREMagic(): density matrix dimension must be a power of 2");

        const singleQubitPauliMatrices = [ Sim.I, Sim.X, Sim.Y, Sim.Z ];
        const NUM_SINGLE_QUBIT_PAULI_MATRICES = singleQubitPauliMatrices.length;

        let sumOfTraces = 0;

        // Generate all possible Pauli strings of length N
        const numPauliStrings = Math.pow( NUM_SINGLE_QUBIT_PAULI_MATRICES, N );
        //console.log(`numPauliStrings is ${numPauliStrings}`);

        // Use a stack so that we can usually reuse most of the tensor product from the previous iteration
        let previous_pauliString = [ ];
        let stackOfPauliProducts = [ ];

        let saveToCache = false;
        let retrieveFromCache = false;
        if ( useCache ) {
            if ( Sim.pauliMatrixCache === undefined )
                Sim.pauliMatrixCache = [ [] ]; // a 2D array, where the first index is N, and the second index is the pauli string index

            if ( Sim.pauliMatrixCache.length > N && Sim.pauliMatrixCache[ N ] !== undefined )
                retrieveFromCache = true;
            else {
                saveToCache = true;
                Sim.pauliMatrixCache[ N ] = [];
            }
        }

        for ( let pauliStringIndex = 0; pauliStringIndex < numPauliStrings; pauliStringIndex ++ ) {
            let pauliString = []; // an array of N indices, each indexing into singleQubitPauliMatrices
            let num = pauliStringIndex;
            // convert num to base 4 to get Pauli string
            for ( let j = 0; j < N; j++ ) {
                pauliString.unshift( num % NUM_SINGLE_QUBIT_PAULI_MATRICES );
                num = Math.floor( num / NUM_SINGLE_QUBIT_PAULI_MATRICES );
            }

            let P;

            if ( retrieveFromCache ) {
                P = Sim.pauliMatrixCache[ N ][ pauliStringIndex ];
            }
            else {
                if ( useStack ) {
                    // The first element that differs between previous_pauliString and pauliString
                    // tells us how much to pop off from the stack
                    for ( let j = 0; j < previous_pauliString.length && j < pauliString.length; ++j ) {
                        if ( previous_pauliString[j] !== pauliString[j] ) {
                            stackOfPauliProducts.splice( j ); // remove the jth, and all subsequent, elements
                            //console.log(`spliced from ${j}`);
                            break;
                        }
                    }

                    // Construct and push the appropriate matrices onto the stack.
                    // Do this by iterating over values of j, up to N,
                    // and for each value of j,
                    // construct the j-qubit Pauli matrix, specified by pauliString[0..j].
                    for ( let j = stackOfPauliProducts.length; j < N; ++j ) {
                        let M;
                        if ( j === 0 )
                            M = singleQubitPauliMatrices[ pauliString[0] ];
                        else
                            M = CMatrix.tensor(stackOfPauliProducts.at(-1), singleQubitPauliMatrices[ pauliString[j] ]);
                        stackOfPauliProducts.push( M );
                    }

                    P = stackOfPauliProducts.at( -1 ); // last matrix on the stack

                    previous_pauliString = [...pauliString]; // deep copy of array elements
                }
                else {
                    // Construct the N-qubit Pauli operator from scratch for each iteration.
                    // This is simpler, but slower, than using the stack.
                    P = singleQubitPauliMatrices[ pauliString[0] ];
                    for ( let j = 1; j < N; ++j ) {
                        P = CMatrix.tensor(P, singleQubitPauliMatrices[ pauliString[j] ]);
                    }
                }
            }

            let trace = CMatrix.traceOfMatrixProduct( densityMatrix, P ).mag();
            let traceSquared = trace * trace;
            let traceToThe4th = traceSquared * traceSquared;
            sumOfTraces += traceToThe4th;

            if ( saveToCache ) {
                Sim.pauliMatrixCache[ N ][ pauliStringIndex ] = P.copy();
            }
        }
        return - Math.log2( sumOfTraces / ( 2 ** N ) );
    }

    // If the client wants to, they could change the value of usingTextbookConvention
    // and call this again, to initialize things using a different convention.
    static init() {
        // When discussing quantum circuits,
        // the term 'bra', written <*|, denotes a row vector,
        // and the term 'ket', written |*>, denotes a column vector.
        // So an expression written as <a|b> means the dot product of a and b,
        // and the expression |a><b| results in a matrix as tall as a and as wide as b.
        // More precisely, <psi| is the conjugate transpose of |psi>.
        // If |psi> is made of complex amplitudes,
        // <psi|psi> is the sum of associated probabilities,
        // and the matrix |psi><psi| contains the probabilities along its diagonal.


        // Here we define the six canonical points on the Bloch sphere: the stabilizer states.
        //
        // |0>
        Sim.braZero = CMatrix.createRowVector([1,0]);
        Sim.ketZero = CMatrix.createColVector([1,0]);
        // |1>
        Sim.braOne = CMatrix.createRowVector([0,1]);
        Sim.ketOne = CMatrix.createColVector([0,1]);
        // |+>
        Sim.ketPlus = CMatrix.createColVector([Math.SQRT1_2,Math.SQRT1_2]);
        Sim.braPlus = Sim.ketPlus.conjugateTranspose();
        // |->
        Sim.ketMinus = CMatrix.createColVector([Math.SQRT1_2,-Math.SQRT1_2]);
        Sim.braMinus = Sim.ketMinus.conjugateTranspose();
        // |+i>
        Sim.ketPlusI = CMatrix.createColVector([Math.SQRT1_2,new Complex(0,Math.SQRT1_2)]);
        Sim.braPlusI = Sim.ketPlusI.conjugateTranspose();
        // |-i>
        Sim.ketMinusI = CMatrix.createColVector([Math.SQRT1_2,new Complex(0,-Math.SQRT1_2)]);
        Sim.braMinusI = Sim.ketMinusI.conjugateTranspose();

        // Here we define some commonly used logic gates.
        //
        Sim.ZERO = new CMatrix(2,2);
        Sim.I = CMatrix.identity(2);  // identity gate for a single qubit
        Sim.H = CMatrix.mult( CMatrix.create([[1,1],[1,-1]]), Math.SQRT1_2 ); // hadamard gate

        Sim.X = CMatrix.create([[0,1],[1,0]]); // a Pauli X gate, also called a NOT gate
        Sim.Y = CMatrix.create([[new Complex(0,0),new Complex(0,-1)],[new Complex(0,1),new Complex(0,0)]]);
        Sim.Z = CMatrix.create([[1,0],[0,-1]]); // the same thing as Phase(180)

        // "SX" means "Square root of X"
        Sim.SX = CMatrix.mult(
            CMatrix.create([[new Complex(1,1),new Complex(1,-1)],[new Complex(1,-1),new Complex(1,1)]]),
            0.5
        );
        // This is the inverse
        Sim.invSX = CMatrix.mult(
            CMatrix.create([[new Complex(1,-1),new Complex(1,1)],[new Complex(1,1),new Complex(1,-1)]]),
            0.5
        );
        // "SY" means "Square root of Y"
        Sim.SY = CMatrix.mult(
            CMatrix.create([[new Complex(1,1),new Complex(-1,-1)],[new Complex(1,1),new Complex(1,1)]]),
            0.5
        );
        Sim.invSY = CMatrix.mult(
            CMatrix.create([[new Complex(1,-1),new Complex(1,-1)],[new Complex(-1,1),new Complex(1,-1)]]),
            0.5
        );
        // "SZ" means "Square root of Z"; the same thing as Phase(90), and the same thing as what is often called an S gate.
        Sim.SZ = CMatrix.create(
            [[new Complex(1,0),new Complex(0,0)],[new Complex(0,0),new Complex(0,1)]]
        );
        Sim.invSZ = CMatrix.create(
            [[new Complex(1,0),new Complex(0,0)],[new Complex(0,0),new Complex(0,-1)]]
        );


        // The "SS" prefix in "SSX", "SSY", "SSZ" means "Square root of Square root", i.e., 4th root.
        // SSZ is the same thing as Phase(45), and the same thing as what is often called a T gate.
        //
        //let cos_pi_over_8 = Math.cos(Math.PI/8);
        //let sin_pi_over_8 = Math.sin(Math.PI/8);
        let c1 = new Complex( (2+Math.SQRT2)/4 /* cos_pi_over_8*cos_pi_over_8 */, Math.SQRT1_2/2 /* sin_pi_over_8*cos_pi_over_8 */ );
        let c2 = new Complex( (2-Math.SQRT2)/4 /* sin_pi_over_8*sin_pi_over_8 */, - Math.SQRT1_2/2 /* sin_pi_over_8*cos_pi_over_8 */ );
        Sim.SSX = CMatrix.create([[c1,c2],[c2,c1]]);
        let c1_ = new Complex( (2+Math.SQRT2)/4, - Math.SQRT1_2/2 );
        let c2_ = new Complex( (2-Math.SQRT2)/4, Math.SQRT1_2/2 );
        Sim.invSSX = CMatrix.create([[c1_,c2_],[c2_,c1_]]);
        c2 = new Complex( - Math.SQRT1_2/2 /* sin_pi_over_8*cos_pi_over_8 */, - (2-Math.SQRT2)/4 /* sin_pi_over_8*sin_pi_over_8 */ );
        c2_ = new Complex( Math.SQRT1_2/2 , - (2-Math.SQRT2)/4 );
        let c3 = new Complex( Math.SQRT1_2/2 /* sin_pi_over_8*cos_pi_over_8 */, (2-Math.SQRT2)/4 /* sin_pi_over_8*sin_pi_over_8 */ );
        let c3_ = new Complex( -Math.SQRT1_2/2 , (2-Math.SQRT2)/4 );
        Sim.SSY = CMatrix.create([[c1,c2],[c3,c1]]);
        Sim.invSSY = CMatrix.create([[c1_,c2_],[c3_,c1_]]);
        Sim.SSZ = CMatrix.create(
            [[new Complex(1,0),new Complex(0,0)],[new Complex(0,0),new Complex(Math.SQRT1_2,Math.SQRT1_2)]]
        );
        Sim.invSSZ = CMatrix.create(
            [[new Complex(1,0),new Complex(0,0)],[new Complex(0,0),new Complex(Math.SQRT1_2,-Math.SQRT1_2)]]
        );


        Sim.RX_90deg = CMatrix.create([[new Complex(Math.SQRT1_2,0),new Complex(0,-Math.SQRT1_2)],[new Complex(0,-Math.SQRT1_2),new Complex(Math.SQRT1_2,0)]]);
        Sim.RY_90deg = CMatrix.create([[new Complex(Math.SQRT1_2,0),new Complex(-Math.SQRT1_2,0)],[new Complex(Math.SQRT1_2,0),new Complex(Math.SQRT1_2,0)]]);
        Sim.RZ_90deg = CMatrix.create([[new Complex(Math.SQRT1_2,-Math.SQRT1_2),new Complex(0,0)],[new Complex(0,0),new Complex(Math.SQRT1_2,Math.SQRT1_2)]]);

        // qubit q0 is the control bit, qubit q1 is the target bit.
        // CX is also often called CNOT
        Sim.CX = CMatrix.create([[1,0,0,0],[0,1,0,0],[0,0,0,1],[0,0,1,0]]).reverseEndianness( ! usingTextbookConvention );
        Sim.SWAP_2 = Sim.SWAP(0,1,2); // a swap gate for a two-qubit circuit
        Sim.iSWAP = CMatrix.create([[1,0,0,0],[0,0,Complex.i,0],[0,Complex.i,0,0],[0,0,0,1]]);
        Sim.sqrt_SWAP = CMatrix.create([[1,0,0,0],[0,new Complex(0.5,0.5),new Complex(0.5,-0.5),0],[0,new Complex(0.5,-0.5),new Complex(0.5,0.5),0],[0,0,0,1]]);

        // Here we define some magic states.
        //
        // This is cos(pi/8)|0> + sin(pi/8)|1> ≈ [ 0.924, 0.383 ]^T
        // and is given in Bravyi + Kitaev (2004), "Universal quantum computation with ideal Clifford gates and noisy ancillas", page 5, equation 3
        // In the bloch sphere, it's located at (phase=0, theta=45 degrees)
        // Other ways to compute the same state:
        //     CMatrix.naryMult( [ Sim.GlobalPhase(22.5), Sim.invSSY, Sim.H, Sim.ketZero ] );
        //     CMatrix.naryMult( [ Sim.GlobalPhase(-22.5), Sim.SSY, Sim.ketZero ] );
        Sim.ket_H_magic_state = CMatrix.createColVector([Math.cos(Math.PI/8),Math.sin(Math.PI/8)]);
        // This yields (1/2^0.5)(|0> + (e^(i pi/4))(|1>)) ≈ [ 0.707, 0.5+0.5i ]^T
        // and is given in Leone, Oliviero, Hamma (2022) "Stabilizer Rényi Entropy", page 2, column 2.
        // In the bloch sphere, it's located at (phase=45 degrees, theta=90 degrees)
        Sim.ket_H_magic_state_2 = CMatrix.naryMult( [ Sim.SSZ, Sim.H, Sim.ketZero ] );

        // This is ≈ [ 0.888, 0.325+0.325i ]^T
        // and is given in Bravyi + Kitaev (2004), "Universal quantum computation with ideal Clifford gates and noisy ancillas", page 5, equation 4
        // In the bloch sphere, it's located at (phase=45 degrees, theta≈54.735610 degrees)
        // where theta = pi/2 - arctan(1/(2^0.5)) radians
        // Other ways to compute the same state (ignoring differences in global phase):
        //     CMatrix.naryMult( [ Sim.RZ(45), Sim.RY(54.735610), Sim.ketZero ] );
        //     CMatrix.naryMult( [ Sim.ZE(0.25), Sim.YE(0.304087), Sim.ketZero ] );
        let angle_beta = 0.5 * Math.acos(1/Math.sqrt(3));
        let sine_beta_over_root2 = Math.SQRT1_2 * Math.sin(angle_beta);
        Sim.ket_T_magic_state = CMatrix.createColVector([ Math.cos(angle_beta), new Complex(sine_beta_over_root2,sine_beta_over_root2) ]);

    }
}

Sim.init();



function performRegressionTest( verbose=true ) {
    console.log("Matrices are ordered according to " + (usingTextbookConvention?"textbook":"common software") + " convention.");

    let input, step1, step2, step3, output, expectedOutput, success;
    let allSuccessful = true;


    // Simulate a circuit on two qubits that entangles them,
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22H%22],[%22%E2%80%A2%22,%22X%22]]}
    //
    // qubit q0 |0>----Hadamard-----o-----
    //                              |
    // qubit q1 |0>----------------(+)----
    //
    input = CMatrix.tensor( Sim.ketZero /*q1*/, Sim.ketZero /*q0*/, usingTextbookConvention );
    step1 = CMatrix.tensor( Sim.I /*q1*/, Sim.H /*q0*/, usingTextbookConvention );
    step2 = Sim.CX;
    output = CMatrix.naryMult([ step2, step1, input ]);
    if ( verbose) console.log(StringUtil.concatMultiline(
        step2.toString(),
        " * ",
        step1.toString(),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([ 0.707, 0, 0, 0.707 ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'872ec24acc' );
    allSuccessful &&= success;


    // Simulate another circuit on two qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22%E2%80%A2%22,%22X%22],[%22X%22]]}
    //
    // qubit q0 |0>----o----(+)-
    //                 |
    // qubit q1 |0>---(+)-------
    //
    input = CMatrix.tensor( Sim.ketZero /*q1*/, Sim.ketZero /*q0*/, usingTextbookConvention );
    step1 = Sim.CX;
    step2 = CMatrix.tensor( Sim.I /*q1*/, Sim.X /*q0*/, usingTextbookConvention );
    output = CMatrix.naryMult([ step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        step2.toString(),
        " * ",
        step1.toString(),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([ 0,1,0,0 ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'ec53d19216' );
    allSuccessful &&= success;


    // Simulate another circuit on two qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22%E2%80%A2%22,%22X%22],[%22X%22]],%22init%22:[1]}
    //
    // qubit q0 |1>----o----(+)-
    //                 |
    // qubit q1 |0>---(+)-------
    //
    input = CMatrix.tensor( Sim.ketZero /*q1*/, Sim.ketOne /*q0*/, usingTextbookConvention  );
    step1 = Sim.CX;
    step2 = CMatrix.tensor( Sim.I /*q1*/, Sim.X /*q0*/, usingTextbookConvention );
    output = CMatrix.naryMult([ step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        step2.toString(),
        " * ",
        step1.toString(),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([ 0,0,1,0 ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'2bbcc438a1' );
    allSuccessful &&= success;


    // Simulate another circuit on two qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22%E2%80%A2%22,%22X%22],[%22X%22]],%22init%22:[%22+%22,%22i%22]}
    //
    // qubit q0 |+>----o----(+)-
    //                 |
    // qubit q1 |i>---(+)-------
    //
    input = CMatrix.tensor( Sim.ketPlusI /*q1*/, Sim.ketPlus /*q0*/, usingTextbookConvention );
    step1 = Sim.CX;
    step2 = CMatrix.tensor( Sim.I /*q1*/, Sim.X /*q0*/, usingTextbookConvention );
    output = CMatrix.naryMult([ step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        step2.toString(),
        " * ",
        step1.toString(),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([ new Complex(0,0.5),0.5,0.5,new Complex(0,0.5) ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'7e132563e4' );
    allSuccessful &&= success;


    // Simulate another circuit on two qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[{%22id%22:%22Rxft%22,%22arg%22:%22pi/2%22},{%22id%22:%22Rxft%22,%22arg%22:%22pi/2%22}],[%22%E2%80%A2%22,{%22id%22:%22Rzft%22,%22arg%22:%22pi/2%22}]]}
    //
    // qubit q0 |0>----RX(pi/2)--------o--------
    //                                 |
    // qubit q1 |0>----RX(pi/2)----(RZ(pi/2))---
    //
    input = CMatrix.tensor( Sim.ketZero /*q1*/, Sim.ketZero /*q0*/, usingTextbookConvention );
    step1 = CMatrix.tensor( Sim.RX_90deg /*q1*/, Sim.RX_90deg /*q0*/, usingTextbookConvention );
    output = CMatrix.mult( step1, input );
    output = Sim.qubitWiseMultiply( Sim.RZ_90deg,1,2,output,[[0,true]]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        "... = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([ new Complex(0.5,0),new Complex(-0.35355,-0.35355),new Complex(0,-0.5),new Complex(-0.35355,-0.35355) ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'be0c19df98' );
    allSuccessful &&= success;


    // Simulate another circuit on two qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22X^%C2%BC%22,%22Y^%C2%BC%22],[1,%22X^%C2%BC%22]]}
    //
    // qubit q0 |0>----(x^0.25)-----------------
    //
    // qubit q1 |0>----(y^0.25)-----(x^0.25)----
    //
    input = CMatrix.tensor( Sim.ketZero /*q1*/, Sim.ketZero /*q0*/, usingTextbookConvention );
    step1 = CMatrix.tensor( Sim.SSY /*q1*/, Sim.SSX /*q0*/, usingTextbookConvention );
    step2 = CMatrix.tensor( Sim.SSX /*q1*/, Sim.I /*q0*/, usingTextbookConvention );
    output = CMatrix.naryMult([ step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        step2.toString(),
        " * ",
        step1.toString(),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([ new Complex(0.42678, 0.67678),new Complex(0.28033, -0.17678),new Complex(0.42678, 0.17678),new Complex(0.07322, -0.17678) ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'21e10d99d6' );
    allSuccessful &&= success;


    // Simulate a circuit on three qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22X^%C2%BC%22,%22Y^%C2%BC%22,%22H%22],[1,%22X^%C2%BC%22],[1,%22Swap%22,%22Swap%22]]}
    //
    // qubit q0 |0>----(x^0.25)----------------------
    //
    // qubit q1 |0>----(y^0.25)-----(x^0.25)----X-----
    //                                          |
    // qubit q2 |0>-------H---------------------X-----
    //
    input = CMatrix.naryTensor( [ Sim.ketZero /*q2*/, Sim.ketZero /*q1*/, Sim.ketZero /*q0*/ ], usingTextbookConvention );
    step1 = CMatrix.naryTensor( [ Sim.H /*q2*/, Sim.SSY /*q1*/, Sim.SSX /*q0*/ ], usingTextbookConvention );
    step2 = CMatrix.naryTensor( [ Sim.I /*q2*/, Sim.SSX /*q1*/, Sim.I /*q0*/ ], usingTextbookConvention );
    step3 = Sim.SWAP(1,2,3);
    output = CMatrix.naryMult([ step3, step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        step3.toString(),
        " * ",
        step2.toString({decimalPrecision:1}),
        " * ",
        "...", // step1.toString({decimalPrecision:1}),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([
        new Complex(0.30178,0.47855),
        new Complex(0.19822,-0.12500),
        new Complex(0.30178,0.47855),
        new Complex(0.19822,-0.12500),
        new Complex(0.30178,0.12500),
        new Complex(0.05178,-0.12500),
        new Complex(0.30178,0.12500),
        new Complex(0.05178,-0.12500)
    ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'1c4fee293c' );
    allSuccessful &&= success;




    // Simulate a circuit on three qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22X^%C2%BC%22,%22Y^%C2%BC%22,%22H%22],[1,%22X^%C2%BC%22],[1,%22X%22,%22%E2%80%A2%22]]}
    //
    // qubit q0 |0>----(x^0.25)-------------------------
    //
    // qubit q1 |0>----(y^0.25)-----(x^0.25)----(+)-----
    //                                           |
    // qubit q2 |0>-------H----------------------o------
    //
    input = CMatrix.naryTensor( [ Sim.ketZero /*q2*/, Sim.ketZero /*q1*/, Sim.ketZero /*q0*/ ], usingTextbookConvention );
    step1 = CMatrix.naryTensor( [ Sim.H /*q2*/, Sim.SSY /*q1*/, Sim.SSX /*q0*/ ], usingTextbookConvention );
    step2 = CMatrix.naryTensor( [ Sim.I /*q2*/, Sim.SSX /*q1*/, Sim.I /*q0*/ ], usingTextbookConvention );
    step3 = Sim.expand4x4ForNWires( Sim.CX, 2, 1, 3 );
    output = CMatrix.naryMult([ step3, step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        step3.toString(),
        " * ",
        step2.toString({decimalPrecision:1}),
        " * ",
        "...", // step1.toString({decimalPrecision:1}),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([
        new Complex(0.30178,0.47855),
        new Complex(0.19822,-0.12500),
        new Complex(0.30178,0.12500),
        new Complex(0.05178,-0.12500),
        new Complex(0.30178,0.12500),
        new Complex(0.05178,-0.12500),
        new Complex(0.30178,0.47855),
        new Complex(0.19822,-0.12500)
    ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'1c4dab5619' );
    allSuccessful &&= success;




    // Simulate the same circuit, but this time without using explicit large matrices.
    //
    // qubit q0 |0>----(x^0.25)-------------------------
    //
    // qubit q1 |0>----(y^0.25)-----(x^0.25)----(+)-----
    //                                           |
    // qubit q2 |0>-------H----------------------o------
    //
    input = CMatrix.naryTensor( [ Sim.ketZero /*q2*/, Sim.ketZero /*q1*/, Sim.ketZero /*q0*/ ], usingTextbookConvention  );
    step1 = Sim.qubitWiseMultiply(Sim.H,2,3,input,[]);
    step1 = Sim.qubitWiseMultiply(Sim.SSY,1,3,step1,[]);
    step1 = Sim.qubitWiseMultiply(Sim.SSX,0,3,step1,[]);
    step2 = Sim.qubitWiseMultiply(Sim.SSX,1,3,step1,[]);
    output = Sim.qubitWiseMultiply(Sim.X,1,3,step2,[[2,true]]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        input.toString(),
        " -> ",
        step1.toString(),
        " -> ",
        step2.toString(),
        " -> ",
        output.toString({binaryPrefixes:true})
    ));
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'23abd31026' );
    allSuccessful &&= success;





    // Simulate another circuit on two qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22X^%C2%BD%22,%22X^%C2%BD%22],[%22%E2%80%A2%22,%22X%22]],%22init%22:[0,%22-%22]}
    //
    // qubit q0 |0>---(x^0.5)----o-----
    //                           |
    // qubit q1 |->---(x^0.5)---(+)----
    //
    input = CMatrix.tensor( Sim.ketMinus /*q1*/, Sim.ketZero /*q0*/, usingTextbookConvention );
    step1 = CMatrix.tensor( Sim.SX /*q1*/, Sim.SX /*q0*/, usingTextbookConvention );
    step2 = Sim.CX;
    output = CMatrix.naryMult([ step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        step2.toString(),
        " * ",
        step1.toString(),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([
        new Complex(-0.35355, 0.35355),
        new Complex(-0.35355,-0.35355),
        new Complex( 0.35355,-0.35355),
        new Complex( 0.35355, 0.35355)
    ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'1c58b99eac' );
    allSuccessful &&= success;


    // Simulate another circuit on two qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22X^%C2%BD%22,%22X%22],[%22H%22,%22X^%C2%BD%22],[%22%E2%80%A2%22,%22X%22]]}
    //
    // qubit q0 |0>---(x^0.5)--hadamard----o-----
    //                                     |
    // qubit q1 |0>-----(+)-----(x^0.5)---(+)----
    //
    input = CMatrix.tensor( Sim.ketZero /*q1*/, Sim.ketZero /*q0*/, usingTextbookConvention );
    step1 = CMatrix.tensor( Sim.X /*q1*/, Sim.SX /*q0*/, usingTextbookConvention );
    step2 = CMatrix.tensor( Sim.SX /*q1*/, Sim.H /*q0*/, usingTextbookConvention );
    step3 = Sim.CX;
    output = CMatrix.naryMult([ step3, step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        step3.toString(),
        " * ",
        step2.toString(),
        " * ",
        step1.toString(),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([
        new Complex( 0.35355,-0.35355),
        new Complex(-0.35355, 0.35355),
        new Complex( 0.35355, 0.35355),
        new Complex( 0.35355, 0.35355)
    ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'723049b630' );
    allSuccessful &&= success;


    // Simulate another circuit on three qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22X^%C2%BD%22,%22X^%C2%BD%22,%22X^%C2%BD%22],[1,%22X%22,%22%E2%80%A2%22]]}
    //
    // qubit q0 |0>---(x^0.5)--------
    //
    // qubit q1 |0>---(x^0.5)--(+)---
    //                          |
    // qubit q2 |0>---(x^0.5)---o----
    //
    input = CMatrix.naryTensor( [ Sim.ketZero /*q2*/, Sim.ketZero /*q1*/, Sim.ketZero /*q0*/ ], usingTextbookConvention  );
    step1 = CMatrix.naryTensor( [ Sim.SX /*q2*/, Sim.SX /*q1*/, Sim.SX /*q0*/ ], usingTextbookConvention  );
    step2 = Sim.expand4x4ForNWires( Sim.CX, 2, 1, 3 );
    output = CMatrix.naryMult([ step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        step2.toString(),
        " * ",
        step1.toString(),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([
        new Complex(-0.25, 0.25),
        new Complex( 0.25, 0.25),
        new Complex( 0.25, 0.25),
        new Complex( 0.25,-0.25),
        new Complex( 0.25,-0.25),
        new Complex(-0.25,-0.25),
        new Complex( 0.25, 0.25),
        new Complex( 0.25,-0.25)
    ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'c7cdcdc026' );
    allSuccessful &&= success;


    // Simulate the same circuit, but this time without using explicit large matrices.
    //
    // qubit q0 |0>---(x^0.5)--------
    //
    // qubit q1 |0>---(x^0.5)--(+)---
    //                          |
    // qubit q2 |0>---(x^0.5)---o----
    //
    input = CMatrix.naryTensor( [ Sim.ketZero /*q2*/, Sim.ketZero /*q1*/, Sim.ketZero /*q0*/ ], usingTextbookConvention  );
    step1 = Sim.qubitWiseMultiply(Sim.SX,0,3,input,[]);
    step1 = Sim.qubitWiseMultiply(Sim.SX,1,3,step1,[]);
    step1 = Sim.qubitWiseMultiply(Sim.SX,2,3,step1,[]);
    output = Sim.qubitWiseMultiply(Sim.X,1,3,step1,[[2,true]]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        input.toString(),
        " -> ",
        step1.toString(),
        " -> ",
        output.toString({binaryPrefixes:true})
    ));
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'45cacd1026' );
    allSuccessful &&= success;



    // Simulate a circuit on four qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22H%22,%22X^%C2%BD%22,1,%22X^%C2%BD%22],[%22%E2%80%A2%22,1,%22X%22],[1,%22X%22,%22%E2%80%A2%22],[1,%22%E2%80%A2%22,1,%22X%22],[1,%22H%22]]}
    //
    // qubit q0 |0>---hadamard---o--------------------------
    //                           |
    // qubit q1 |0>---(x^0.5)----|---(+)----o----hadamard---
    //                           |    |     |
    // qubit q2 |0>-------------(+)---o-----|---------------
    //                                      |
    // qubit q3 |0>---(x^0.5)--------------(+)--------------
    //
    input = CMatrix.naryTensor( [ Sim.ketZero /*q3*/, Sim.ketZero /*q2*/, Sim.ketZero /*q1*/, Sim.ketZero /*q0*/ ], usingTextbookConvention );
    step1 = CMatrix.naryTensor( [ Sim.SX /*q3*/, Sim.I /*q2*/, Sim.SX /*q1*/, Sim.H /*q0*/ ], usingTextbookConvention );
    step2 = Sim.expand4x4ForNWires( Sim.CX, 0, 2, 4 );
    step3 = Sim.expand4x4ForNWires( Sim.CX, 2, 1, 4 );
    step4 = Sim.expand4x4ForNWires( Sim.CX, 1, 3, 4 );
    step5 = CMatrix.naryTensor( [ Sim.I /*q3*/, Sim.I /*q2*/, Sim.H /*q1*/, Sim.I /*q0*/ ], usingTextbookConvention );

    output = CMatrix.naryMult([ step5, step4, step3, step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        "... = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([
        new Complex( 0  , 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0  , 0.5),
        new Complex( 0  , 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0.5, 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0.5, 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0  ,-0.5)
    ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'95b90f1b5d' );
    allSuccessful &&= success;

    // Try simulating the same circuit, but this time without using explicit large matrices.
    output_method2 = Sim.qubitWiseMultiply(Sim.H,0,4,input,[]);
    output_method2 = Sim.qubitWiseMultiply(Sim.SX,1,4,output_method2,[]);
    output_method2 = Sim.qubitWiseMultiply(Sim.SX,3,4,output_method2,[]);
    output_method2 = Sim.qubitWiseMultiply(Sim.X,2,4,output_method2,[[0,true]]);
    output_method2 = Sim.qubitWiseMultiply(Sim.X,1,4,output_method2,[[2,true]]);
    output_method2 = Sim.qubitWiseMultiply(Sim.X,3,4,output_method2,[[1,true]]);
    output_method2 = Sim.qubitWiseMultiply(Sim.H,1,4,output_method2,[]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        "Difference found using a better method: ",
        CMatrix.diff(output,output_method2).transpose().toString()
    ));
    success = CMatrix.approximatelyEqual(output,output_method2);
    Util.assert( success, "Regression test failed "+'95b90f1b5d_B' );
    allSuccessful &&= success;



    console.log( allSuccessful ? "All regression tests passed." : "At least one regression test failed." );
}

performRegressionTest(false);

</script>




<!----- START: web analytics via https://www.goatcounter.com/ , to log visits, without tracking personal info ----->

<script>
    window.goatcounter = {
        path: function(p) {
            // remove everything after the substring
            let substring = "?circuit=";
            let index = p.indexOf(substring);
            if (index !== -1) {
                p = p.slice(0, index + substring.length);
            }
            // prepend with the domain name
            return location.host + p;
        }
    }
</script>
<script data-goatcounter="https://mjmcguffin.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>

<!----- END: web analytics ----->



<script language="JavaScript">


// ============================================================
// Vec2 objects are for storing 2D points and 2D vectors.
// To create a new instance, use the new keyword:
//    let vector_a = new Vec2();
//    let vector_b = new Vec2(x,y);
// These objects are mutable. After an instance has been created,
// its coordinates can be changed by writing directly to data members:
//    vector_a.x = 10;
//    vector_a.y = -2;
// ============================================================
class Vec2 {
    constructor(x=0,y=0) {
        this.x = x;
        this.y = y;
    }

    // Performs a deep copy.
    copy(other) {
        this.x = other.x; this.y = other.y;
    }

    // Returns the negation of the vector.
    negate() { return new Vec2(-this.x,-this.y); }

    // Returns the Euclidean length (also called magnitude or L2-norm) of the vector.
    norm() { return Math.sqrt( this.x*this.x + this.y*this.y ); }

    // Returns the squared length.
    // This is useful when the caller needs to compare
    // the length of a vector to a pre-defined threshold,
    // or compare the lengths of two vectors:
    // in such cases, comparing the squared length is sufficient,
    // and saves a square root operation.
    normSquared() { return this.x*this.x + this.y*this.y; }

    // Returns a normalized vector of unit length.
    normalize() {
        let n = this.norm();
        if ( n > 0 ) {
            let k = 1.0/n;
            return new Vec2( k*this.x, k*this.y );
        }
        return new Vec2();
    }

    angle() {
        let lengthSquared = this.x*this.x + this.y*this.y;
        if ( lengthSquared === 0 ) return 0;
        let sine = Math.abs( this.y/Math.sqrt( lengthSquared ) );
        let theta = ( sine >= 1 ) ? Math.PI/2 : Math.asin( sine );
        if ( this.x < 0 ) theta = Math.PI - theta;
        if ( this.y < 0 ) theta = - theta;
        return theta;
    }
    setAngle( theta ) {
        let delta_theta = theta - this.angle();
        let sine = Math.sin( delta_theta );
        let cosine = Math.cos( delta_theta );
        let rotatedX = this.x * cosine - this.y * sine;
        let rotatedY = this.x * sine + this.y * cosine;
        this.x = rotatedX;
        this.y = rotatedY;
    }

    // A static method that returns the sum of two vectors.
    static sum( v1, v2 ) {
        return new Vec2( v1.x+v2.x, v1.y+v2.y );
    }

    // A static method that returns the difference of two vectors.
    static diff( v1, v2 ) {
        return new Vec2( v1.x-v2.x, v1.y-v2.y );
    }
    // A static method that returns the product of a vector with a scalar.
    static mult( v, k ) {
        return new Vec2( k*v.x, k*v.y );
    }
    // A static method that returns the dot product of two vectors
    static dot( v1, v2 ) {
        return v1.x*v2.x + v1.y*v2.y;
    }
    // A static method that returns the centroid of two vectors
    static average( v1, v2 ) {
        return new Vec2( (v1.x+v2.x)*0.5, (v1.y+v2.y)*0.5 );
    }
    // Returns the centroid of an array of vectors
    static centroid( listOfPoints ) {
        let x = 0;
        let y = 0;
        let N = listOfPoints.length;
        for ( let i = 0; i < N; i ++ ) {
            x += listOfPoints[i].x;
            y += listOfPoints[i].y;
        }
        return new Vec2( x/N, y/N );
    }

    static distance( v1, v2 ) {
        let dx = v1.x - v2.x;
        let dy = v1.y - v2.y;
        return Math.sqrt( dx*dx + dy*dy );
    }
    static distanceSquared( v1, v2 ) {
        let dx = v1.x - v2.x;
        let dy = v1.y - v2.y;
        return dx*dx + dy*dy;
    }
}

// ============================================================
// Box2 objects are for storing 2D axis-aligned rectangles.
// To create a new instance, use the new keyword:
//    let box_a = new Box2();
//    let box_b = new Box2(new Vec2(-10,-10),new Vec2(10,10));
// ============================================================

class Box2 {
    constructor( vec2_min = null, vec2_max = null ) {
        // Internally, the min and max points are diagonally opposite,
        // and are only valid if isEmpty===false.
        // Below, we initialize things based on what the client passed in.

        this.isEmpty = true;
        this.min = new Vec2();
        this.max = new Vec2();
        if ( vec2_min !== null && vec2_max !== null ) {
            this.boundPoint( vec2_min );
            this.boundPoint( vec2_max );
        }
    }
    clear() { this.isEmpty = true; this.min = new Vec2(); this.max = new Vec2(); }
    center() { return Vec2.average(this.min,this.max); }
    diagonal() { return Vec2.diff(this.max,this.min); }
    width() { return this.max.x - this.min.x; }
    height() { return this.max.y - this.min.y; }

    containsPoint( q ) {
        return !( this.isEmpty || q.x < this.min.x || q.x > this.max.x || q.y < this.min.y || q.y > this.max.y );
    }
    containsBox( b ) {
        if ( this.isEmpty ) return false;
        if ( b.isEmpty ) return true;
        return this.min.x <= b.min.x && b.max.x <= this.max.x && this.min.y <= b.min.y && b.max.y <= this.max.y;
    }

    // Returns true if there is any overlap with the given rectangle
    overlapsBox( b ) {
        if ( this.isEmpty || b.isEmpty ) return false;
        return ! (
            b.max.x < this.min.x
            || b.min.x > this.max.x
            || b.max.y < this.min.y
            || b.min.y > this.max.y
        );
    }

    // Enlarges the box enough to contain the given point
    boundPoint( vec2 ) {
        if ( this.isEmpty ) {
            this.isEmpty = false;
            this.min.copy( vec2 );
            this.max.copy( vec2 );
        }
        else {
            if ( vec2.x < this.min.x ) this.min.x = vec2.x;
            else if ( vec2.x > this.max.x ) this.max.x = vec2.x;

            if ( vec2.y < this.min.y ) this.min.y = vec2.y;
            else if ( vec2.y > this.max.y ) this.max.y = vec2.y;
        }
    }
    boundPoints( points ) {
        for ( let i = 0; i < points.length; ++i ) {
            this.boundPoint( points[i] );
        }
    }

    // Enlarges the box enough to contain the given box
    boundBox( box ) {
        if ( ! box.isEmpty ) {
            this.boundPoint( box.min );
            this.boundPoint( box.max );
        }
    }

    // Find the intersection with the given box and save the result.
    intersectBox( b ) {
        if ( this.isEmpty ) return;
        if ( b.isEmpty ) {
            clear();
            return;
        }
        this.min.x = Math.max( this.min.x, b.min.x );
        this.min.y = Math.max( this.min.y, b.min.y );
        this.max.x = Math.min( this.max.x, b.max.x );
        this.max.y = Math.min( this.max.y, b.max.y );
        if ( this.min.x > this.max.x || this.min.y > this.max.y ) {
            this.clear();
        }
    }
}


// ============================================================
// Draw2 objects are for managing the transformation between
// pixel space and a 2D world space, allowing a client to pan and zoom.
// The objects also manage the drawing of simple shapes on a canvas,
// allowing a client to pass in coordinates in either space
// (pixel space or world space).
// To create a new instance, use the new keyword:
//    let draw2 = new Draw2(canvas);
// ============================================================


// TD_ prefix means Text Direction
const TD_HORIZONTALLY_RIGHT = 0;
const TD_VERTICALLY_DOWN = 1;


class Draw2 {
    static PIXELS = "pixels";
    static WORLD = "world";


    constructor(canvas) {
        this.canvas = canvas;
        this.canvas_context = canvas.getContext("2d");
        this.canvasWidth_pixels = canvas.width;
        this.canvasHeight_pixels = canvas.height;
        this.offsetX_pixels = 0;
        this.offsetY_pixels = 0;
        this.scaleFactorInWorldSpaceUnitsPerPixel = 1.0; // greater if user is more zoomed out
        this.setFont(this.canvas_context.font);
        this.coordinateSystem = Draw2.PIXELS;
        this.resetWorldTransformation();
    }
    setFont(fontName/*Example: 'italic 27px Calibri'*/) {
        this.canvas_context.font = fontName;
        this.fontHeight = parseInt(this.canvas_context.font.match(/\d+/)[0],10);
    }
    setFontHeight( fontHeight /*in pixels*/ ) {
        this.canvas_context.font = fontHeight.toString() + "px sans-serif";
        this.fontHeight = parseInt(this.canvas_context.font.match(/\d+/)[0],10);
    }
    convertPixelsToWorldSpaceUnitsX( x_pixels ) {
        return ( x_pixels - this.offsetX_pixels )*this.scaleFactorInWorldSpaceUnitsPerPixel;
    }
    convertPixelsToWorldSpaceUnitsY( y_pixels ) {
        return ( y_pixels - this.offsetY_pixels )*this.scaleFactorInWorldSpaceUnitsPerPixel;
    }
    convertPixelsToWorldSpaceUnits( p_pixels ) {
        return new Vec2(
            ( p_pixels.x - this.offsetX_pixels )*this.scaleFactorInWorldSpaceUnitsPerPixel,
            ( p_pixels.y - this.offsetY_pixels )*this.scaleFactorInWorldSpaceUnitsPerPixel
        );
    }

    convertWorldSpaceUnitsToPixelsX( x_world ) {
        return x_world / this.scaleFactorInWorldSpaceUnitsPerPixel + this.offsetX_pixels;
    }
    convertWorldSpaceUnitsToPixelsY( y_world ) {
        return y_world / this.scaleFactorInWorldSpaceUnitsPerPixel + this.offsetY_pixels;
    }
    convertWorldSpaceUnitsToPixels( p_world ) {
        return new Vec2(
            p_world.x / this.scaleFactorInWorldSpaceUnitsPerPixel + this.offsetX_pixels,
            p_world.y / this.scaleFactorInWorldSpaceUnitsPerPixel + this.offsetY_pixels
        );
    }


    translate( deltaX_pixels, deltaY_pixels ) {
        this.offsetX_pixels += deltaX_pixels;
        this.offsetY_pixels += deltaY_pixels;
    }
    zoomIn(
        zoomFactor // greater than 1 to zoom in, between 0 and 1 to zoom out
    ) {
        let centerX_pixels = this.canvasWidth_pixels * 0.5;
        let centerY_pixels = this.canvasHeight_pixels * 0.5;
        this.scaleFactorInWorldSpaceUnitsPerPixel /= zoomFactor;
        this.offsetX_pixels = centerX_pixels - (centerX_pixels - this.offsetX_pixels) * zoomFactor;
        this.offsetY_pixels = centerY_pixels - (centerY_pixels - this.offsetY_pixels) * zoomFactor;
    }




    // Causes the zoom and translation to be adjusted to fit the given rectangle within the canvas
    frameWithinCanvasRegion(
        rect, // an instance of Box2; the rectangle (in world space) to frame
        expand, // true if caller wants a margin of whitespace added around the rect
        region_x,region_y, // pixel coordinates of upper left corner of region within the canvas
        region_w, region_h // dimensions in pixels
    ) {
        if ( rect.isEmpty || rect.diagonal().x === 0 || rect.diagonal().y === 0 ) {
            return;
        }
        if ( expand ) {
            let diagonal = rect.diagonal().norm() / 50;
            let v = new Vec2( diagonal, diagonal );
            rect = new Box2( Vec2.diff(rect.min,v), Vec2.sum(rect.max,v) );
        }
        if ( rect.width() / rect.height() >= region_w / region_h ) {
            // The rectangle to frame is wider (or shorter) than the region of the canvas,
            // so the limiting factor is the width of the rectangle.
            this.offsetX_pixels = - rect.min.x * region_w / rect.width() + region_x;
            this.scaleFactorInWorldSpaceUnitsPerPixel = rect.width() / region_w;
            this.offsetY_pixels = region_h/2 - rect.center().y / this.scaleFactorInWorldSpaceUnitsPerPixel + region_y;
        }
        else {
            // The limiting factor is the height of the rectangle.
            this.offsetY_pixels = - rect.min.y * region_h / rect.height() + region_y;
            this.scaleFactorInWorldSpaceUnitsPerPixel = rect.height() / region_h;
            this.offsetX_pixels = region_w/2 - rect.center().x / this.scaleFactorInWorldSpaceUnitsPerPixel + region_x;
        }
    }
    frameWithinEntireCanvas(
        rect, // an instance of Box2; the rectangle (in world space) to frame
        expand // true if caller wants a margin of whitespace added around the rect
    ) {
        this.frameWithinCanvasRegion(rect,expand,0,0,this.canvasWidth_pixels,this.canvasHeight_pixels);
    }

    translateToEnclose( targetRect ) {
        let canvasRect_world = new Box2(
            this.convertPixelsToWorldSpaceUnits(
                new Vec2( 0, 0 )
            ),
            this.convertPixelsToWorldSpaceUnits(
                new Vec2( this.canvasWidth_pixels, this.canvasHeight_pixels )
            )
        );
        if (canvasRect_world.containsBox(targetRect)) {
            // The target is already within the canvas
            return;
        }
        let canvasCenter_world = canvasRect_world.center();
        let targetCenter_world = targetRect.center();
        let d1 = Vec2.diff( targetCenter_world, canvasCenter_world );
        let d1_length = d1.norm();
        let canvas_halfDiagonal = Vec2.mult( canvasRect_world.diagonal(), 0.5 );
        let target_halfDiagonal = Vec2.mult( targetRect.diagonal(), 0.5 );
        if (
            target_halfDiagonal.x > canvas_halfDiagonal.x
            || target_halfDiagonal.y > canvas_halfDiagonal.y
        ) {
            // The target is too big to fit in the canvas without zooming out,
            // so just center the target in the canvas
            // by applying the d1 translation.
            this.offsetX_pixels -= d1.x / this.scaleFactorInWorldSpaceUnitsPerPixel;
            this.offsetY_pixels -= d1.y / this.scaleFactorInWorldSpaceUnitsPerPixel;
            return;
        }
        let distanceToTranslate = 0;
        let candidateDistance = 0;
        if ( d1.x < 0 ) {
            // Find distance to translate toward -x, using similar triangles.
            // Larger triangle's hypotenuse / base = smaller triangle's hypotenuse / base
            // d1_length / (-d1.x) = candidateDistance / (-d1.x-(canvas_halfDiagonal.x - target_halfDiagonal.x))
            candidateDistance = d1_length / (-d1.x) * (-d1.x-(canvas_halfDiagonal.x - target_halfDiagonal.x));
            if ( candidateDistance > distanceToTranslate ) {
                distanceToTranslate = candidateDistance;
            }
        }
        else if ( d1.x > 0 ) {
            // Find distance to translate toward +x, using similar triangles.
            // Larger triangle's hypotenuse / base = smaller triangle's hypotenuse / base
            // d1_length / (d1.x) = candidateDistance / (d1.x-(canvas_halfDiagonal.x - target_halfDiagonal.x))
            candidateDistance = d1_length / (d1.x) * (d1.x-(canvas_halfDiagonal.x - target_halfDiagonal.x));
            if ( candidateDistance > distanceToTranslate ) {
                distanceToTranslate = candidateDistance;
            }
        }
        if ( d1.y < 0 ) {
            // Find distance to translate toward -y, using similar triangles.
            // Larger triangle's hypotenuse / base = smaller triangle's hypotenuse / base
            // d1_length / (-d1.y) = candidateDistance / (-d1.y-(canvas_halfDiagonal.y - target_halfDiagonal.y))
            candidateDistance = d1_length / (-d1.y) * (-d1.y-(canvas_halfDiagonal.y - target_halfDiagonal.y));
            if ( candidateDistance > distanceToTranslate ) {
                distanceToTranslate = candidateDistance;
            }
        }
        else if ( d1.y > 0 ) {
            // Find distance to translate toward +y, using similar triangles.
            // Larger triangle's hypotenuse / base = smaller triangle's hypotenuse / base
            // d1_length / (d1.y) = candidateDistance / (d1.y-(canvas_halfDiagonal.y - target_halfDiagonal.y))
            candidateDistance = d1_length / (d1.y) * (d1.y-(canvas_halfDiagonal.y - target_halfDiagonal.y));
            if ( candidateDistance > distanceToTranslate ) {
                distanceToTranslate = candidateDistance;
            }
        }

        // Scale d1 to have length distanceToTranslate
        d1 = Vec2.mult( d1.normalize(), distanceToTranslate );

        // Apply the d1 translation.
        this.offsetX_pixels -= d1.x / this.scaleFactorInWorldSpaceUnitsPerPixel;
        this.offsetY_pixels -= d1.y / this.scaleFactorInWorldSpaceUnitsPerPixel;
    }


    resize(
        w, h // the new canvas dimensions, in pixels
    ) {
        let oldCenter = this.convertPixelsToWorldSpaceUnits( new Vec2(
            this.canvasWidth_pixels * 0.5, this.canvasHeight_pixels * 0.5
        ) );
        let radius = Math.min( this.canvasWidth_pixels, this.canvasHeight_pixels ) * 0.5 * this.scaleFactorInWorldSpaceUnitsPerPixel;

        this.canvasWidth_pixels = w;
        this.canvasHeight_pixels = h;

        if ( radius > 0 ) {
            this.frameWithinEntireCanvas(
                new Box2(
                    new Vec2( oldCenter.x - radius, oldCenter.y - radius ),
                    new Vec2( oldCenter.x + radius, oldCenter.y + radius )
                ),
                false
            );
        }
    }

    setCoordinateSystemToPixels() {
        this.coordinateSystem = Draw2.PIXELS;
    }
    setCoordinateSystemToWorldSpaceUnits() {
        this.coordinateSystem = Draw2.WORLD;
    }

    setWorldTransformation( /* Vec2 */ translation, scale, angle /*in radians*/ ) {
        this.hasWorldTransform = true;
        this.worldTransform_translation.copy( translation );
        this.worldTransform_scale = scale;
        this.worldTransform_angle = angle;
        this.worldTransform_sine = Math.sin( angle );
        this.worldTransform_cosine = Math.cos( angle );
        //console.log( "transforming with " + scale + "," + angle + ", " + this.worldTransform_sine );
    }
    resetWorldTransformation() {
        this.hasWorldTransform = false;
        this.worldTransform_translation = new Vec2();
        this.worldTransform_scale = 1.0;
        this.worldTransform_angle = 0;
    }
    applyTransformation( x, y ) {
        let rotatedX = x * this.worldTransform_cosine - y * this.worldTransform_sine;
        let rotatedY = x * this.worldTransform_sine + y * this.worldTransform_cosine;
        let p = Vec2.sum( Vec2.mult( new Vec2( rotatedX, rotatedY ), this.worldTransform_scale ), this.worldTransform_translation );
        //console.log("apply " + x + "," + y + "; ; " + p.x + ", " + p.y + ", " + this.worldTransform_sine + ", " + this.worldTransform_cosine + " , " + this.worldTransform_scale + ", " + this.worldTransform_translation.x + ", " + this.worldTransform_translation.y );
        return p;
    }


    setStrokeColor_array( array ) {
        this.setStrokeColor(array[0],array[1],array[2],array[3]);
    }
    setStrokeColor(
        red, green, blue, // between 0 and 255
        alpha=1.0 // between 0.0 and 1.0
    ) {
        if ( alpha === 1.0 )
            this.canvas_context.strokeStyle = "rgb("+red+","+green+","+blue+")";
        else
            this.canvas_context.strokeStyle = "rgba("+red+","+green+","+blue+","+alpha+")";
    }
    setFillColor_array( array ) {
        this.setFillColor(array[0],array[1],array[2],array[3]);
    }
    setFillColor(
        red, green, blue, // between 0 and 255
        alpha=1.0 // between 0.0 and 1.0
    ) {
        if ( alpha === 1.0 )
            this.canvas_context.fillStyle = "rgb("+red+","+green+","+blue+")";
        else
            this.canvas_context.fillStyle = "rgba("+red+","+green+","+blue+","+alpha+")";
    }
    setLineWidth( lw ) {
        this.canvas_context.lineWidth = lw;
    }
    clear(
        red, green, blue // between 0 and 255
    ) {
        this.setFillColor(red,green,blue);
        this.canvas_context.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
    drawLine( x1, y1, x2, y2 ) {
        if ( this.coordinateSystem === Draw2.WORLD ) {
            //console.log("drawLine " + x1 + "," + y1 + ",  " + x2 + "," + y2 );
            if ( this.hasWorldTransform ) {
                // console.log("drawLine " + x1 + "," + y1 + ",  " + x2 + "," + y2 );
                let p = this.applyTransformation(x1,y1);
                x1 = p.x;
                y1 = p.y;
                p = this.applyTransformation(x2,y2);
                x2 = p.x;
                y2 = p.y;
            }
            //console.log("drawLine " + x1 + "," + y1 + ",  " + x2 + "," + y2 );
            x1 = this.convertWorldSpaceUnitsToPixelsX( x1 );
            y1 = this.convertWorldSpaceUnitsToPixelsY( y1 );
            x2 = this.convertWorldSpaceUnitsToPixelsX( x2 );
            y2 = this.convertWorldSpaceUnitsToPixelsY( y2 );
        }

        this.canvas_context.beginPath();
        this.canvas_context.moveTo(x1,y1);
        this.canvas_context.lineTo(x2,y2);
        this.canvas_context.stroke();
    }
    drawRect( x, y, w, h, isFilled=false ) {
        if ( w < 0 ) {
            w = -w;
            x -= w;
        }
        if ( h < 0 ) {
            h = -h;
            y -= h;
        }
        if ( this.coordinateSystem === Draw2.WORLD ) {
            if ( this.hasWorldTransform ) {
                let p = this.applyTransformation(x,y);
                x = p.x;
                y = p.y;
            }
            x = this.convertWorldSpaceUnitsToPixelsX( x );
            y = this.convertWorldSpaceUnitsToPixelsY( y );
            w /= this.scaleFactorInWorldSpaceUnitsPerPixel;
            h /= this.scaleFactorInWorldSpaceUnitsPerPixel;
        }
        if ( isFilled ) this.canvas_context.fillRect( x, y, w, h );
        else this.canvas_context.strokeRect( x, y, w, h );
    }
    fillRect( x, y, w, h ) {
        this.drawRect(x,y,w,h,true);
    }
    drawCircle( x_center, y_center, radius, isFilled=false ) {
        if ( this.coordinateSystem === Draw2.WORLD ) {
            x_center = this.convertWorldSpaceUnitsToPixelsX( x_center );
            y_center = this.convertWorldSpaceUnitsToPixelsY( y_center );
            radius /= this.scaleFactorInWorldSpaceUnitsPerPixel;
        }
        this.canvas_context.beginPath();
        this.canvas_context.arc(x_center, y_center, radius, 0, 2 * Math.PI, false);
        if ( isFilled ) this.canvas_context.fill();
        else this.canvas_context.stroke();
    }
    drawArc( x_center, y_center, radius, startAngle /*radians*/, endAngle /*radians*/, isFilled=false ) {
        if ( this.coordinateSystem === Draw2.WORLD ) {
            x_center = this.convertWorldSpaceUnitsToPixelsX( x_center );
            y_center = this.convertWorldSpaceUnitsToPixelsY( y_center );
            radius /= this.scaleFactorInWorldSpaceUnitsPerPixel;
        }
        this.canvas_context.beginPath();
        if ( isFilled ) this.canvas_context.moveTo(x_center,y_center);
        this.canvas_context.arc(x_center, y_center, radius, startAngle, endAngle, startAngle > endAngle /*counterclockwise*/);
        if ( isFilled ) this.canvas_context.fill();
        else this.canvas_context.stroke();
    }
    fillCircle( x_center, y_center, radius ) {
        this.drawCircle( x_center, y_center, radius, true );
    }
    drawPolyline( points, isFilled=false, isClosed=false ) {
        if ( points.length <= 1 )
            return;
        let x;
        let y;
        this.canvas_context.beginPath();
        x = points[0].x;
        y = points[0].y;
        if ( this.coordinateSystem === Draw2.WORLD ) {
            x = this.convertWorldSpaceUnitsToPixelsX( x );
            y = this.convertWorldSpaceUnitsToPixelsY( y );
        }
        this.canvas_context.moveTo(x,y);
        for ( let i = 1; i < points.length; ++i ) {
            x = points[i].x;
            y = points[i].y;
            if ( this.coordinateSystem === Draw2.WORLD ) {
                x = this.convertWorldSpaceUnitsToPixelsX( x );
                y = this.convertWorldSpaceUnitsToPixelsY( y );
            }
            this.canvas_context.lineTo(x,y);
        }
        if ( isClosed ) this.canvas_context.closePath();
        if ( isFilled ) this.canvas_context.fill();
        else this.canvas_context.stroke();
    }
    drawPolygon( points, isFilled=false ) {
        this.drawPolyline( points, isFilled, true );
    }
    fillPolygon( points ) {
        this.drawPolyline( points, true, true );
    }

    drawArrowHead(
        x, y, // the tip of the arrow
        direction_x,direction_y, // a vector; its length doesn't matter
        arrowHeadLength,
        isFilled = true,
        isStroked = true
    ) {
        // scale the direction vector to have the appropriate length
        let forwardVector = Vec2.mult( new Vec2(direction_x,direction_y).normalize(), arrowHeadLength );

        let tip = new Vec2( x, y );
        let back = Vec2.diff( tip, forwardVector );
        let lateralVector = new Vec2( forwardVector.y / 2, - forwardVector.x / 2 );
        let side1 = Vec2.diff( back, lateralVector );
        let side2 = Vec2.sum( back, lateralVector );
        if ( isFilled )
            this.drawPolygon( [ tip, side1, side2 ], true );
        if ( isStroked )
            this.drawPolygon( [ tip, side1, side2 ], false );
    }
    drawArithmeticOperator(
        x, y, // center
        diameter,
        symbol,
        isFilled = true,
        isStroked = true
    ) {
        let radius = diameter/2;
        let r2 = radius * 0.65;
        if ( isFilled )
            this.fillCircle( x, y, radius );
        if ( isStroked )
            this.drawCircle( x, y, radius );
        if ( symbol === "+" || symbol === "-" ) {
            this.drawLine( x-r2, y, x+r2, y );
        }
        if ( symbol === "+" ) {
            this.drawLine( x, y-r2, x, y+r2 );
        }
    }

    // TODO warning: I haven't bothered to make this handle rotations in the worldTransform
    // properly.  This would require rotating, but not translating, the tangent vectors,
    // and this could be done by transforming the control points.
    drawSpline(
        x1,y1, x2,y2, // endpoints
        tangent1x,tangent1y, tangent2x,tangent2y, // vectors; their length doesn't matter
        weight1, weight2, // determine how strongly the curve is influenced, after scaling by distance between the endpoints
        maxLateralExtent
    ) {
        let endpoint1 = new Vec2(x1,y1);
        let endpoint2 = new Vec2(x2,y2);
        let distanceBetweenEndpoints = Vec2.distance( endpoint1, endpoint2 );
        let t1 = Vec2.mult( new Vec2(tangent1x,tangent1y).normalize(), distanceBetweenEndpoints*weight1 );
        let t2 = Vec2.mult( new Vec2(tangent2x,tangent2y).normalize(), distanceBetweenEndpoints*weight2 );
        // control points
        let cp1x = x1 + t1.x;
        let cp1y = y1 + t1.y;
        let cp2x = x2 + t2.x;
        let cp2y = y2 + t2.y;

        if ( maxLateralExtent !== undefined ) {
            /*
                A point P(t) on a cubic bezier curve, where t is in [0,1], is given by
                    P(t) = (1-t)^3 (x1,y1) + 3(1-t)^2 t (cp1x,cp1y) + 3(1-t)t^2 (cp2x,cp2y) + t^3 (x2,y2)
                Setting t=0.5 yields
                    P(0.5) = (1/8) (x1,y1) + (3/8) (cp1x,cp1y) + (3/8) (cp2x,cp2y) + (1/8) (x2,y2)
            */
            let midpoint = Vec2.average( endpoint1, endpoint2 );
            let midcurve = new Vec2(
                ( x1 + 3*cp1x + 3*cp2x + x2 ) / 8,
                ( y1 + 3*cp1y + 3*cp2y + y2 ) / 8
            );
            let lateralExtent = Vec2.distance( midpoint, midcurve );
            if ( lateralExtent > maxLateralExtent ) {
                // The curve will extend laterally too far, so break it up into two smaller curves

                // Move the control points closer to the endpoints
                weight1 *= maxLateralExtent/lateralExtent;
                weight2 *= maxLateralExtent/lateralExtent;
                t1 = Vec2.mult( new Vec2(tangent1x,tangent1y).normalize(), distanceBetweenEndpoints*weight1 );
                t2 = Vec2.mult( new Vec2(tangent2x,tangent2y).normalize(), distanceBetweenEndpoints*weight2 );
                // recomputing the control points for the original endpoints
                cp1x = x1 + t1.x;
                cp1y = y1 + t1.y;
                cp2x = x2 + t2.x;
                cp2y = y2 + t2.y;
            }
        }

        if ( this.coordinateSystem === Draw2.WORLD ) {
            /*
            if ( this.hasWorldTransform ) {
                let p = this.applyTransformation(x1,y1);
                x1 = p.x;
                y1 = p.y;
                p = this.applyTransformation(x2,y2);
                x2 = p.x;
                y2 = p.y;
                ... need to also transform the control points
            }
            */
            endpoint1 = this.convertWorldSpaceUnitsToPixels( endpoint1 );
            endpoint2 = this.convertWorldSpaceUnitsToPixels( endpoint2 );
            cp1x = this.convertWorldSpaceUnitsToPixelsX( cp1x );
            cp1y = this.convertWorldSpaceUnitsToPixelsY( cp1y );
            cp2x = this.convertWorldSpaceUnitsToPixelsX( cp2x );
            cp2y = this.convertWorldSpaceUnitsToPixelsY( cp2y );
        }
        this.canvas_context.beginPath();
        this.canvas_context.moveTo( endpoint1.x,endpoint1.y );
        this.canvas_context.bezierCurveTo( cp1x,cp1y,cp2x,cp2y, endpoint2.x,endpoint2.y );
        this.canvas_context.stroke();
    }

    // returns the width of a string, in pixels
    stringWidth( s ) {
        if ( s.length === 0 ) return 0;
        return this.canvas_context.measureText(s).width;
    }

    // draws the given string using the current fill color
    drawString(
        x, y,  // left extremity of the baseline of the string (near the lower-left corner of the string)
        s,     // the string
        height, // the desired height
        direction // TD_HORIZONTALLY_RIGHT or TD_VERTICALLY_DOWN
    ) {
        if ( s.length === 0 ) return;
        //this.canvas_context.textBaseline = 'alphabetic';
        this.canvas_context.textBaseline = 'bottom';
        this.canvas_context.textAlign = 'start';
        if ( this.coordinateSystem === Draw2.WORLD ) {
            x = this.convertWorldSpaceUnitsToPixelsX( x );
            y = this.convertWorldSpaceUnitsToPixelsY( y );
            height /= this.scaleFactorInWorldSpaceUnitsPerPixel;
        }
        this.canvas_context.save();
        this.canvas_context.translate( x, y );
        let scaleFactor = height / this.fontHeight;
        this.canvas_context.scale( scaleFactor, scaleFactor );
        if ( direction === TD_VERTICALLY_DOWN ) {
            this.canvas_context.rotate(Math.PI/2);
        }
        this.canvas_context.fillText( s, 0, 0 );
        this.canvas_context.restore();
    }
    drawStringCenteredInRectangle(
        rect, // the bounding rect; the text is scaled to fit in this
        s,  // the string
        margin, // a fraction of the width or height; 0.0 for none
        direction, // TD_HORIZONTALLY_RIGHT or TD_VERTICALLY_DOWN

        // highlighting is done using a rectangle drawn in the current stroke color
        indexOfStartOfSubstringToHighlight = 0, // 0 for first char
        lengthOfSubstringToHighlight = 0 // 0 for none
    ) {
        if ( s.length === 0 ) return;
        if ( indexOfStartOfSubstringToHighlight < 0 || indexOfStartOfSubstringToHighlight >= s.length )
            lengthOfSubstringToHighlight = 0;

        let rect2 = rect;
        if ( this.coordinateSystem === Draw2.WORLD ) {
            rect2 = new Box2(
                this.convertWorldSpaceUnitsToPixels( rect.min ),
                this.convertWorldSpaceUnitsToPixels( rect.max )
            );
        }
        let textW = this.stringWidth( s );
        let textW_beforeSubstring = 0;
        let textW_untilEndOfSubstring = 0;
        if ( lengthOfSubstringToHighlight > 0 ) {
            textW_beforeSubstring = this.stringWidth( s.substring( 0, indexOfStartOfSubstringToHighlight ) );
            textW_untilEndOfSubstring = this.stringWidth( s.substring( 0, indexOfStartOfSubstringToHighlight + lengthOfSubstringToHighlight ) );
        }
        let textH = this.fontHeight;
        let textAspectRatio = textW / textH;
        let rectW = rect2.width();
        let rectH = rect2.height();
        let rectAspectRatio = rectW / rectH;
        this.canvas_context.textBaseline = 'middle';
        this.canvas_context.textAlign = 'center';
        let scaleFactor = 1;
        if ( direction === TD_HORIZONTALLY_RIGHT ) {
            if ( rectAspectRatio < textAspectRatio ) { // bounding rect is more tall and skinny than text
                scaleFactor = rectW / textW * (1-margin);
            }
            else { // bounding rect is more wide and short than text
                scaleFactor = rectH / textH * (1-margin);
            }
        }
        else if ( direction === TD_VERTICALLY_DOWN ) {
            textAspectRatio = 1 / textAspectRatio;
            if ( rectAspectRatio < textAspectRatio ) { // bounding rect is more tall and skinny than text
                scaleFactor = rectW / textH * (1-margin);
            }
            else { // bounding rect is more wide and short than text
                scaleFactor = rectH / textW * (1-margin);
            }
        }
        this.canvas_context.save();
        let center = rect2.center();
        this.canvas_context.translate( center.x, center.y );
        this.canvas_context.scale( scaleFactor, scaleFactor );
        if ( direction === TD_VERTICALLY_DOWN ) {
            this.canvas_context.rotate(Math.PI/2);
        }
        this.canvas_context.fillText( s, 0, 0 );
        if ( lengthOfSubstringToHighlight > 0 ) {
            this.canvas_context.strokeRect( -textW/2+textW_beforeSubstring, -textH/2, textW_untilEndOfSubstring-textW_beforeSubstring, textH );
        }
        this.canvas_context.restore();
    }

    drawImage( image, x, y, w, h ) {
        if ( this.coordinateSystem === Draw2.WORLD ) {
            if ( this.hasWorldTransform ) {
                let p = this.applyTransformation(x,y);
                x = p.x;
                y = p.y;
            }
            x = this.convertWorldSpaceUnitsToPixelsX( x );
            y = this.convertWorldSpaceUnitsToPixelsY( y );
            w /= this.scaleFactorInWorldSpaceUnitsPerPixel;
            h /= this.scaleFactorInWorldSpaceUnitsPerPixel;
        }
        this.canvas_context.drawImage(image, x, y, w, h );
    }
}



// ============================================================

// Creates an array filled with the given initialValue
let create1DArray = function( numElements, initialValue ) {
    let array = [];
    if ( initialValue === null ) {
        for ( let i = 0; i < numElements; i++ ) {
            array.push(null);
        }
    }
    else if ( typeof(initialValue) === 'object' ) {
        if ( initialValue instanceof Array ) {
            for ( let i = 0; i < numElements; i++ ) {
                array.push([...initialValue]);
            }
        }
        else {
            for ( let i = 0; i < numElements; i++ ) {
                array.push({...initialValue});
            }
        }
    }
    else {
        for ( let i = 0; i < numElements; i++ ) {
            array.push(initialValue);
        }
    }
    return array;
}

// Creates a 2D array filled with the given initialValue
let create2DArray = function( numColumns, numRows, initialValue ) {
    let array = [];
    if ( initialValue === null ) {
        for ( let c = 0; c < numColumns; c++ ) {
            array.push([]);
            for ( let r = 0; r < numRows; r++ ) {
                array[c].push(null);
            }
        }
    }
    else if ( typeof(initialValue) === 'object' ) {
        if ( initialValue instanceof Array ) {
            for ( let c = 0; c < numColumns; c++ ) {
                array.push([]); // adds an empty 1D array at the end of "array"
                for ( let r = 0; r < numRows; r++ ) {
                    array[c].push([...initialValue]); // added at end of the 1D array "array[c]"
                }
            }
        }
        else {
            for ( let c = 0; c < numColumns; c++ ) {
                array.push([]); // adds an empty 1D array at the end of "array"
                for ( let r = 0; r < numRows; r++ ) {
                    array[c].push({...initialValue}); // added at end of the 1D array "array[c]"
                }
            }
        }
    }
    else {
        for ( let c = 0; c < numColumns; c++ ) {
            array.push([]); // adds an empty 1D array at the end of "array"
            for ( let r = 0; r < numRows; r++ ) {
                array[c].push(initialValue); // added at end of the 1D array "array[c]"
            }
        }
    }


    return array;
}

// ============================================================


// ================================ FRONTEND

const SUPPRESS_GATES_THAT_DONT_WORK = false;

// The prefix CP means CircuitPart, which could be a gate, or part of a gate (like half a swap), or a control bit.
const CP_EMPTY = -1;
const CP_I = 0; // identity
const CP_CB = 1; // control bit
const CP_ACB = 2; // anticontrol bit
const CP_H = 3; // hadamard
const CP_X = 4; // NOT
const CP_Y = 5;
const CP_Z = 6;
const CP_SX = 7; // "SX" means "Square root of X"
const CP_SY = 8; // "SY" means "Square root of Y"
const CP_SZ = 9; // "SZ" means "Square root of Z"
const CP_SSX = 10; // "SSX" means "Square root of Square root of X", or in other words, fourth root of X
const CP_SSY = 11; // "SSY" means "Square root of Square root of Y", or in other words, fourth root of Y
const CP_SSZ = 12; // "SSZ" means "Square root of Square root of Z", or in other words, fourth root of Z
const CP_invSX = 13; // "inv" means inverse
const CP_invSY = 14;
const CP_invSZ = 15;
const CP_invSSX = 16;
const CP_invSSY = 17;
const CP_invSSZ = 18;
const CP_SWAP = 19;
const CP_XE = 20;
const CP_YE = 21;
const CP_ZE = 22;
const CP_RX = 23;
const CP_RY = 24;
const CP_RZ = 25;
const CP_GP = 26;
const CP_PH = 27;
const CP_ZG = 28;
const CP_YG = 29;
const CP_HG = 30;
const CP_NUM = SUPPRESS_GATES_THAT_DONT_WORK ? 20 : 31;

class Icon {
    constructor(
        circuitPart_id,
        name, // string
        tooltip, // string
        isParametric, // boolean
        parametersAreInDegrees, // boolean
        matrix, // a 2x2 complex matrix; only for gates that *are* parametric, and hence have a fixed matrix

        // A function that takes one or more parameters and returns a 2x2 complex matrix; only for parametric gates.
        parametricFunctionToGenerateMatrix,

        // Only for parametric gates.
        // An array of objects of the form {
        //    name: ...,
        //    defaultValue: ...,
        //    minValue: ...,
        //    maxValue: ...,
        //    dragIncrement: ...,
        //    snapIncrement: ...
        // }
        paramInfo,

        // This is not provided to the constructor
        // ,imageSource
    ) {
        this.circuitPart_id = circuitPart_id;
        this.name = name;
        this.tooltip = tooltip;
        this.isParametric = isParametric;
        this.parametersAreInDegrees = parametersAreInDegrees;
        this.matrix = matrix;
        this.parametricFunctionToGenerateMatrix = parametricFunctionToGenerateMatrix;
        this.paramInfo = paramInfo;
        this.numParameters = paramInfo.length;

        this.image = new Image();

        // We don't do this in the constructor, because it would cause
        // the image to load asynchronously in a different thread,
        // so it's better for the client to do this using a Promise
        // so the client can be informed when the image is loaded and ready.
        // this.image.src = imageSource;
    }
    circuitPartFactory() {
        let cp = new CircuitPart();
        cp.parentIcon = this;
        cp.paramValues = [ ];
        for ( let i = 0; i < this.numParameters; ++i ) {
            cp.paramValues[ i ] = this.paramInfo[ i ].defaultValue;
        }
        return cp;
    }
};

let icons = [];
let icon_promises = [];

function appendToIcons(
    circuitPart_id,
    name,
    tooltip,
    isParametric,
    parametersAreInDegrees,
    matrix,
    parametricFunctionToGenerateMatrix,
    paramInfo,
    imageSource
) {
    let icon = new Icon( circuitPart_id, name, tooltip, isParametric, parametersAreInDegrees, matrix, parametricFunctionToGenerateMatrix, paramInfo );
    icons.push( icon );
    Util.assert( icons.length-1 === circuitPart_id, "appendToIcons(): invalid index" );
    icon_promises.push( new Promise( function(resolve,reject) {
        icon.image.onload = resolve;
        icon.image.onerror = reject;
        icon.image.src = imageSource;
    } ) );
}

const imageSourcePrefix = "data:image/png;base64,";

appendToIcons(
    CP_I, "I", "Identity", false, false, Sim.I, null, [],
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_CB, "Control bit", "Control bit", false, false, null, null, [ ],
    imageSourcePrefix+
"iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TRdGKoB1EHDJUQbGLijiWKhbBQmkrtOpgcukXNGlIUlwcBdeCgx+LVQcXZ10dXAVB8APEXXBSdJES/5cUWsR4cNyPd/ced+8AoV5mqtkRAVTNMpKxqJjJropdrxDQiwGMY0Jiph5PLabhOb7u4ePrXZhneZ/7c/QpOZMBPpE4wnTDIt4gnt20dM77xEFWlBTic+JJgy5I/Mh12eU3zgWHBZ4ZNNLJeeIgsVhoY7mNWdFQiWeIQ4qqUb6QcVnhvMVZLVdZ8578hYGctpLiOs0RxLCEOBIQIaOKEsqwEKZVI8VEkvajHv5hx58gl0yuEhg5FlCBCsnxg//B727N/PSUmxSIAp0vtv0xCnTtAo2abX8f23bjBPA/A1day1+pA3OfpNdaWugI6N8GLq5bmrwHXO4AQ0+6ZEiO5Kcp5PPA+xl9UxYYvAV61tzemvs4fQDS1NXyDXBwCIwVKHvd493d7b39e6bZ3w/c2XLRMDVo6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB+kCDAEzCtj16isAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAABm0lEQVR42u3cO27CQBAG4D+POlUq6oiKjhpxkRwgR0mLOAJlThGlzgUiQckBaFFCihgJ0USJjL3Wfp80FcIePGPjx3oTAAAAAAAAAAAAAAAAAAAAAAAAAAAAoE9XFf3WeZJZkmmScZJRkrvms12SbZKPJO9J3pK8ao/hmyR5TrJOcvhjrJvvTmzG4RknWSbZ/6Pw57FvljW2WYfhKcmmhcKfx6ZZNoW6T7K4QOHPY9Gsi4I8JFl1UPxjrJp1Usie32XxT5vAkaAAix6Kf/p3QM8nfIeew4lhj5d6mwIaYOMSsR/LAop/jKVydGvS0k2etmKfgd4xvB5oAzwmuS0on9smJzqyLmjvP312QAfmBRb/GHN/AZc3k1vdDTCVW90NMJZb3Q0wklt7hjgk7LPgxv1KcuMIgAa4oJ3c6m6ArdzqboAPudXdAO9yq7sB3uSGh0GVXwa+yKluBoRgSFjtDArFsHC8GFI9r4bh5VC8Hs7JiaEJIlwimiIGk0T9yjRxP0wTBwAAAAAAAAAAAAAAAAAAAAAAAAAAAPTiG7ZI8ww+RAqnAAAAAElFTkSuQmCC"
);
appendToIcons(
    CP_ACB, "Anticontrol bit", "Anticontrol bit", false, false, null, null, [ ],
    imageSourcePrefix+
"iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TRdGKoB1EHDJUQbGLijiWKhbBQmkrtOpgcukXNGlIUlwcBdeCgx+LVQcXZ10dXAVB8APEXXBSdJES/5cUWsR4cNyPd/ced+8AoV5mqtkRAVTNMpKxqJjJropdrxDQiwGMY0Jiph5PLabhOb7u4ePrXZhneZ/7c/QpOZMBPpE4wnTDIt4gnt20dM77xEFWlBTic+JJgy5I/Mh12eU3zgWHBZ4ZNNLJeeIgsVhoY7mNWdFQiWeIQ4qqUb6QcVnhvMVZLVdZ8578hYGctpLiOs0RxLCEOBIQIaOKEsqwEKZVI8VEkvajHv5hx58gl0yuEhg5FlCBCsnxg//B727N/PSUmxSIAp0vtv0xCnTtAo2abX8f23bjBPA/A1day1+pA3OfpNdaWugI6N8GLq5bmrwHXO4AQ0+6ZEiO5Kcp5PPA+xl9UxYYvAV61tzemvs4fQDS1NXyDXBwCIwVKHvd493d7b39e6bZ3w/c2XLRMDVo6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB+kCDAEzIXRJE2sAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAACt0lEQVR42u3cwWqjQBzH8V+79z2UxUMvvSw59ZZeS16njxLwYukjdPEW36Gsx/YFAhaKUPASUJEe2nX2UBeWVCdJGyeRfD/gZST5T5y/44xxlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwC4dHdBvnUi6lDSWNJJ0Kul7s6+Q9CxpLulB0m9Jd6TH8J1LmkpKJJkNt6T57DmHcXhGkm4kvX6i4Ze31+a7RhzWYbiS9LiFhl/eHpvvxp76Iem6h4Zf3q6bWNgjPyXdOmj8f9ttExN7cuav1fhBEJg4jk2apqaqKlPXtanr2lRVZdI0NXEcmyAINkkCeoI9sLLbn81mJssys64sy8xsNlv3coAdD/g6G8j3fZMkifmsJEmM7/urkoCB4Q6nep2j/TAMTZ7n5qvyPDdhGK6aHTBF3IEbW+OXZWm2pSzLVUlwQ3O4dd51k8f3/a2c+W09geVy8CruGDo17Tobv3LNX2dMYOkFpjSLO0nXaL9vltlBQrO4Mek6CzeZ6n1WlmW2XmAytIN5PMAEuGwrDIJAnuf1HtzzPAVBsFHdSIDtGrcVXlxcOKuAJdaYBHAz///g7OzMWQUssUYkQP9O2wpPTk6cVcAS63RoB3OIj4T9aUvcuq51dOTm5xhjdHzceu7Ukr7RA4AE6FHRVvjy8uKsApZYBQnQv+e2wsVi4awClljPJED/5m2FT09PzipgiTUnAfr30FZ4f3/vrAKWWA+MKvrHreAD7wHu9P4QxgdxHPce3BLjUawmcoa/gw/8PsAvSW9tO6IoUlFsfzZWFIWiKOra/dbUCQ7xSNiB46FQ8Fg4WBhy8FgaBhaHguXh+G9gyAsimCLyihjwkqiVeE3cO14TBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAduIvSgDcBqz++SAAAAAASUVORK5CYII="
);
appendToIcons(
    CP_H, "H", "Hadamard", false, false, Sim.H, null, [ ],
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_X, "X", "Pauli X; also called NOT", false, false, Sim.X, null, [ ],
    imageSourcePrefix+
"iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TRdGKoB1EHDJUQbGLijiWKhbBQmkrtOpgcukXNGlIUlwcBdeCgx+LVQcXZ10dXAVB8APEXXBSdJES/5cUWsR4cNyPd/ced+8AoV5mqtkRAVTNMpKxqJjJropdrxDQiwGMY0Jiph5PLabhOb7u4ePrXZhneZ/7c/QpOZMBPpE4wnTDIt4gnt20dM77xEFWlBTic+JJgy5I/Mh12eU3zgWHBZ4ZNNLJeeIgsVhoY7mNWdFQiWeIQ4qqUb6QcVnhvMVZLVdZ8578hYGctpLiOs0RxLCEOBIQIaOKEsqwEKZVI8VEkvajHv5hx58gl0yuEhg5FlCBCsnxg//B727N/PSUmxSIAp0vtv0xCnTtAo2abX8f23bjBPA/A1day1+pA3OfpNdaWugI6N8GLq5bmrwHXO4AQ0+6ZEiO5Kcp5PPA+xl9UxYYvAV61tzemvs4fQDS1NXyDXBwCIwVKHvd493d7b39e6bZ3w/c2XLRMDVo6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB+kCDAEzOBAiu6sAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAI4ElEQVR42u2c2U9TWxuHf7SUqVUgFKhQplAIlAIW4sQk0BgSg8iVQ0IYNNx74aV/gNEEvRAiJEdUUMKNI3DhwCRThJbQGLEhWClTAUMplLaU0n0uvrDzNcCBw/flHNq+T8LN6to7dL0Pi73W++4FEARBEARBEARBEAThKXgdoA9Dw+S+MebQ+Hg2JAAJQJAABAlAeCbeh72QYWhxcKQe9b28aAYgSACCBCBIAIIEIEgAggQgSACCBCBIAIIEIEgAggQgSACCBCBIAIIEIEgAEoCGgAQgSACCBCBIAIIEIEgAggQgSACCBCBIAIIEINwab3f5ImazGSMjI9BoNODz+RCJRPD19d3Rz2q1YmZmBiaTCVwuF3K5HKmpqQgICNjRd2trCxqNBiqVCkajEXw+H2KxGP7+/mwfh8OBubk5LC8vQyAQIDs7G9HR0fD29iYB/km0Wi0ePXqEkZER8Hg8BAQEgMvl7hrUtbU1bG5ugsPhoKSkBLdu3UJcXNyOvuvr62hqasL79++xtrYGHo8HgUDgFFyGYbC+vg6r1YqAgADcuXMHYWFhEAgELjFuhz4m7qgdELGysgKlUgm9Xg+73Y6JiQm0trbi58+fcDgcTn3j4+NRVFSEzMxMpKSkICUlZdeAbW5uQqlUYmRkBC9evMDo6Cg2NjbYzwMCAnDq1Cnk5uYiLi4OwcHBOHnyJKKiov7xGeAvDojw+l/vzez2cxSx2+3MxsYGY7FYmPn5eaampoaJiYlx+r1lMhnT2NjIaLVaxmw2Mw6HY997rqysMH/88QcjkUgYAIyvry9z5coVprm5mVEqlYxer2fMZjNjt9v/te++V5w85l8AAHC5XHbaF4lEuHz5Mrq7u7GwsACr1cr+VUdGRiIyMhI8Hu9A9wwMDGT7Jicno7KyEhcvXoREIoGfnx+tAo4qUVFRyM/Ph1AoZNt0Oh1GR0dhNBoPfJ/x8XG8fv0aISEhuH37NqqqqiCVSl0++G4vAI/Hw/nz5xEbG8vODBaLBZ2dnZient7xbLAbs7OzqKurw9LSEqqrq1FSUgKhUAgOxz2Gzu33ARITE3HmzBkEBQWxbcPDwxgbG4PZbN43+DU1NVAqlSgrK0NJSQlCQkIOfSIXCfAvwOfzoVAoEBERwbYZDAb09vZiYWFhz+t+//6N+vp6DA8Po6ysDKWlpRAKhW4VfI8QwMvLCxkZGUhLSwOfz2eXsH19ffjx44fTsu6/l5T19fX48OEDiouLUVpairCwMLcLvkcIAABCoRCFhYUIDw9n26ampjA0NASDweDUd3V1FU+ePEFbWxuKi4tx9epVhIeHu2XwPUYALpeLrKw"
+"sSCQSdjlns9nQ1dUFrVaLra0tAP/ZJm5paUFraytyc3Nx7do1iMXiXXcUSQAXIzY2FtnZ2QgJCWHbxsbGoFKpsLa2BqvViubmZjx9+hQ5OTmorKxETEyMWwffowTw8/NDYWEhxGIxO52bTCZ0dXVBp9Ohra0Nzc3NyMjIQEVFBRISEg60UeTqeMODSElJQWZmJiYmJtiNoP7+fty9exeTk5OQyWSoqqpCUlKSRwTfo2YAAAgMDERRUZHTknBxcRFtbW1ISEhAdXU1UlNT4ePj4zFj4lECcDgcnD17FnK5nF0SOhwOeHl5IS8vD1KpdNcaAhLAjQgLC4NCoXBaElqtVszOzsJisXjacHieAFwuFzExMTh27BjbZrPZMDAwgNnZ2QPlB0gAF2Z8fBzPnj3D1NSUU7tKpYJard43P0ACuDDT09Oora2FXq9HWVkZJBIJ+9lB8gO0DHRhZmdn8eDBA6hUKty8eRNZWVkwGAyYn5/H+vq6U35ALBZ7zMOgR8wAer0etbW1bGavuLgYEokECoUCIpGI7bdXfoAEcGGMRiMaGhrw6dMnXLp0ic3sbReLyGQytrLHZrOhs7MTk5OTsNvtJIA7BP/x48dob29HSUnJjszedslYaGgoe41arcbg4ODfKhkjAY4gFosFL1++xJs3b6BQKHD9+vUdmT0ej4e8vDynkjGTyYTPnz9Dp9N5xJLQLQXYzuw9f/4cOTk5KC8v3zOzl5iYiNOnTzuVjH39+vVAJWMkwBHEZrPh7du3aGpqwrlz51BZWYn4+Pg9X9TYLhk7ceKE05Kwp6fHI5aEbiXA1tYWOjo60NDQAKlUioqKCiQmJv5lZm+7ZCw9Pd2pZKy/v3/PkjES4IgG/+PHj6itrUVsbCxu3LiB5OTkA6V1hUIhCgoKdpSMDQ4OYnl5mQRwleA/fPgQUVFRqK6uRnp6+oHTulwuF9nZ2TtKxrq7u/Hr1y+2ZIwEOILY7Xa8e/cO9+/fh6+vL8rLyyGXy//2Tt5eJWNKpRJra2skwFFkdXUVjY2NuHfvHtRqNQoLC5Genn6obVw/Pz8UFBTsKBnr7u7G3NzckXsb+v+FS+YCjEYjent78erVK3z58gXT09PgcDjg8XiHfmXLbrfDYDDsqAno6elBX18fIiMjERgY6HYCuMT5ADMzMxgYGMDExAS0Wi30ej2mpqag1Wqxvr7OPs2npKQgNzcXFy5cQH5+PoKDg/cN+uDgIIaGhqBWq/H9+3doNBr2ntskJSVBLpdDKpUiKCgIoaGhyMvLg0gkOjLvCxz2fACXmAFGRkZQV1cHjUYDi8UCLpcLDocDf39/+Pv7w263w2Qy4du3b9DpdLDZbEhLS9tXAIPBgJaWFnR0dECv12NjYwMCgWDH+39LS0tob29HV1cXfHx8kJSUhOjoaISFhbl82bhLzAA6nQ4ajQZmsxlcLhc8Hs8pQA6HA5ubm+zWbUREBJKTk/c9psVisUCtVmNxcZG91sfHZ9eg2mw2djVw/PhxyGSyI/Wu4GFnALc5IsbTOawAdEych0MCkAAECUCQAAQJQJAABAlAkAAECUCQAAQJQJAABAlAkAAECUCQAAQJQJAABAlAkAAECUCQAAQJQJAABAlAkAAECUCQAAQJQJAAhKtw6PMBCPeIMc0A9C+AIAEIEoAgAQiCIAiCIAiCIAiCIAg35k8tHJo2triJNQAAAABJRU5ErkJggg=="
);
appendToIcons(
    CP_Y, "Y", "Pauli Y", false, false, Sim.Y, null, [ ],
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_Z, "Z", "Pauli Z = Phase(pi)", false, false, Sim.Z, null, [ ],
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_SX, "X^0.5", "X^0.5; also called V", false, false, Sim.SX, null, [ ],
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_SY, "Y^0.5", "Y^0.5", false, false, Sim.SY, null, [ ],
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_SZ, "Z^0.5", "Z^0.5; also called S = Phase(pi/2)", false, false, Sim.SZ, null, [ ],
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_SSX, "X^0.25", "X^0.25", false, false, Sim.SSX, null, [ ],
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_SSY, "Y^0.25", "Y^0.25", false, false, Sim.SSY, null, [ ],
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_SSZ, "Z^0.25", "Z^0.25; also called T = Phase(pi/4)", false, false, Sim.SSZ, null, [ ],
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_invSX, "X^-0.5", "X^-0.5; also called V^-1", false, false, Sim.invSX, null, [ ],
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_invSY, "Y^-0.5", "Y^-0.5", false, false, Sim.invSY, null, [ ],
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_invSZ, "Z^-0.5", "Z^-0.5; also called S^-1 = Phase(-pi/2)", false, false, Sim.invSZ, null, [ ],
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_invSSX, "X^-0.25", "X^-0.25", false, false, Sim.invSSX, null, [ ],
    imageSourcePrefix+
"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"
+"=="
);
appendToIcons(
    CP_invSSY, "Y^-0.25", "Y^-0.25", false, false, Sim.invSSY, null, [ ],
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_invSSZ, "Z^-0.25", "Z^-0.25; also called T^-1 = Phase(-pi/4)", false, false, Sim.invSSZ, null, [ ],
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_SWAP, "Swap", "Swap", false, false, null, null, [ ],
    imageSourcePrefix+
"iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TRdGKoB1EHDJUQbGLijiWKhbBQmkrtOpgcukXNGlIUlwcBdeCgx+LVQcXZ10dXAVB8APEXXBSdJES/5cUWsR4cNyPd/ced+8AoV5mqtkRAVTNMpKxqJjJropdrxDQiwGMY0Jiph5PLabhOb7u4ePrXZhneZ/7c/QpOZMBPpE4wnTDIt4gnt20dM77xEFWlBTic+JJgy5I/Mh12eU3zgWHBZ4ZNNLJeeIgsVhoY7mNWdFQiWeIQ4qqUb6QcVnhvMVZLVdZ8578hYGctpLiOs0RxLCEOBIQIaOKEsqwEKZVI8VEkvajHv5hx58gl0yuEhg5FlCBCsnxg//B727N/PSUmxSIAp0vtv0xCnTtAo2abX8f23bjBPA/A1day1+pA3OfpNdaWugI6N8GLq5bmrwHXO4AQ0+6ZEiO5Kcp5PPA+xl9UxYYvAV61tzemvs4fQDS1NXyDXBwCIwVKHvd493d7b39e6bZ3w/c2XLRMDVo6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB+kCDAIFBy0euboAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAACc0lEQVR42u3dS1LbQBiF0SbFkN1kAz3NMFle1pqUswKIHi3pf5yvihnGku4pY5sCxpAkSZIkSV162/A5L5ep7sbfXJ/eAQCAABAA6tn7xa8gdF8vjwACQAAIAAEgAASAABAAAkAACAABIAAEgAAQAAIAAAEgAARAmF6ffMxE13V+cR7puvtEXskRzP+cQ7qdIgGIjmBuOH4ATgKIimBuPHYAFgCIhmDuOG4AFgGIgmDuPGYAFl/QmWj8CUAdBNGOsRSA6AgiHls5AFEvdFSYJQFEu+CRH5XKAohy4aM/LykN4OkBMjwpLQ/gqSGyvCxtAeDuQTK9J9EGwF3DZBq/HYCrB8o2fksAVw2Vcfy2AFYPlnX81gBWDZd5/PYAzg6YfXwATgz5q8D4AJxAUGF8AG5AMIOfMwAXIpgJzheAixDMJOcKwAUIZqLzBOCLfhQf//BOHX459GOM8XOo5SPAxxjjt28BPQGcHd+TwMQAVo3vZWBCAKvH90ZQIgB7x/87vBVcBsDe8f+MMb6PGj8JbA/g6PhH3yyaANQZvwqClgBWjV8BQTsAq8fPjqAVgKvGz4ygDYCrx8+KoAWAu8bPiKA8gLvHz4agNICnxs+EoCyAp8fPgqAkgCjjZ0BQDkC08aMjKAUg6viREZQBEH38qAjKAMgwfkQE7f5Y9NPjH0UAwAIAUcY/ggCAkwCijb8XAQAnAEQdfw8CAA7eX/TxtyIA4MD9ZRl/C4JQAN42fuGjt9V9HdrJfw5tHgAACAABIAAEgAAQAAJAAAgAASAABIAAEAACQAAIAAGgGr2fuO3L5fMIIAAEgAAQAJIkSZIkSQrcP3bjBfOXegYhAAAAAElFTkSuQmCC"
);

if ( ! SUPPRESS_GATES_THAT_DONT_WORK ) {

const exponentParamInfo = [{name:"k", defaultValue:0, minValue:-2, maxValue:2, dragIncrement:0.01, snapIncrement:0.125}];
const singleAngleParamInfo = [{name:"angle", defaultValue:0, minValue:-360, maxValue:360, dragIncrement:1, snapIncrement:22.5}];
const twoAngleParamInfo = [{name:"angle1", defaultValue:0, minValue:-360, maxValue:360, dragIncrement:1, snapIncrement:22.5},  {name:"angle2", defaultValue:0, minValue:-360, maxValue:360, dragIncrement:1, snapIncrement:22.5}];

appendToIcons(
    CP_XE, "X^k", "Pauli X exponential", true, false, null, Sim.XE, exponentParamInfo,
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_YE, "Y^k", "Pauli Y exponential", true, false, null, Sim.YE, exponentParamInfo,
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_ZE, "Z^k", "Pauli Z exponential; Z^k = Phase(k pi)", true, false, null, Sim.ZE, exponentParamInfo,
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_RX, "Rx", "Rotation around X", true, true, null, Sim.RX, singleAngleParamInfo,
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_RY, "Ry", "Rotation around Y", true, true, null, Sim.RY, singleAngleParamInfo,
    imageSourcePrefix+
"iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TRdGKoB1EHDJUQbGLijiWKhbBQmkrtOpgcukXNGlIUlwcBdeCgx+LVQcXZ10dXAVB8APEXXBSdJES/5cUWsR4cNyPd/ced+8AoV5mqtkRAVTNMpKxqJjJropdrxDQiwGMY0Jiph5PLabhOb7u4ePrXZhneZ/7c/QpOZMBPpE4wnTDIt4gnt20dM77xEFWlBTic+JJgy5I/Mh12eU3zgWHBZ4ZNNLJeeIgsVhoY7mNWdFQiWeIQ4qqUb6QcVnhvMVZLVdZ8578hYGctpLiOs0RxLCEOBIQIaOKEsqwEKZVI8VEkvajHv5hx58gl0yuEhg5FlCBCsnxg//B727N/PSUmxSIAp0vtv0xCnTtAo2abX8f23bjBPA/A1day1+pA3OfpNdaWugI6N8GLq5bmrwHXO4AQ0+6ZEiO5Kcp5PPA+xl9UxYYvAV61tzemvs4fQDS1NXyDXBwCIwVKHvd493d7b39e6bZ3w/c2XLRMDVo6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB+kCDAICC2vpY1YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAANcklEQVR42u2d62+TZ5qHL58Sx3acOE5Sx87Jdk4cmnAoBDJFnSWDCjMsGmna9LRSASFmdtXufhlp/4SdL1tppHaW1X7YWbqi2tIiurBQjlJmKAwDbBIIOZADIU5CEsfgBMdOHL9+9wODt4RA68yU2sl9SXyJiJP4ud77dz/3+7wJCIIgCIIgCIIgCIKwXNB8i/+jytu0dNdYK+/P8kYEEAEEEUAQAYTliX6xn6iqsjlIqVZfo5EKIIgAggggiACCCCCIAIIIIIgAggggiACCCCCIAIIIIIgAggggiACCCCCIACKAvAUigCACCCKAsCzRp8s3qqoqgUCA69ev09vbSzQaTfo1jEYjDoeDvLw8cnJycDqdWK1WdDqdCJDqzM3NcfXqVT744AP6+vqIxWLJ/7B6PVlZWRiNRjIzMzGZTNjtdjZu3Mj27duprKzEYDAsKwEW/Xj4834wRFEU7t69S1tbG8FgkFgshs/n48SJE1y5ciUhRElJCbt27WLdunULLubs7CxDQ0O0trZy7do1/H4/+fn5VFdXs3XrVpqamvB6vWi16ZWOz3gwRLMkKoBOp8PlclFUVEQsFkNVVXw+HxMTE7S0tBCLxcjMzGTt2rXs3buXmpqaBUu7oiiEQiEmJiYYHBzkwoULHD58mAsXLtDR0UFXVxf79u2joaFhWVQDfbpZrtPpEgurqiqhUChRjXJycli9ejUej4esrKynXhUmk4nCwkKqq6tZvXo1BQUFfPjhh/T39/PFF18QDofRaDQ0NDSg1+tFgFQkHo/j9/sZGBhAURQA7HY71dXVz1z8+VXF6XSybds22tra8Pl8PHjwgObmZkpLS6msrMThcCz6uTvZBn6HRKNRfD4fAwMDxONxNBoNdrsdr9ebVFev1WoT1SAzMxOAYDDIlStX6OzsTMglAqQY09PTDA4O4vf7icfjZGZmUlJSgsvlSrqBMxgMmM1mDAYDGo0GRVEYGxujp6dHBEhVAoEAPT09zM7OJvLf4/Fgs9mSFkBV1cS/r+8WJicnicfjIkCq5v/t27cTV2heXh5VVVUYjcakXy8cDjM2Nsbs7GxCAq1Wuyx2AWkpwEL5n5+fn3T+z68mc3NziY/ZbDbcbveS3wWkpQDz8z8jIwOn00lRUVHS5T8ajXL79m1u3ryZGCaZTCZqampYtWrVkh8Tp6UAC+V/RUUFeXl5SW/Z/H4/ly9fxufzJfLe4/Gwc+fORTWUIsD3lP8VFRXfev//9UavtbWVs2fPMj09DUBZWRnvvPMOjY2NZGVlLfkeIO0C7mn5X1FRkVS5jsVi3Lhxg4MHD9LR0UE8Hsfj8bB//37efPN"
+"NCgsLl/QAKG0FWGj/73K5cDqd37pcRyIRLl68yIEDBzh//jyKorBlyxb27dtHY2MjDodjyZf+tBXgz8n/mZkZ2tvbOXLkCKdPn6a/v5/S0lKamprYunUrq1atwmKxLIsrPy0FWCj/MzIyiEajtLS0kJGRsWDO+3w+Ojo66OnpYWRkhGAwSE1NDXv27KG2tpaamhrsdvuyuerTVoD5+Q8wNTXF2bNnuX79+hNX7tdv/QYCAfR6Pa+88grvv/8+tbW1lJWVYbFYluXCp6UA8/PfZDKxZcsW3n33XXJzc58QQFVVotEoIyMjnDp1iubmZlpbW7FYLLhcLqqrq5f14qedAPPzPzs7m/Xr1/Pqq69itVoX/BxVVQmHw6xfvx6Px8PHH3/M559/zujoKPv372fHjh2Ju4AiQBru/71e7zMXUKPRYDabqa2tRVEU+vr6OHbsGM3NzRiNRkpKSlizZs2yPRiaNvXvz53/6/V63G439fX1WCwWIpEIV69e5cyZM4+dKhIB0mj/X1xcnNS41mQy4XA4MJlMwMMxcGtrK4FAQARIt/y3Wq14vd6k7v8rikIkEknc9YvFYkxNTRGJRJZtD5AWAiyU/3a7ncrKyqTu/0ciEcbHxwmHw4krfv5BEBFgCeb/I4LBIAMDA4kKoNPpyM7OTkSCCLCE819RFEZHR+nt7U1UEYPBgNVqTfouomwD0zD/o9Eow8PDj933z8jIwGq1JjUHiIbGab90nM+OnqVrJIwx183mba/xs531OLL1aBf0KMqEr5srf+hC61rHlo1uTHqtCPA88z8cDjM0NEQgEEgI8OgBEaPR+K0qQDTYS/OxQxw+H8C76cf89MVhLp0+wr/+eoR7wfd4b+9m8oz6J57FCg7e4Pi//YqPjvZTvvl18sr/nnVFJnQaEeC55f/U1BQ+ny9RRR71AFlZWQtWkUgkQjAYxGQyYbVaUaNjtPz+BP9zfpS6n+xm19Za8iLXiQ2d49DZ85w6VUTDj9bxwwo9hsdebgb/YBcXz1ygvVPF7A6jSaGzpinfA/wl8v+RSI9O/Xx9LrBQjMTjcbq6ujh48CDXrl0jFoswequF351uRevezq7GNRTbjMxFIkz6A8Sik0xNjhAIKczfUKjRIGN3++gcmEZnyeeF0hUUZj0tKkSA7yT/4eFIeH6Z1+l0C+Z/KBSitbWVGzdukJmZiTp7l862y3T4c/jBj+t5wWpAowkzOjxA29VhFMVOfu5Kyp16dPO+pbnJMYZvtdITmsVcWEBF3QpyDTo0UgG+mdnZWTo7O/90FT48sZudnY3T6Uz6Bo7VasXlcn3jWX9VVRkYGKClpQW3201lZSVK6B5+/wMMpRtYW5GLXqdBmRqhp+Miv++fwphfTM2aeipyDE9c2aGJe9zpvsWDuTi5+Tl4VjjJ1KXO254yPcD09DTt7e20tbURjUZ58OABvb29tLW10d3dnWjcxsbGOHToED6fj6KiosRj45s3b6agoOCpzZzNZmPt2rW43W46OjoSU8H79+8/NhQaGhri+PHjTE1N8cYbbzysNIqBl3ftZZVSgCvbgJY4o4O3udr8FaNhKFnhpb6xjmzD/AYwzNjYHW7e8KMouRTk1VDjMaPTaUSA+UxMTHD8+HE+/fRTZmZmUBQl8WtgTCZTYlijqio3b96ku7s70cBt3rwZt9uN3W5/amOYkZFBfX09e/bs4cCBA/T29jI+Ps6lS5dobGzE5XLR2dnJJ598wtDQEE1NTdTV1aHX69EYbBR7bRQnmoQAvjtt/PHyMHFtPuWe9by0woZ+3sKq0UkmxgboGQ6jt5ThKq+jxGoghdY/dQTIz8/ntddeY+PGjcTjcbRaLXq9fsEFjcViiWneo6eCS0tLn9kTaDQaCgsLeeuttygvL+fkyZOcO3eOM2fOMDg4iMlkQqvV4vF42L17N5s2bcJsNi9YUaL37zJw4wptExFMBStZUddAieXJhZ2bHGek7zr94ShmZwHeFMv/lBLAbDZTV1dHXV3dd/Y1dDodDoeDHTt2UFdXx9tvv00wGCQSia"
+"DRaLDZbJSXl1NWVvbMGUPw7hidLTcIRqGsuJi6TZVk6Z8UNTQR4E7Xw/wvzs/Bm2L5nzaTwL80RqMRj8eDx+MhHo8Ti8XQaDQPy/03DoRmuB8Y4U5vAFWxUZBfQ02V5YnyDzMEJkbo7Z4gnqL5v2wFeGwbpNUueJr4GTNFJkNj+EZn0GS4yC/w4DDrmO/Nw/1/P52DYfTZ5ZRXrMObk1r5nxZzgJQkDnEFtHoDhkwTBjRP5Hpo3EfH/17g1tQMpkI75S9Wk61PrfwXARbXrZCT66S01AjqHHPRaeZQH/tdetGQj2u/+4LDR1u4P6PBXlBI1Uonel3qvd0iQNJk4KpYyZbtL5OnGWfwzmXaekMoigrEidzr4fxnv+FX/3yIP/TdQ4nnYLdVUOU2pVz+Sw+wKDSYC6r40eu/YDwQ4/DpL/mnf7zPmdoK7PpJbvePo7OYKaryYukYIm5+gTJvHeXZqZf/IsBiFdCbcFb/gN2/dFD/kx6Gx/1MhuJkmFaweqONgqxpOpr/g2NayCkqoGLNKqx6Pal45EQESLoBjBGLKcS1WbzgfpHCspVEZ6aZnp5FNWRhsRgYbz3JibYupufMlBZVs259EQZ9ap44EgGSIBrs56tTh/j3z1owezbz+u6fs6Uqm0yTlcw/HStUwoN0t1/gXMsYxrxK1jXsYENZ9gJzAmkC04wwdzov8+m//JYjR/+bL880c73vPkpcfWz4M9R5hS8Pn2QgUsi6H77B37zdQIElNcu/CJAUEe75B7nV5WdOY8PhWskqTzb/f6tihrsdzfzXR7/h6JVJvBv+ml+818SGqjz02tQ9cCoRkMT+32ZzUVntQTFv5R9+uZsNHit6rQYlGqTn2pf89tcfceLqPSoaf87f/t3rvPJSacoc/nz6nuabSYm/F/D9oxK5d4evjn7Mf372FdN2N9VVXsxqEF9fOz2DAbQWD3+182dse/klVlY5yDI8v8Vf7N8LEAGSciBG6N4I3e3t9A6O8SA0w6yiojWYKHA4cJa4qaxwk5+dwfN+zEAEeJ4exBWiM9OEQmGiqo5MowWrxfi9dvoiwDJnsQLILmCZIwKIAIIIIIgAggggiACCCCCIAIIIIIgAggggiACCCCCIAIIIIIgAggggiACCCCCIAIIIIIgAQrqz6OcChKWxxlIBJAIEEUAQAQQRQBAEQRAEQRAEQRAEQVjC/B+S9v/CajJD3wAAAABJRU5ErkJggg=="
);
appendToIcons(
    CP_RZ, "Rz", "Rotation around Z", true, true, null, Sim.RZ, singleAngleParamInfo,
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_GP, "GP", "Global Phase", true, true, null, Sim.GlobalPhase, singleAngleParamInfo,
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_PH, "Ph", "Phase(theta) = Z^(theta/pi)", true, true, null, Sim.Phase, singleAngleParamInfo,
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_ZG, "Z_G", "Generalized Z", true, true, null, Sim.Z_G, twoAngleParamInfo,
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_YG, "Y_G", "Generalized Y", true, true, null, Sim.Y_G, twoAngleParamInfo,
    imageSourcePrefix+
"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"
);
appendToIcons(
    CP_HG, "H_G", "Generalized Hadamard", true, true, null, Sim.H_G, twoAngleParamInfo,
    imageSourcePrefix+
"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"
);

}

let empty_icon_image = new Image();
icon_promises.push( new Promise( function(resolve,reject) {
    empty_icon_image.onload = resolve;
    empty_icon_image.onerror = reject;
    empty_icon_image.src = imageSourcePrefix+
"iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw1AUhU9TtSIVBzOoOGSoTnZREUepYhEslLZCqw4mL/2DJg1Jiouj4Fpw8Gex6uDirKuDqyAI/oC4C06KLlLifUmhRYwXHu/jvHsO790HCI0K06yuOUDTbTMVj0nZ3KoUeoUAEQH0YFhmlpFIL2bgW1/31El1F+VZ/n1/Vr+atxgQkIjnmGHaxBvEM5u2wXmfWGQlWSU+J54w6YLEj1xXPH7jXHRZ4JmimUnNE4vEUrGDlQ5mJVMjniaOqJpO+ULWY5XzFmetUmOte/IXhvP6SprrtEYRxxISSEKCghrKqMBGlHadFAspOo/5+Edcf5JcCrnKYORYQBUaZNcP/ge/Z2sVpia9pHAM6H5xnI8xILQLNOuO833sOM0TIPgMXOltf7UBzH6SXm9rkSNgYBu4uG5ryh5wuQMMPRmyKbtSkJZQKADvZ/RNOWDwFuhb8+bWOsfpA5ChWS3fAAeHwHiRstd93t3bObd/e1rz+wFHOXKVt2WOkQAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB+kCFAEKInZpsBsAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAA+klEQVR42u3XMRJAEQxAQTHuf+WodUZlkt2aJt743xgAAABAF3GxJo2p7hlP8+lNAAJAAAiAntbrxkyPg69+9SPcAAgAASAABIAAEAACQAAIAAEgAASAABAAAkAACEAARiAABIAAEAACQAAIAAEgAASAABAAAkAACAABIAAEgAAQAAJAAAgAASAABIAAEAACQAAIAAEgAASAABAAAkAACAABIAAEgAAQAAJAAAgAASAABIAAEAACQAAIAAEgAASAABAAAkAACAABIAAEgAAQAAJAAAgAASAABIAAEAACQAAIAAFwios1aUx1z9gN4BOAABAAAgAAAACgsA3xowXhKvS0iAAAAABJRU5ErkJggg=="
;
} ) );

let areAllImagesLoaded = false;

Promise.all( icon_promises ).then(
    function() {
        allImagesLoadedCallback();
    }
).catch(
    function( error ) { console.error("Error loading images:", error); }
);



const PARAMETRIC_GATE_MARGIN = 0.13;



// These are instantiated inside Icon.circuitPartFactory()
// They contain these data members:
//     parentIcon // a reference to an instance of Icon
//     paramValues // an array of values
class CircuitPart {
    getCircuitPartID() {
        return this.parentIcon.circuitPart_id;
    }
    getName() {
        //if ( this.parentIcon.isParametric ) {
        //    let s = "";
        //    for ( let i = 0; i < this.paramValues.length; ++i ) {
        //        if ( i > 0 )
        //            s += ",";
        //        s += StringUtil.numToString( this.paramValues[i] );
        //    }
        //    return this.parentIcon.name + '(' + s + ')';
        //}
        return this.parentIcon.name;
    }
    getTooltip() {
        return this.parentIcon.tooltip;
    }
    getImage() {
        return this.parentIcon.image;
    }
    isParametric() {
        return this.parentIcon.isParametric;
    }
    getMatrix() {
        if ( this.parentIcon.isParametric ) {
            return this.parentIcon.parametricFunctionToGenerateMatrix.apply( null, this.paramValues );
        }
        return this.parentIcon.matrix;
    }
    getNumParameters() {
        return this.parentIcon.numParameters;
    }
    getMargin() { // used for drawing the gate
        return PARAMETRIC_GATE_MARGIN;
    }
    getHeightOfParameterString() { // used for drawing the gate
        let numLinesOfText = this.parentIcon.numParameters + 1;
        if ( numLinesOfText < 3 ) numLinesOfText = 3;
        return (1-2*PARAMETRIC_GATE_MARGIN) / numLinesOfText;
    }
    // returns rectangle in the world space
    getBoundingRectOfParameterString( i /* index of parameter */, origin /* of gate, in world space */) {
        let h = this.getHeightOfParameterString();
        let x0 = origin.x + PARAMETRIC_GATE_MARGIN;
        let y0 = origin.y + PARAMETRIC_GATE_MARGIN+(1+i)*h;
        return new Box2(
            new Vec2( x0, y0 ),
            new Vec2( origin.x + 1 - PARAMETRIC_GATE_MARGIN, y0 + h )
        );
    }
    getParameterAsString( i ) {
        let s = StringUtil.numToString( this.paramValues[i], 3 );
        if ( this.parentIcon.parametersAreInDegrees )
            s += "°";
        return s;
    }
    getParamInfo( i ) {
        return this.parentIcon.paramInfo[ i ];
    }
}



class Circuit {
    constructor() {
        this.MIN_WIRES = 1;
        this.MAX_WIRES = 16;
        this.MIN_STAGES = 1;
        this.MAX_STAGES = 32;

        this.initializeToEmpty();
        //this.cells = [];
        //for ( let w = 0; w < this.numWires; ++w ) {
        //    this.cells[ w ] = [];
        //    for ( let s = 0; s < this.numStages; ++s ) {
        //        this.cells[w][s] = null;
        //    }
        //}
    }
    initializeToEmpty( desiredNumWires = this.MIN_WIRES, desiredNumStages = this.MIN_STAGES ) {
        this.numWires = desiredNumWires;
        this.numStages = desiredNumStages;
        this.cells = create2DArray( this.numWires, this.numStages, null );
        this.stateVectors = [];
        this.stateVectorsAndStatsAreDirty = true;
    }
    clear() {
        this.initializeToEmpty();
    }
    isCellEmpty(w,s) {
        if ( w === this.numWires ) return true;
        Util.assert( 0 <= w && w < this.numWires && 0 <= s && s < this.numStages, "isCellEmpty(): invalid index" );
        if ( w < 0 || w >= this.numWires || s < 0 || s >= this.numStages ) return true;
        if ( this.cells[w][s] !== null ) return false;
        return true;
    }
    isWireEmpty(w) {
        Util.assert( 0 <= w && w < this.numWires, "isWireEmpty(): invalid index" );
        if ( w < 0 || w >= this.numWires ) return true;
        for ( let s = 0; s < this.numStages; ++s ) {
            if ( this.cells[w][s] !== null ) return false;
        }
        return true;
    }
    isStageEmpty(s) {
        Util.assert( 0 <= s && s < this.numStages, "isStageEmpty(): invalid index" );
        if ( s < 0 || s >= this.numStages ) return true;
        for ( let w = 0; w < this.numWires; ++w ) {
            if ( this.cells[w][s] !== null ) return false;
        }
        return true;
    }
    numSwapPartsInStage(s) {
        Util.assert( 0 <= s && s < this.numStages, "numSwapPartsInStage(): invalid index" );
        if ( s < 0 || s >= this.numStages ) return 0;
        let returnValue = 0;
        for ( let w = 0; w < this.numWires; ++w ) {
            if ( this.getCircuitPartIDOfCell(w,s) === CP_SWAP ) returnValue ++;
        }
        return returnValue;
    }
    addWireAtEnd() {
        if ( this.numWires >= this.MAX_WIRES ) return;
        this.cells.push( create1DArray(this.numStages,null) );
        this.numWires ++;
        this.stateVectorsAndStatsAreDirty = true;
    }
    // inserts a stage before the given stage which can be in the range [0,numStages]
    insertStage(s) {
        Util.assert( 0 <= s && s <= this.numStages, "insertStage() invalid args" );
        if ( this.numStages >= this.MAX_STAGES ) return;
        for ( let w = 0; w < this.numWires; ++w ) {
            this.cells[w].splice( s, 0/*number of items to delete*/, null/*item to insert*/ );
        }
        this.numStages ++;
        this.stateVectorsAndStatsAreDirty = true;
    }
    addStageAtEnd() {
        this.insertStage( this.numStages );
    }
    removeWiresFromEnd( numWiresToRemove ) {
        let maxWiresThatCouldBeRemoved = this.numWires - this.MIN_WIRES;
        if ( numWiresToRemove > maxWiresThatCouldBeRemoved )
            numWiresToRemove = maxWiresThatCouldBeRemoved;
        if ( numWiresToRemove <= 0 ) return;
        this.cells.splice( this.numWires - numWiresToRemove, numWiresToRemove );
        this.numWires -= numWiresToRemove;
        this.stateVectorsAndStatsAreDirty = true;
    }
    removeStagesFromEnd( numStagesToRemove ) {
        let maxStagesThatCouldBeRemoved = this.numStages - this.MIN_STAGES;
        if ( numStagesToRemove > maxStagesThatCouldBeRemoved )
            numStagesToRemove = maxStagesThatCouldBeRemoved;
        if ( numStagesToRemove <= 0 ) return;
        for ( let w = 0; w < this.numWires; ++w ) {
            this.cells[w].splice( this.numStages - numStagesToRemove, numStagesToRemove );
        }
        this.numStages -= numStagesToRemove;
        this.stateVectorsAndStatsAreDirty = true;
    }
    removeAllEmptyWiresAtEnd() {
        let numWiresToRemove = 0;
        let w = this.numWires - 1;
        while ( w >= this.MIN_WIRES && this.isWireEmpty(w) ) {
            numWiresToRemove ++;
            w --;
        }
        this.removeWiresFromEnd( numWiresToRemove );
        this.stateVectorsAndStatsAreDirty = true;
    }
    copyStage(sourceStage,targetStage) {
        Util.assert(
            sourceStage !== targetStage
            && 0 <= sourceStage && sourceStage < this.numStages
            && 0 <= targetStage && targetStage < this.numStages,
            "copyStage(): invalid args"
        );
        if (
            sourceStage === targetStage
            || sourceStage < 0 || sourceStage >= this.numStages
            || targetStage < 0 || targetStage >= this.numStages
        )
            return;
        for ( let w = 0; w < this.numWires; ++w ) {
            this.cells[w][targetStage] = this.cells[w][sourceStage];
        }
        this.stateVectorsAndStatsAreDirty = true;
    }
    removeAllEmptyStages() {
        // find the first non-empty stage
        let targetStage = 0;
        let sourceStage = 0;
        while ( sourceStage < this.numStages && this.isStageEmpty( sourceStage ) ) {
            sourceStage ++;
        }
        while ( sourceStage < this.numStages ) {
            if ( targetStage < sourceStage ) {
                this.copyStage( sourceStage, targetStage );
                targetStage = sourceStage;
            }
            else {
                targetStage ++;
            }
            sourceStage ++;
            while ( sourceStage < this.numStages && this.isStageEmpty( sourceStage ) ) {
                sourceStage ++;
            }
        }
        this.removeStagesFromEnd( this.numStages - targetStage );
        this.stateVectorsAndStatsAreDirty = true;
    }
    compactify() {
        this.removeAllEmptyWiresAtEnd();
        this.removeAllEmptyStages();
        this.stateVectorsAndStatsAreDirty = true;
    }
    // Adds the given part at the given wire and stage, or before the given stage by inserting a new stage.
    // If the boolean flag is false, the part is added *at* the given stage,
    // overwriting whatever part may already be there.
    addCircuitPart(circuitPart,wire,stage,/*boolean*/insertBeforeTheGivenStage) {
        Util.assert(
            0 <= wire && wire < this.MAX_WIRES && 0 <= stage && stage <= this.numStages,
            "addCircuitPart() invalid args"
        );
        if ( wire < 0 || wire >= this.MAX_WIRES || stage < 0 || stage > this.numStages )
            return;
        if ( stage === this.numStages ) {
            this.addStageAtEnd();
        }
        else if ( insertBeforeTheGivenStage ) {
            this.insertStage( stage );
        }
        while ( wire >= this.numWires ) {
            this.addWireAtEnd();
        }
        this.cells[ wire ][ stage ] = circuitPart;
        this.stateVectorsAndStatsAreDirty = true;
    }
    getCellContents(wire,stage) {
        if ( wire < 0 || wire >= this.numWires || stage < 0 || stage >= this.numStages )
            return null;
        return this.cells[ wire ][ stage ];
    }
    getCircuitPartIDOfCell(wire,stage) {
        if ( wire < 0 || wire >= this.numWires || stage < 0 || stage >= this.numStages )
            return CP_EMPTY;
        if ( this.cells[ wire ][ stage ] === null )
            return CP_EMPTY;
        return this.cells[ wire ][ stage ].getCircuitPartID();
    }
    clearCell(wire,stage) {
        Util.assert(
            0 <= wire && 0 <= stage, "clearCell() invalid args"
        );
        if ( wire < 0 || wire >= this.numWires || stage < 0 || stage >= this.numStages )
            return;
        this.cells[ wire ][ stage ] = null;
        this.stateVectorsAndStatsAreDirty = true;
    }
    findFirstEmptyStageFollowedByOnlyEmptyStages() {
        let s = this.numStages;
        while ( s >= 1 && this.isStageEmpty(s-1) )
            s --;
        return s;
    }
    addGate(
        wire,
        circuitPart_id,
        listOfControlBits = [] // a list of pairs of the form [wire_index, flag] where 0<=wire_index<n and flag is true for a control bit and false for an anti-control bit
    ) {
        Util.assert( 0 <= wire, "addGate() invalid args" );
        if ( wire < 0 )
            return;
        let s = this.findFirstEmptyStageFollowedByOnlyEmptyStages();
        this.addCircuitPart( icons[ circuitPart_id ].circuitPartFactory(), wire, s, false );
        for ( let i=0; i < listOfControlBits.length; ++i ) {
            this.addCircuitPart( icons[ listOfControlBits[i][1] ? CP_CB : CP_ACB ].circuitPartFactory(), listOfControlBits[i][0], s, false );
        }
        this.stateVectorsAndStatsAreDirty = true;
    }
    addSwapGate( wire1, wire2 ) {
        Util.assert(
            0 <= wire1 && wire1 !== wire2 && 0 <= wire2,
            "addSwapGate() invalid args"
        );
        if ( wire1 < 0 || wire1 === wire2 || wire2 < 0 )
            return;
        let s = this.findFirstEmptyStageFollowedByOnlyEmptyStages();
        this.addCircuitPart( icons[ CP_SWAP ].circuitPartFactory(), wire1, s, false );
        this.addCircuitPart( icons[ CP_SWAP ].circuitPartFactory(), wire2, s, false );
        this.stateVectorsAndStatsAreDirty = true;
    }
    expandCircuit( useGeneralizedGates ) {

        let expandedListOfGatesForCircuit = [ ]; // array of {part:CircuitPart,stage:int,wire:int,listOfControlBits:[int],listOfAntiControlBits:[int]}
        let numStagesAfterExpansion = 0;
        // ---------- We need to construct expandedListOfGatesForCircuit and then convert it to a Circuit
        // ---------- for each layer in the circuit...
        for ( let s = 0; s < this.numStages; ++s ) {
            let listOfControlBits = [ ]; // ints of the wires
            let listOfAntiControlBits = [ ]; // ints of the wires
            let listOfSwapParts = [ ]; // ints of wires
            let listOfOtherParts = [ ]; // array of { part:CircuitPart, wire:int }

            // ---------- Make lists of things in this layer: control bits, swap gate parts, other parts
            for ( let w = 0; w < this.numWires; ++w ) {
                let circuitPart = this.cells[w][s];
                switch( this.getCircuitPartIDOfCell(w,s) ) {
                case CP_EMPTY:
                case CP_I:
                    break;
                case CP_CB:
                    listOfControlBits.push( w );
                    break;
                case CP_ACB:
                    listOfAntiControlBits.push( w );
                    break;
                case CP_SWAP:
                    listOfSwapParts.push( w );
                    break;
                default:
                    listOfOtherParts.push( { part:circuitPart, wire:w } );
                    break;
                }
            }
            // ---------- Add swap gate parts to the expanded list
            if ( listOfSwapParts.length > 0 ) {
                // add all the swap parts to the same stage of the expanded circuit
                for ( let j = 0; j < listOfSwapParts.length; ++j ) {
                    let w = listOfSwapParts[j];
                    expandedListOfGatesForCircuit.push( {
                        part: this.cells[w][s],
                        stage: numStagesAfterExpansion,
                        wire: w,
                        listOfControlBits: listOfControlBits.slice(),
                        listOfAntiControlBits: listOfAntiControlBits.slice()
                    } );
                }
                numStagesAfterExpansion ++;
            }
            // ---------- For each of the remaining parts in the layer, expand them as necessary
            for ( let j = 0; j < listOfOtherParts.length; ++j ) {
                let circuitPart = listOfOtherParts[j].part;
                let w = listOfOtherParts[j].wire;
                let expandedListOfPartsForOneGate = [ ]; // array of CircuitPart
                let circuitPartID = circuitPart.getCircuitPartID();
                let exponentParameter = 0;
                switch ( circuitPartID ) {
                // ---------- These ones don't need expanding:
                case CP_H:
                case CP_X:  case CP_Y:  case CP_Z:
                case CP_SZ:  case CP_invSZ:
                case CP_SSZ:  case CP_invSSZ:
                case CP_PH:  case CP_ZE:
                case CP_GP:
                case CP_ZG:  case CP_YG:  case CP_HG:
                    expandedListOfPartsForOneGate.push( circuitPart );
                    break;
                // ---------- These ones need expanding:
                case CP_SX:
                    if ( useGeneralizedGates ) {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                        let cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 1 ] = 90;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    else {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_SZ ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                    }
                    break;
                case CP_invSX:
                    if ( useGeneralizedGates ) {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                        let cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 1 ] = -90;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    else {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_invSZ ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                    }
                    break;
                case CP_SY:
                    if ( useGeneralizedGates ) {
                        let cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 45;
                        cp.paramValues[ 1 ] = (180+45);
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    else {
                        expandedListOfPartsForOneGate.push( icons[ CP_Z ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        let cp = icons[ CP_GP ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 45;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    break;
                case CP_invSY:
                    if ( useGeneralizedGates ) {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        let cp = icons[ CP_ZG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = -45;
                        cp.paramValues[ 1 ] = -(180+45);
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    else {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_Z ].circuitPartFactory() );

                        let cp = icons[ CP_GP ].circuitPartFactory();
                        cp.paramValues[ 0 ] = - 45;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    break;
                case CP_SSX:
                case CP_invSSX:
                case CP_XE:
                    if ( circuitPartID === CP_SSX )
                        exponentParameter = 0.25;
                    else if ( circuitPartID === CP_invSSX )
                        exponentParameter = -0.25;
                    else // circuitPartID === CP_XE
                        exponentParameter = circuitPart.paramValues[ 0 ];
                    if ( useGeneralizedGates ) {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        let cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 0;
                        cp.paramValues[ 1 ] = exponentParameter * 180;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    else {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        let cp = icons[ CP_ZE ].circuitPartFactory();
                        cp.paramValues[ 0 ] = exponentParameter;
                        expandedListOfPartsForOneGate.push( cp );

                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                    }
                    break;
                case CP_SSY:
                case CP_invSSY:
                case CP_YE:
                    if ( circuitPartID === CP_SSY )
                        exponentParameter = 0.25;
                    else if ( circuitPartID === CP_invSSY )
                        exponentParameter = -0.25;
                    else // circuitPartID === CP_YE
                        exponentParameter = circuitPart.paramValues[ 0 ];
                    if ( useGeneralizedGates ) {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        let cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 0;
                        cp.paramValues[ 1 ] = 90;
                        expandedListOfPartsForOneGate.push( cp );
                        cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 0;
                        cp.paramValues[ 1 ] = exponentParameter * 180;
                        expandedListOfPartsForOneGate.push( cp );
                        cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 0;
                        cp.paramValues[ 1 ] = - 90;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    else {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_SZ ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        let cp = icons[ CP_ZE ].circuitPartFactory();
                        cp.paramValues[ 0 ] = exponentParameter;
                        expandedListOfPartsForOneGate.push( cp );

                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_invSZ ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                    }
                    break;
                case CP_RX:
                    if ( useGeneralizedGates ) {
                        let cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = - circuitPart.paramValues[ 0 ] /2;
                        cp.paramValues[ 1 ] = - circuitPart.paramValues[ 0 ] /2;
                        expandedListOfPartsForOneGate.push( cp );
                        cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 0;
                        cp.paramValues[ 1 ] = circuitPart.paramValues[ 0 ];
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    else {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        let cp = icons[ CP_ZE ].circuitPartFactory();
                        cp.paramValues[ 0 ] = circuitPart.paramValues[ 0 ] / 180;
                        expandedListOfPartsForOneGate.push( cp );

                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        cp = icons[ CP_GP ].circuitPartFactory();
                        cp.paramValues[ 0 ] = - circuitPart.paramValues[ 0 ] /2;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    break;
                case CP_RY:
                    if ( useGeneralizedGates ) {
                        let cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = - circuitPart.paramValues[ 0 ] /2;
                        cp.paramValues[ 1 ] = - circuitPart.paramValues[ 0 ] /2;
                        expandedListOfPartsForOneGate.push( cp );
                        cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 0;
                        cp.paramValues[ 1 ] = 90;
                        expandedListOfPartsForOneGate.push( cp );
                        cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 0;
                        cp.paramValues[ 1 ] = circuitPart.paramValues[ 0 ];
                        expandedListOfPartsForOneGate.push( cp );
                        cp = icons[ CP_HG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = 0;
                        cp.paramValues[ 1 ] = - 90;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    else {
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_SZ ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        let cp = icons[ CP_ZE ].circuitPartFactory();
                        cp.paramValues[ 0 ] = circuitPart.paramValues[ 0 ] / 180;
                        expandedListOfPartsForOneGate.push( cp );

                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_invSZ ].circuitPartFactory() );
                        expandedListOfPartsForOneGate.push( icons[ CP_H ].circuitPartFactory() );

                        cp = icons[ CP_GP ].circuitPartFactory();
                        cp.paramValues[ 0 ] = - circuitPart.paramValues[ 0 ] /2;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    break;
                case CP_RZ:
                    if ( useGeneralizedGates ) {
                        let cp = icons[ CP_ZG ].circuitPartFactory();
                        cp.paramValues[ 0 ] = - circuitPart.paramValues[ 0 ] /2;
                        cp.paramValues[ 1 ] = circuitPart.paramValues[ 0 ] /2;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    else {
                        let cp = icons[ CP_ZE ].circuitPartFactory();
                        cp.paramValues[ 0 ] = circuitPart.paramValues[ 0 ] / 180;
                        expandedListOfPartsForOneGate.push( cp );
                        cp = icons[ CP_GP ].circuitPartFactory();
                        cp.paramValues[ 0 ] = - circuitPart.paramValues[ 0 ] /2;
                        expandedListOfPartsForOneGate.push( cp );
                    }
                    break;
                // ---------- We should not encounter these:
                case CP_SWAP:
                case CP_EMPTY:  case CP_I:
                case CP_CB:  case CP_ACB:
                default:
                    Util.assert( false, "unexpected condition in expandCircuit()" );
                    break;
                } // switch

                for ( let jj = 0; jj < expandedListOfPartsForOneGate.length; ++jj ) {
                    expandedListOfGatesForCircuit.push( {
                        part: expandedListOfPartsForOneGate[ jj ],
                        stage: numStagesAfterExpansion,
                        wire: w,
                        listOfControlBits: listOfControlBits.slice(),
                        listOfAntiControlBits: listOfAntiControlBits.slice()
                    } );
                    numStagesAfterExpansion ++;
                }
            } // for each other part

        } // for each layer

        // ---------- Now, expandedListOfGatesForCircuit is complete. Convert it to a Circuit.

        if ( numStagesAfterExpansion <= this.MAX_STAGES ) {
            this.initializeToEmpty( this.numWires, numStagesAfterExpansion );
            for ( let j = 0; j < expandedListOfGatesForCircuit.length; ++j ) {
                let x = expandedListOfGatesForCircuit[ j ];
                // x is an object with form {
                //     part:CircuitPart,
                //     stage:int,
                //     wire:int,
                //     listOfControlBits:[int], listOfAntiControlBits:[int]
                // }
                this.cells[ x.wire ][ x.stage ] = x.part;
                for ( let jj = 0; jj < x.listOfControlBits.length; ++jj ) {
                    this.cells[ x.listOfControlBits[ jj ] ][ x.stage ] = icons[ CP_CB ].circuitPartFactory();
                }
                for ( let jj = 0; jj < x.listOfAntiControlBits.length; ++jj ) {
                    this.cells[ x.listOfAntiControlBits[ jj ] ][ x.stage ] = icons[ CP_ACB ].circuitPartFactory();
                }
            }
        }
        else {
            Util.assert( false, `expandCircuit(): Expanded circuit would have ${numStagesAfterExpansion} layers, but the max is ${this.MAX_STAGES}` );
        }

        this.stateVectorsAndStatsAreDirty = true;
    }
    // Can be used to simulate forward or backward or both
    //     To simulate forward from the first state vector, the caller could do
    //         this.computeStateVectorsLayerByLayer( this.stateVectors, 0, this.numStages );
    //     To simulate back, and forward, from layer i, and store in alternative state vectors,
    //     the caller could do
    //         this.computeStateVectorsLayerByLayer( this.altStateVectors, i, 0 );
    //         this.computeStateVectorsLayerByLayer( this.altStateVectors, i, this.numStages );
    computeStateVectorsLayerByLayer(
        arrayOfStateVectors,
        startLayer, // between 0 and numStages; we assume the state vector for this layer is already computed
        endLayer  // between 0 and numStages; this is the last layer whose state vector is computed
    ) {
        Util.assert(
            0 <= startLayer && startLayer <= this.numStages && 0 <= endLayer && endLayer <= this.numStages,
            `unexpected condition in computeStateVectorsLayerByLayer(): ${startLayer},${endLayer},${this.numStages}`
        );
        let increment = ( endLayer >= startLayer ) ? +1 : -1;
        let s = startLayer; // index of state vector that is already known
        while ( true ) {
            let s2 = s + increment; // index of next state vector to compute
            let s3 = increment > 0 ? s : s2; // index of layer of circuit containing the gates that relate state vectors s and s2

            // From state vector s, we compute state vector s2, using the gates in layer s3 of the circuit
            if ( s === endLayer || s2 < 0 || s2 > this.numStages )
                break;

            arrayOfStateVectors[s2] = arrayOfStateVectors[s].copy();

            // Collect info about control bits and swap gate

            let listOfControlBits = []; // a list of pairs of the form [wire_index, flag] where 0<=wire_index<n and flag is true for a control bit and false for an anti-control bit
            let numSwapParts = 0;
            let min_w_of_swap_part = -1;
            let max_w_of_swap_part = -1;

            for ( let w = 0; w < this.numWires; ++w ) {
                let circuitPart_id = this.getCircuitPartIDOfCell(w,s3);
                if ( circuitPart_id >= 0 ) {
                    if ( circuitPart_id === CP_CB || circuitPart_id === CP_ACB ) {
                        listOfControlBits.push( circuitPart_id === CP_CB ? [w,true] : [w,false] );
                    }
                    else if ( circuitPart_id === CP_SWAP ) {
                        numSwapParts ++;
                        if ( numSwapParts === 1 )
                            min_w_of_swap_part = w;
                        max_w_of_swap_part = w;
                    }
                }
            }

            // Implement each gate, except for the swap gate
            for ( let w = 0; w < this.numWires; ++w ) {
                let circuitPart = this.cells[w][s3];
                let circuitPart_id = this.getCircuitPartIDOfCell(w,s3);
                if ( circuitPart_id >= 0 && circuitPart_id < CP_NUM ) {
                    if (
                        circuitPart_id !== CP_I
                        && circuitPart_id !== CP_CB
                        && circuitPart_id !== CP_ACB
                        && circuitPart_id !== CP_SWAP
                    ) {
                        let U = circuitPart.getMatrix();
                        if ( increment < 0 ) {
                            U = U.conjugateTranspose();
                        }
                        arrayOfStateVectors[s2] = Sim.qubitWiseMultiply(
                            U, w, this.numWires, arrayOfStateVectors[s2], listOfControlBits
                        );
                    }
                }
            }

            // Implement swap gate
            if ( numSwapParts === 2 ) {
                arrayOfStateVectors[s2] = Sim.applySwap(
                    min_w_of_swap_part, max_w_of_swap_part, this.numWires, arrayOfStateVectors[s2], listOfControlBits
                );
            }

            s = s2;
        } // while
    }
    // recomputes the state vectors for each stage
    run() {
        this.stateVectors = []; // delete contents of array
        this.perQubitStats = []; // delete contents of array
        this.stateVectors[0] = CMatrix.tensorPower( Sim.ketZero, this.numWires );

        this.computeStateVectorsLayerByLayer( this.stateVectors, 0, this.numStages );

        let n = this.numWires;
        for ( let s = 0; s <= this.numStages; ++s ) {
            let SV = this.stateVectors[ s ];
            let arrayOfAll2x2ReducedDensityMatrices = Sim.computeAll2x2ReducedDensityMatrices( n, SV );
            let arrayOfAll4x4ReducedDensityMatrices = Sim.computeAll4x4ReducedDensityMatrices( n, SV );
            this.perQubitStats[s] = Sim.analyzeEachQubit(n,arrayOfAll2x2ReducedDensityMatrices);
            if ( s == this.numStages ) { // only compute these things for the last stage ...
                this.pairwiseCorrelations = Sim.computePairwiseQubitCorrelations(n,SV);
                this.pairwiseConcurrences = Sim.computePairwiseQubitConcurrences(n,arrayOfAll4x4ReducedDensityMatrices);
                this.pairwisePurities = Sim.computePairwiseQubitPurity(n,arrayOfAll4x4ReducedDensityMatrices);
                this.pairwiseEntropies = Sim.computePairwiseQubitVonNeumannEntropy(n,arrayOfAll4x4ReducedDensityMatrices);

                // This is a hack to make it easier to display tooltips with arrows that point at appropriate edges of rectangular glyphs.
                // The matrix is a convenient way to store a bit of information for each pair of wires,
                // and the 4-element array contains values normalized to be between 0 and 1.0 indicating where
                // the edges of the rectangular glyphs are for 4 different metrics.
                this.normalizedPositionsOfGlyphs = create2DArray(n,n,[0,0,0,0]);
            }
        }
        this.stateVectorsAndStatsAreDirty = false;
    }
    runIfNecessary() {
        if ( this.stateVectorsAndStatsAreDirty )
            this.run();
    }
    generateString() {
        let obj = {cols:[]};
        for ( let s = 0; s < this.numStages; ++s ) {
            let thisColumn = [];

            let lastNonEmptyWireInThisLayer = this.numWires - 1;
            while ( this.isCellEmpty(lastNonEmptyWireInThisLayer,s) && lastNonEmptyWireInThisLayer > 0 )
                lastNonEmptyWireInThisLayer --;

            for ( let w = 0; w <= lastNonEmptyWireInThisLayer; ++w ) {
                let circuitPart = this.cells[w][s];
                switch( this.getCircuitPartIDOfCell(w,s) ) {
                case CP_EMPTY: thisColumn.push(1); break; // a 1 without quotes means a blank
                case CP_I:     thisColumn.push("1"); break; // a 1 in quotes means an explicit identity gate
                case CP_CB:    thisColumn.push("•"); break;
                case CP_ACB:   thisColumn.push("◦"); break;
                case CP_X:     thisColumn.push("X"); break;
                case CP_Y:     thisColumn.push("Y"); break;
                case CP_Z:     thisColumn.push("Z"); break;
                case CP_H:     thisColumn.push("H"); break;
                case CP_SWAP:  thisColumn.push("Swap"); break;

                case CP_SSX:   thisColumn.push("X^¼"); break;
                case CP_SX:    thisColumn.push("X^½"); break;
                case CP_SSY:   thisColumn.push("Y^¼"); break;
                case CP_SY:    thisColumn.push("Y^½"); break;
                case CP_SSZ:   thisColumn.push("Z^¼"); break;
                case CP_SZ:    thisColumn.push("Z^½"); break;
                case CP_invSSX:   thisColumn.push("X^-¼"); break;
                case CP_invSX:    thisColumn.push("X^-½"); break;
                case CP_invSSY:   thisColumn.push("Y^-¼"); break;
                case CP_invSY:    thisColumn.push("Y^-½"); break;
                case CP_invSSZ:   thisColumn.push("Z^-¼"); break;
                case CP_invSZ:    thisColumn.push("Z^-½"); break;

                /*
                case CP_SSX:   thisColumn.push({id:'X^ft',arg:'0.25'}); break;
                case CP_SX:    thisColumn.push({id:'X^ft',arg:'0.5'}); break;
                case CP_SSY:   thisColumn.push({id:'Y^ft',arg:'0.25'}); break;
                case CP_SY:    thisColumn.push({id:'Y^ft',arg:'0.5'}); break;
                case CP_SSZ:   thisColumn.push({id:'Z^ft',arg:'0.25'}); break;
                case CP_SZ:    thisColumn.push({id:'Z^ft',arg:'0.5'}); break;
                */
                case CP_XE:    thisColumn.push({id:'X^ft', arg: (circuitPart.paramValues[0]).toString() }); break;
                case CP_YE:    thisColumn.push({id:'Y^ft', arg: (circuitPart.paramValues[0]).toString() }); break;
                case CP_ZE:    thisColumn.push({id:'Z^ft', arg: (circuitPart.paramValues[0]).toString() }); break;
                case CP_RX:    thisColumn.push({id:'Rxft', arg: (circuitPart.paramValues[0]/180*Math.PI).toString() }); break;
                case CP_RY:    thisColumn.push({id:'Ryft', arg: (circuitPart.paramValues[0]/180*Math.PI).toString() }); break;
                case CP_RZ:    thisColumn.push({id:'Rzft', arg: (circuitPart.paramValues[0]/180*Math.PI).toString() }); break;
                case CP_PH:    thisColumn.push({id:'Phft', arg: (circuitPart.paramValues[0]/180*Math.PI).toString() }); break; // note that, if we wanted this to work in Quirk, we could convert it to a Z^... gate, but maybe it's better to keep it as a phase gate since that might be more meaningful to the user
                case CP_GP:    thisColumn.push({id:'GPft', arg: (circuitPart.paramValues[0]/180*Math.PI).toString() }); break;
                case CP_ZG:    thisColumn.push({id:'Zgft', arg1: (circuitPart.paramValues[0]/180*Math.PI).toString(), arg2: (circuitPart.paramValues[1]/180*Math.PI).toString() }); break;
                case CP_YG:    thisColumn.push({id:'Ygft', arg1: (circuitPart.paramValues[0]/180*Math.PI).toString(), arg2: (circuitPart.paramValues[1]/180*Math.PI).toString() }); break;
                case CP_HG:    thisColumn.push({id:'Hgft', arg1: (circuitPart.paramValues[0]/180*Math.PI).toString(), arg2: (circuitPart.paramValues[1]/180*Math.PI).toString() }); break;
                }
            }
            obj.cols.push( thisColumn );
        }
        return JSON.stringify( obj );
    }
    generateQASMString( withHTMLLineBreaks ) {
        let result = "";
        const lineBreak = withHTMLLineBreaks ? "<br/>\n" : "\n";
        result += "qreg q[" + this.numWires + "];" + lineBreak;
        for ( let s = 0; s < this.numStages; ++s ) {
            let arrayOfControlBits = [];
            let gateNameControlBitsPrefix = "";
            let controlBitArguments = "";
            for ( let w = 0; w < this.numWires; ++w ) {
                if ( this.getCircuitPartIDOfCell(w,s) === CP_CB ) {
                    arrayOfControlBits.push( w );
                    gateNameControlBitsPrefix += "c";
                    controlBitArguments += "q[" + w + "],";
                }
            }

            for ( let w = 0; w < this.numWires; ++w ) {
                let gateNameSuffix = "";
                let circuitPart = this.cells[w][s];
                switch ( this.getCircuitPartIDOfCell(w,s) ) {
                    case CP_X: gateNameSuffix = "x"; break;
                    case CP_SX: gateNameSuffix = "sx"; break;
                    case CP_invSX: gateNameSuffix = "sxdg"; break;
                    case CP_Y: gateNameSuffix = "y"; break;
                    case CP_Z: gateNameSuffix = "z"; break;
                    case CP_SZ: gateNameSuffix = "s"; break;
                    case CP_invSZ: gateNameSuffix = "sdg"; break;
                    case CP_SSZ: gateNameSuffix = "t"; break;
                    case CP_invSSZ: gateNameSuffix = "tdg"; break;
                    case CP_H: gateNameSuffix = "h"; break;
                    case CP_I: gateNameSuffix = "id"; break;
                    case CP_RX: gateNameSuffix = "rx("+(circuitPart.paramValues[0])/180*Math.PI+")"; break;
                    case CP_RY: gateNameSuffix = "ry("+(circuitPart.paramValues[0])/180*Math.PI+")"; break;
                    case CP_RZ: gateNameSuffix = "rz("+(circuitPart.paramValues[0])/180*Math.PI+")"; break;
                    case CP_PH: gateNameSuffix = "p("+(circuitPart.paramValues[0])/180*Math.PI+")"; break;
                }
                if ( gateNameSuffix.length > 0 ) {
                    let instruction = gateNameControlBitsPrefix + gateNameSuffix + " " + controlBitArguments;
                    instruction += "q[" + w + "];"
                    result += instruction + lineBreak;
                }
            }
            let swapBit1 = -1;
            let swapBit2 = -1;
            for ( let w = 0; w < this.numWires; ++w ) {
                if ( this.getCircuitPartIDOfCell(w,s)===CP_SWAP ) {
                    if ( swapBit1 < 0 )
                        swapBit1 = w;
                    else {
                        swapBit2 = w;
                        let instruction = gateNameControlBitsPrefix + "swap " + controlBitArguments;
                        instruction += "q[" + swapBit1 + "],q[" + swapBit2 + "];"
                        result += instruction + lineBreak;
                        break;
                    }
                }
            }
        }
        return result;
    }
    constructFromString( circuitString ) {
        this.clear();
        let obj = JSON.parse( circuitString );
        if ( obj.cols !== null ) {
            for ( let l = 0; l < obj.cols.length; ++l ) {
                for ( let w = 0; w < obj.cols[l].length; ++w ) {
                    let gatePartInString = obj.cols[l][w];
                    let circuitPart_id = CP_I;
                    if ( typeof(gatePartInString)==='number' ) {
                    }
                    else if ( typeof(gatePartInString)==='string' ) {
                        switch(gatePartInString) {
                        case '1': circuitPart_id=CP_I; break;
                        case '•': circuitPart_id=CP_CB; break;
                        case '◦': circuitPart_id=CP_ACB; break;
                        case 'X': circuitPart_id=CP_X; break;
                        case 'Y': circuitPart_id=CP_Y; break;
                        case 'Z': circuitPart_id=CP_Z; break;
                        case 'H': circuitPart_id=CP_H; break;
                        case 'Swap': circuitPart_id=CP_SWAP; break;
                        case 'X^¼': circuitPart_id=CP_SSX; break;
                        case 'Y^¼': circuitPart_id=CP_SSY; break;
                        case 'Z^¼': circuitPart_id=CP_SSZ; break;
                        case 'X^½': circuitPart_id=CP_SX; break;
                        case 'Y^½': circuitPart_id=CP_SY; break;
                        case 'Z^½': circuitPart_id=CP_SZ; break;
                        case 'X^-¼': circuitPart_id=CP_invSSX; break;
                        case 'Y^-¼': circuitPart_id=CP_invSSY; break;
                        case 'Z^-¼': circuitPart_id=CP_invSSZ; break;
                        case 'X^-½': circuitPart_id=CP_invSX; break;
                        case 'Y^-½': circuitPart_id=CP_invSY; break;
                        case 'Z^-½': circuitPart_id=CP_invSZ; break;
                        }
                        this.addCircuitPart( icons[ circuitPart_id ].circuitPartFactory(), w, l, false );
                    }
                    else if ( typeof(gatePartInString)==='object' ) {
                        let argument = parseFloat( gatePartInString.arg );
                        let argument1 = parseFloat( gatePartInString.arg1 );
                        let argument2 = parseFloat( gatePartInString.arg2 );
                        let tempParamValues = [ ];
                        switch(gatePartInString.id) {
                        case 'X^ft':
                            tempParamValues[0] = argument;
                            circuitPart_id = CP_XE;
                            break;
                        case 'Y^ft':
                            tempParamValues[0] = argument;
                            circuitPart_id = CP_YE;
                            break;
                        case 'Z^ft':
                            tempParamValues[0] = argument;
                            circuitPart_id = CP_ZE;
                            break;
                        case 'Rxft':
                            tempParamValues[0] = argument / Math.PI * 180;
                            circuitPart_id = CP_RX;
                            break;
                        case 'Ryft':
                            tempParamValues[0] = argument / Math.PI * 180;
                            circuitPart_id = CP_RY;
                            break;
                        case 'Rzft':
                            tempParamValues[0] = argument / Math.PI * 180;
                            circuitPart_id = CP_RZ;
                            break;
                        case 'Phft':
                            tempParamValues[0] = argument / Math.PI * 180;
                            circuitPart_id = CP_PH;
                            break;
                        case 'GPft':
                            tempParamValues[0] = argument / Math.PI * 180;
                            circuitPart_id = CP_GP;
                            break;
                        case 'Zgft':
                            tempParamValues[0] = argument1 / Math.PI * 180;
                            tempParamValues[1] = argument2 / Math.PI * 180;
                            circuitPart_id = CP_ZG;
                            break;
                        case 'Ygft':
                            tempParamValues[0] = argument1 / Math.PI * 180;
                            tempParamValues[1] = argument2 / Math.PI * 180;
                            circuitPart_id = CP_YG;
                            break;
                        case 'Hgft':
                            tempParamValues[0] = argument1 / Math.PI * 180;
                            tempParamValues[1] = argument2 / Math.PI * 180;
                            circuitPart_id = CP_HG;
                            break;
                        }
                        let circuitPart = icons[ circuitPart_id ].circuitPartFactory();
                        circuitPart.paramValues = tempParamValues;
                        this.addCircuitPart(circuitPart,w,l,false);
                    }
                }
            }
        }
    }
}

function drawTextLabelWithOutline(
    x_pixels, y_pixels, // lower left corner, or lower right if isLeftWard===true
    s, isLeftWard,
    withBackground,
    withBorder,
    rectangleHeight
) {
    let margin = rectangleHeight/8;
    let textHeight = rectangleHeight - 2*margin;
    let textWidth = ( textHeight / draw2.fontHeight ) * draw2.stringWidth( s );

    let rectangleWidth = textWidth + 2*margin;
    let x0 = x_pixels + ( isLeftWard ? (- rectangleWidth) : 0 );
    if ( x0 + rectangleWidth > canvas.width ) x0 = canvas.width - rectangleWidth;
    if ( x0 < 0 ) x0 = 0;
    let y0 = y_pixels - rectangleHeight;

    if ( withBackground ) {
        draw2.setFillColor_array(DC_label_background);
        draw2.fillRect( x0, y0, rectangleWidth, rectangleHeight );
    }
    if ( withBorder ) {
        draw2.setStrokeColor_array(DC_foreground);
        draw2.drawRect( x0, y0, rectangleWidth, rectangleHeight );
    }
    draw2.setFillColor_array(DC_foreground);
    draw2.drawString( x0+margin, y_pixels-margin, s, textHeight, TD_HORIZONTALLY_RIGHT );
}

function drawMultilineTextLabelWithOutlineAndArrows(
    x_right, y_top, // world space coordinates of upper right corner of the label
    heightPerRowOfText, // in world space units
    strings, // array
    endpoints, // array of Vec2. If an element is null, no arrow is drawn.
    distanceBetweenAdjacentEndpoints, // determines size of arrowheads

    // For the following parameters, the caller can pass in an array with one element for each arrow,
    // or pass an array of a single element in which case that element is used for all arrows.
    endpoint_tangents, // array of Vec2
    arrow_colors, // array of arrays of the form [r,g,b,alpha] where r,g,b are in the range 0 to 255 and alpha is in the range 0.0 to 1.0
    arrow_background_colors // array of arrays of the form [r,g,b,alpha] where r,g,b are in the range 0 to 255 and alpha is in the range 0.0 to 1.0; if undefined, no background color is used
) {
    let margin = heightPerRowOfText/8;
    let textHeight = heightPerRowOfText - 2*margin;
    let maxStringWidth = 0;
    for ( let i = 0; i < strings.length; ++i ) {
        let w = draw2.stringWidth( strings[i] );
        if ( w > maxStringWidth ) maxStringWidth = w;
    }
    let maxTextWidth = ( textHeight / draw2.fontHeight ) * maxStringWidth;

    let rectangleWidth = maxTextWidth + 2*margin;
    let rectangleHeight = heightPerRowOfText * strings.length;
    let x0 = x_right - rectangleWidth;
    let y0 = y_top;

    // draw background
    draw2.setFillColor_array(DC_label_background);
    draw2.fillRect( x0, y0, rectangleWidth, rectangleHeight );

    // draw arrows
    for ( let i = 0; i < strings.length; ++i ) {
        if ( strings[i].length > 0 && endpoints[i] !== null ) {
            draw2.setStrokeColor_array( arrow_colors[i % arrow_colors.length] );
            if ( arrow_background_colors !== undefined )
                draw2.setFillColor_array( arrow_background_colors[i % arrow_background_colors.length] );
            let startpoint = new Vec2( x_right, y0 + (i+0.5)*heightPerRowOfText );
            let endpoint_tangent = endpoint_tangents[i % endpoint_tangents.length];
            draw2.drawSpline(
                startpoint.x, startpoint.y, endpoints[i].x, endpoints[i].y,
                1,0, endpoint_tangent.x, endpoint_tangent.y,
                SV_splineTangentWeight, SV_splineTangentWeight
            );
            draw2.drawArrowHead(
                endpoints[i].x, endpoints[i].y,
                - endpoint_tangent.x, - endpoint_tangent.y,
                distanceBetweenAdjacentEndpoints,
                arrow_background_colors !== undefined,
                true
            );
        }
    }

    // draw border
    draw2.setStrokeColor_array(DC_foreground);
    draw2.drawRect( x0, y0, rectangleWidth, rectangleHeight );

    // draw strings
    draw2.setFillColor_array(DC_foreground);
    for ( let i = 0; i < strings.length; ++i ) {
        draw2.drawString( x0+margin, y0 + (i+1)*heightPerRowOfText - margin, strings[i], textHeight, TD_HORIZONTALLY_RIGHT );
    }
}


// --------------------------

/*
    We want to allow for multiple widgets (e.g., Toolbar, CircuitViewer, FloatingCheckbox)
    that live on a large, zoomable 2D canvas,
    and allow for drag-and-drop actions between the widgets.
    Assume there is some framework that receives mouse events and forwards them
    to the widgets.
    A widget may decide that a drag-and-drop action begins when the user presses down
    on some part of it, or may decide that drag-and-drop begins during the first drag event
    (because the initial press only served to select something within the widget).
    The initiatesDragAndDrop return value is used to indicate this to the framework.
    (For example, the Toolbar might return a true value for initiatesDragAndDrop
    as soon as the user presses on a gate inside the Toolbar,
    but the CircuitViewer might use the initial press to select a gate and wait
    for a subsequent drag event before returning a true value for initiatesDragAndDrop.)
    Once a drag-and-drop action begins, the framework takes over managing subsequent events,
    but still informs the widget of drag (and drag leave, and release) events, to allow the widget to update
    visual feedback or highlighting, e.g., to indicate to the user information about
    drop sites.
    If the widget never returns a true value for initiatesDragAndDrop during a press+drag sequence,
    then the framework allows the widget to do what it wants with the drag events,
    and the widget will never receive a 'drag leave' event, but will receive a release event.

    So, logic for camera pan and zoom, and for drag-and-drop, is managed mostly by the framework,
    whereas logic for dragging gate parameters or rectangle selection within a circuit would be
    managed by the CircuitViewer widget.
*/


const ABSTRACT_METHOD = 'Abstract method';


// The MW_ prefix means MyWidget
// These must be distinct bits, so they can be logically 'OR'ed together.
const MW_BUTTON_LEFT = 1;
const MW_BUTTON_MIDDLE = 2;
const MW_BUTTON_RIGHT = 4;
const MW_KEY_CONTROL = 8;
const MW_KEY_SHIFT = 16;



class MyWidget { // abstract base class

    // Returns an object of the form { redraw:boolean, initiatesDragAndDrop:boolean, objectBeingDragged:reference (in practice, an instance of CircuitPart) }
    widget_mousePress(
        x_pixels, y_pixels, x_world, y_world,
        mouseButton, // one of MW_BUTTON_...
        buttonAndKeyState // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
    ) { throw new Error(ABSTRACT_METHOD); }

    // Returns an object of the form { redraw:boolean, acceptsDragAndDrop:boolean }
    widget_mouseRelease(
        x_pixels, y_pixels, x_world, y_world,
        mouseButton, // one of MW_BUTTON_...
        buttonAndKeyState, // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
        isPartOfDragAndDrop, // if true, the caller is managing events; if false, the widget is managing events
        infoAboutObjectBeingDragged // an object of the form {obj:reference} (in practice, obj is an instance of CircuitPart)
    ) { throw new Error(ABSTRACT_METHOD); }

    // Returns an object of the form {redraw:boolean}
    widget_mouseHover(
        x_pixels, y_pixels, x_world, y_world
    ) { throw new Error(ABSTRACT_METHOD); }

    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_mouseHoverLeave() { throw new Error(ABSTRACT_METHOD); }

    // Returns an object of the form {redraw:boolean, initiatesDragAndDrop:boolean, objectBeingDragged:reference }
    widget_mouseDrag(
        x_pixels, y_pixels, x_world, y_world,
        buttonAndKeyState, // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
        isPartOfDragAndDrop, // if true, the caller is managing events; if false, the widget is managing events
        infoAboutObjectBeingDragged // null for none, otherwise an object of the form { obj:reference, source:reference }
    ) { throw new Error(ABSTRACT_METHOD); }

    // Only invoked during drag-and-drop.
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_mouseDragLeave() { throw new Error(ABSTRACT_METHOD); }

    // Called if this object was the source and/or sink of a drag-and-drop.
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_cleanUpAfterDragAndDrop(wasSource,wasDestination) { throw new Error(ABSTRACT_METHOD); }
}


// --------------------------

// The prefix FC_ means FloatingCheckbox
const FC_SIZE = 25; // width and height, in pixels
// The prefix FCS_ means FloatingCheckboxStyle
const FCS_CHECKMARK = 0;
const FCS_PLUS_MINUS = 1;

class FloatingCheckbox extends MyWidget {
    constructor(
        initial_state,
        off_tooltip,
        on_tooltip,
        client_callback_function, // a function taking (boolean state,client_data) as parameters
        client_data
    ) {
        super();
        this.style = FCS_PLUS_MINUS;
        this.isOn = initial_state;
        this.offTooltip = off_tooltip;
        this.onTooltip = on_tooltip;
        this.client_callback_function = client_callback_function;
        this.client_data = client_data;
        this.isCursorHoveringOver = false;
    }
    getSize() {
        return FC_SIZE;
    }
    setPosition(x,y) { // of upper-left corner; in pixels
        this.x = x;
        this.y = y;
    }
    // returns rectangle in pixel space
    getBoundingRect() {
        return new Box2(
            new Vec2( this.x, this.y ),
            new Vec2( this.x+FC_SIZE, this.y+FC_SIZE )
        );
    }
    draw( draw2 ) {
        //draw2.setCoordinateSystemToPixels();
        let rect = this.getBoundingRect();
        draw2.setFillColor_array( this.isCursorHoveringOver ? DC_highlight_icon : DC_background2 );
        draw2.fillRect(rect.min.x,rect.min.y,rect.width(),rect.height());
        draw2.setStrokeColor_array( DC_foreground );
        draw2.setLineWidth( 1 ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
        draw2.drawRect(rect.min.x,rect.min.y,rect.width(),rect.height());
        if ( this.style === FCS_PLUS_MINUS ) {
            let center = rect.center();
            let radius = 0.75 * FC_SIZE / 2;
            // draw horizontal stroke, for minus or plus sign
            draw2.drawLine( center.x-radius, center.y, center.x+radius, center.y );
            if ( ! this.isOn ) {
                // draw vertical stroke, for plus sign
                draw2.drawLine( center.x, center.y-radius, center.x, center.y+radius );
            }
        }
    }
    // Only called if nothing is being dragged.
    drawTooltip( draw2, x_pixels, y_pixels ) {
        if ( ! this.isCursorHoveringOver )
            return;
        let s = this.isOn ? this.onTooltip : this.offTooltip;
        drawTextLabelWithOutline( x_pixels, y_pixels, s, true, true, true, TOOLTIP_SIZE );
    }
    // Returns a boolean
    isUnder( x_pixels, y_pixels, x_world, y_world ) {
        return this.getBoundingRect().containsPoint( new Vec2( x_pixels, y_pixels ) );
    }
    // Returns an object of the form { redraw:boolean, initiatesDragAndDrop:boolean, objectBeingDragged:reference }
    widget_mousePress(
        x_pixels, y_pixels, x_world, y_world, mouseButton, buttonAndKeyState
    ) {
        this.isCursorHoveringOver = true;
        return { redraw: true, initiatesDragAndDrop: false, objectBeingDragged: null };
    }
    // Returns an object of the form { redraw:boolean, acceptsDragAndDrop:boolean }
    widget_mouseRelease(
        x_pixels, y_pixels, x_world, y_world,
        mouseButton, // one of MW_BUTTON_...
        buttonAndKeyState, // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
        isPartOfDragAndDrop, // if true, the caller is managing events; if false, the widget is managing events
        infoAboutObjectBeingDragged // an object of the form {obj:reference}
    ) {
        this.isOn = ! this.isOn;
        this.client_callback_function( this.isOn, this.client_data );
        return { redraw:true, acceptsDragAndDrop:false };
    }
    // Returns an object of the form {redraw:boolean}
    widget_mouseHover(
        x_pixels, y_pixels, x_world, y_world
    ) {
        this.isCursorHoveringOver = true;
        return {redraw:false};
    }
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_mouseHoverLeave() {
        this.isCursorHoveringOver = false;
        return {redraw:false};
    }
    // Returns an object of the form {redraw:boolean, initiatesDragAndDrop:boolean, objectBeingDragged:reference}
    widget_mouseDrag(
        x_pixels, y_pixels, x_world, y_world,
        buttonAndKeyState, // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
        isPartOfDragAndDrop, // if true, the caller is managing events; if false, the widget is managing events
        infoAboutObjectBeingDragged // null for none, otherwise an object of the form { obj:reference, source:reference }
    ) {
        return { redraw:false, initiatesDragAndDrop:false, objectBeingDragged:null };
    }
    // Only invoked during drag-and-drop.
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_mouseDragLeave() {
        return {redraw:false};
    }
}



// --------------------------


// I won't make this a static member of the Toolbar class, because then I would need to prefix every mention of it with "Toolbar."

// The TB_ prefix means ToolBar
const TB_ICON_SIZE = 64; // icons are scaled to this size, in pixels

const TOOLTIP_SIZE = 32;

class Toolbar extends MyWidget {
    constructor() {
        super();
        this.numRows = 2; // number of rows of icons in the toolbar.
        this.highlighted_circuitPart_id = CP_EMPTY;
    }
    // returns pixel coordinates of upper left corner as an object of the form {x,y}
    getPositionOfIcon( circuitPart_id ) {
        let x = circuitPart_id;
        let y = 0;
        if ( this.numRows === 2 ) {
            switch ( circuitPart_id ) {
            case CP_CB:   x = 0; break;
            case CP_X:    x = 1; break;
            case CP_Y:    x = 2; break;
            case CP_Z:    x = 3; break;
            case CP_SX:  x = 4;  break;
            case CP_SY:  x = 5;  break;
            case CP_SZ:  x = 6;  break;
            case CP_SSX: x = 7;  break;
            case CP_SSY: x = 8;  break;
            case CP_SSZ: x = 9;  break;

            case CP_XE:  x = 10; break;
            case CP_YE:  x = 11; break;
            case CP_ZE:  x = 12; break;

            case CP_PH:  x = 13; break;
            case CP_GP:  x = 14; break;


            case CP_ACB: x = 0; y = 1; break;
            case CP_I:    x = 1; y = 1; break;
            case CP_SWAP: x = 2; y = 1; break;
            case CP_H:    x = 3; y = 1; break;
            case CP_invSX:  x = 4; y = 1; break;
            case CP_invSY:  x = 5; y = 1; break;
            case CP_invSZ:  x = 6; y = 1; break;
            case CP_invSSX: x = 7; y = 1; break;
            case CP_invSSY: x = 8; y = 1; break;
            case CP_invSSZ: x = 9; y = 1; break;

            case CP_RX:  x = 10; y = 1; break;
            case CP_RY:  x = 11; y = 1; break;
            case CP_RZ:  x = 12; y = 1; break;

            case CP_ZG:  x = 13; y = 1; break;
            case CP_YG:  x = 14; y = 1; break;
            case CP_HG:  x = 15; y = 1; break;

            }
        }
        return { x: (x*TB_ICON_SIZE), y: (y*TB_ICON_SIZE) };
    }
    // returns CP_EMPTY if none is found
    findIDOfIconUnderPosition( x_pixels, y_pixels ) {
        for ( let id = 0; id < CP_NUM; ++id ) {
            let pos = this.getPositionOfIcon( id );
            if (
                pos.x <= x_pixels && x_pixels <= pos.x+TB_ICON_SIZE
                && pos.y <= y_pixels && y_pixels <= pos.y+TB_ICON_SIZE
            )
                return id;
        }
        return CP_EMPTY;
    }
    // returns rectangle in pixel space
    getBoundingRect() {
        return new Box2(
            new Vec2(0,0),
            new Vec2( Math.ceil(CP_NUM / this.numRows)*TB_ICON_SIZE, this.numRows*TB_ICON_SIZE )
        );
    }
    draw( draw2 ) {
        //draw2.setCoordinateSystemToPixels();
        let rect = this.getBoundingRect();
        draw2.setFillColor_array(DC_background2);
        draw2.fillRect(rect.min.x,rect.min.y,rect.width(),rect.height());
        for ( let circuitPart_id = 0; circuitPart_id < CP_NUM; ++circuitPart_id ) {
            let pos = this.getPositionOfIcon( circuitPart_id );
            //draw2.canvas_context.drawImage(icons[circuitPart_id].image, pos.x, pos.y, TB_ICON_SIZE, TB_ICON_SIZE );
            draw2.drawImage(icons[circuitPart_id].image, pos.x, pos.y, TB_ICON_SIZE, TB_ICON_SIZE );
            if ( circuitPart_id === this.highlighted_circuitPart_id ) {
                draw2.setLineWidth( 3 ); // TODO_lineWidth
                draw2.setStrokeColor_array(DC_highlight_icon);
                draw2.drawRect(pos.x,pos.y,TB_ICON_SIZE,TB_ICON_SIZE);
            }
        }
    }
    // Only called if nothing is being dragged.
    drawTooltip(
        draw2,
        x_pixels, y_pixels
    ) {
        if ( this.highlighted_circuitPart_id < 0 )
            return;
        let s = icons[ this.highlighted_circuitPart_id ].tooltip;

        drawTextLabelWithOutline( x_pixels, y_pixels, s, false, true, true, TOOLTIP_SIZE );
    }
    // Only called if something is being dragged.
    drawObjectBeingDragged(
        draw2,
        x_pixels, y_pixels,
        infoAboutObjectBeingDragged // an object of the form {obj:reference}
    ) {
    }
    // Returns a boolean
    isUnder( x_pixels, y_pixels, x_world, y_world ) {
        return this.getBoundingRect().containsPoint( new Vec2( x_pixels, y_pixels ) );
    }
    // XXX we are in the Toolbar class
    // Returns an object of the form { redraw:boolean, initiatesDragAndDrop:boolean, objectBeingDragged:reference }
    widget_mousePress(
        x_pixels, y_pixels, x_world, y_world, mouseButton, buttonAndKeyState
    ) {
        let dragStarting = this.highlighted_circuitPart_id!==CP_EMPTY && mouseButton===MW_BUTTON_LEFT && buttonAndKeyState===MW_BUTTON_LEFT;
        return {
            redraw: true,
            initiatesDragAndDrop: dragStarting,
            objectBeingDragged: (dragStarting ? icons[ this.highlighted_circuitPart_id ].circuitPartFactory() : null)
        };
    }
    // Returns an object of the form { redraw:boolean, acceptsDragAndDrop:boolean }
    widget_mouseRelease(
        x_pixels, y_pixels, x_world, y_world,
        mouseButton, // one of MW_BUTTON_...
        buttonAndKeyState, // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
        isPartOfDragAndDrop, // if true, the caller is managing events; if false, the widget is managing events
        infoAboutObjectBeingDragged // an object of the form {obj:reference}
    ) {
        return { redraw:true, acceptsDragAndDrop:false };
    }
    // Returns an object of the form {redraw:boolean}
    widget_mouseHover(
        x_pixels, y_pixels, x_world, y_world
    ) {
        let new_id = this.findIDOfIconUnderPosition( x_pixels, y_pixels );
        if ( new_id !== this.highlighted_circuitPart_id ) {
            this.highlighted_circuitPart_id = new_id;
            return {redraw:true};
        }
        return {redraw:false};
    }
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_mouseHoverLeave() {
        let new_id = CP_EMPTY;
        if ( new_id !== this.highlighted_circuitPart_id ) {
            this.highlighted_circuitPart_id = new_id;
            return {redraw:true};
        }
        return {redraw:false};
    }
    // Returns an object of the form {redraw:boolean, initiatesDragAndDrop:boolean, objectBeingDragged:reference}
    widget_mouseDrag(
        x_pixels, y_pixels, x_world, y_world,
        buttonAndKeyState, // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
        isPartOfDragAndDrop, // if true, the caller is managing events; if false, the widget is managing events
        infoAboutObjectBeingDragged // null for none, otherwise an object of the form { obj:reference, source:reference }
    ) {
        return { redraw:false, initiatesDragAndDrop:false, objectBeingDragged:null };
    }
    // Only invoked during drag-and-drop.
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_mouseDragLeave() {
        return {redraw:false};
    }
    // Called if this object was the source and/or sink of a drag-and-drop.
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_cleanUpAfterDragAndDrop(wasSource,wasDestination) {
        let new_id = CP_EMPTY;
        if ( new_id !== this.highlighted_circuitPart_id ) {
            this.highlighted_circuitPart_id = new_id;
            return {redraw:true};
        }
        return {redraw:false};
    }
} // Toolbar class


// DispOpt is an abbreviation for DisplayOptions
let DispOpt = { };
DispOpt.showOriginalHalfmatrixTooltip = false;
DispOpt.showOriginalLSTooltip = false; // LS means LocalState
DispOpt.showFinalLocalState = false; // true;
DispOpt.showLocalStatePerLayer = false; // true;
DispOpt.showFinalHalfMatrix = false;
// LS_ means LocalState_
DispOpt.LS_numMetrics = 0;
DispOpt.LS_showPurity = false;
DispOpt.LS_showLinearEntropy = true;
DispOpt.LS_showVonNeumannEntropy = true;
DispOpt.LS_showProbability = true;
DispOpt.LS_showPhase = true;
// HM_ means HalfMatrix_
/*const*/ DispOpt.HM_BARCHART = 0;
/*const*/ DispOpt.HM_RECT_GLYPHS = 1;
DispOpt.HM_cellContents = DispOpt.HM_BARCHART;
DispOpt.HM_numMetrics = 0;
DispOpt.HM_showPurity = false;
DispOpt.HM_showLinearEntropy = true;
DispOpt.HM_showVonNeumannEntropy = true;
DispOpt.HM_showConcurrence = true;
DispOpt.HM_showCorrelation = true;
DispOpt.HM_signedMetricsHaveZeroInCenterOfCell = false;
DispOpt.showStateVectorsPerLayer = false;
DispOpt.showVisOfAllLayers = true;
DispOpt.scrollPerLayerVisHorizontally = false;
/*const*/ DispOpt.CELL_ASPECTRATIO_SQUARE = 1.0;
/*const*/ DispOpt.CELL_ASPECTRATIO_RECTANGULAR = 2.8; // 3.5;
/*const*/ DispOpt.OUTSIDE_BITSTRING_ASPECTRATIO = 3;
DispOpt.cell_aspectRatio = DispOpt.CELL_ASPECTRATIO_RECTANGULAR;
DispOpt.allowMultipleColumns = true;
DispOpt.displayOutsideBitstring = true;
DispOpt.displayInsideBitstring = false;
DispOpt.displayInsideProbability = true;
/*const*/ DispOpt.BARFUNCTION_PROBABILITY = 0;
/*const*/ DispOpt.BARFUNCTION_MAGNITUDE = 1;
/*const*/ DispOpt.BARFUNCTION_LOG_PROBABILITY = 2;
DispOpt.barFunction = DispOpt.BARFUNCTION_PROBABILITY;
/*const*/ DispOpt.DIFFVIS_NONE = 0;
/*const*/ DispOpt.DIFFVIS_ONE = 1;
/*const*/ DispOpt.DIFFVIS_ALL = 2;
DispOpt.show_diffvis = DispOpt.DIFFVIS_ALL;

// The DC_ prefix means DisplayColor
const DC_background = [ 255, 255, 255, 1.0 ]; // background of the viewport
const DC_background2 = [ 240, 240, 240, 1.0 ]; // background of the circuit
const DC_label_background = [ 255,255,255,0.85 ];
const DC_foreground = [ 0, 0, 0, 1 ];
const DC_highlight_icon = [ 255, 128, 0, 1 ]; // [ 0, 128, 255, 1 ];
const DC_highlight_wire = [ 255, 128, 0, 1 ];
const DC_highlight_dropSite = [ 255, 128, 0, 1 ];
const DC_barcolor = [ 128,192,255, 1 ]; // for positive values
const DC_barcolor_neg_opaque = [ 255,128,128, 1 ]; // for negative values
const DC_shadow = [ 192, 192, 192, 1.0 ];
const DC_diffvis_1_background = [ 255, 160, 255, 1.0  ];
const DC_diffvis_1_foreground = [ 255, 96, 255, 1.0 ];
const DC_diffvis_2_background = [ 160, 255, 160, 1.0 ];
const DC_diffvis_2_foreground = [ 48, 255, 48, 1.0 ];
const DC_HM_mixedness = [ 128, 128, 128, 1 ]; // [ 255, 0, 255, 1 ];
const DC_HM_mixedness_darker = [ 0, 0, 0, 1 ]; // [ 255, 0, 255, 1 ];
const DC_HM_entanglement_pos = [ 0,128,255, 1 ];
const DC_HM_entanglement_neg = [ 255,0,0, 1 ]; // for negative values

// I won't make these static members of the CircuitViewer class, because then I would need to prefix every mention of them with "CircuitViewer."

// The CVH_ prefix means CircuitViewerHighlight
const CVH_NOTHING = -1;
const CVH_CIRCUIT = 0;
const CVH_FV_LOCALSTATE = 1;
const CVH_FV_HALFMATRIX = 2;
const CVH_PLV_LOCALSTATE = 3;
const CVH_PLV_STATEVECTOR = 4;
// XXX YYY additional cases to consider:
/*
    user can be hovering over a particular parameter of a gate
    CVH_PLV_LOCALSTATE or CVH_PLV_STATEVECTOR
       user is on a PLV and in between two stages of the circuit; we can draw a vertical line segment in the circuit between the two stages
       if user is on a CVH_PLV_STATEVECTOR vis, they are on a particular state, for which we can popup a tooltip

    Things to check:
    - when CVH_PLV_LOCALSTATE, you should still highlight wire, but not a gate
    - when CVH_PLV_LOCALSTATE or CVH_PLV_STATEVECTOR, you should draw vertical line segment in between two stages of the circuit

    When cursor is over a parameter, can you make tooltip appear saying:
        Ctrl+drag left-right to adjust. Shift+drag left-right to snap to nice values.
*/

// CV_ prefix means CircuitViewer
const CV_MARGIN = 0.5; // only used for camera framing

// FV_ means FinalVisualization
// LS_ means LocalState
const FV_MARGIN_LEFT = 1;
let LS_W = 1;
let FV_LS_x0 = 0;

// FV_HM_ prefix for FinalVisualization_HalfMatrix
let FV_HM_center_x0 = 0;
let FV_HM_center_y0 = 0;

// PLV_ prefix for PerLayerVisualization
let PLV_x0 = 0;
let PLV_y0 = 0;
let PLV_col_w = 1;
const PLV_space_h_top = 1;
const PLV_space_h = 0.5;
let PLV_space_w = 1;
let PLV_total_w = 1;
let PLV_stage = 0;
let PLV_stage_fractionalPart = 0.5;
let PLV_mostRecentForScrolling_mouse_x_world = 0;
// SV_ means StateVector
let SV_col_w = 1;
const SV_arrowHeadLength = 0.15;
const SV_arrowHeadLength2 = 0.5;
const SV_splineTangentWeight = 0.6;
const diffvis_forSwapGates_thickness = 2;
let SV_numCols = 1;
let SV_numRows = 2;
let SV_numColBits = 0;
let SV_numRowBits = 0;
let SV_cell_w = 1;
let SV_cell_h = 1 / DispOpt.cell_aspectRatio;
let SV_total_h = 1;
// PLV_LS_ means PerLayerVisualization_LocalState
let PLV_LS_x0 = 0;
// PLV_SV_ means PerLayerVisualization_StateVector
let PLV_SV_x0 = 0;
let PLV_SV_y0 = 0;

const BAR_MARGIN = 0.1;
const BAR_WIDTH = 1 - 2*BAR_MARGIN;

// CV_DM_ prefix means CircuitViewer DragMode
const CV_DM_NOT_DRAGGING = 0;
const CV_DM_DRAGGING_NOTHING = 1;
const CV_DM_PARAMETER_DRAG = 2;
const CV_DM_PARAMETER_DRAG_WITH_SNAPPING = 3;
const CV_DM_TENTATIVE_DRAG_AND_DROP = 4;
const CV_DM_DRAG_AND_DROP = 5;
const CV_DM_DELETE_CIRCUITPART = 6;

class CircuitViewer extends MyWidget {
    clearHighlighting() {
        this.highlighted_mode = CVH_NOTHING;
        this.highlighted_wire = -1;
        this.highlighted_stage = -1;
        this.highlighted_circuitPart = null;
        this.highlighted_wire2 = -1;
        this.highlighted_circuitPart_parameter = -1;
        this.highlighted_baseState = -1;
    }
    clearSelection() {
        this.selected_circuitPart_isAnythingSelected = false;
        this.selected_circuitPart_wire = -1;
        this.selected_circuitPart_stage = -1;
        this.selected_circuitPart_parameter = -1;
    }
    clearDropCandidate() {
        this.hasDropCandidate = false;
        this.drop_wire = -1;
        this.drop_stage = -1;
        this.drop_insertBeforeTheGivenStage = false;
    }
    constructor(circuit) {
        super();
        this.circuit = circuit;
        this.clearHighlighting();
        this.clearDropCandidate();

        this.clearSelection();

        this.dragMode = CV_DM_NOT_DRAGGING;
        this.drag_x0_pixels = 0;
        this.drag_parameterValueAtStart = 0;
        this.drag_cumulativeDelta_pixels = 0;
    }
    // returns an object of the form { mode:..., wire:..., stage:..., circuitPart:..., wire2:..., circuitPart_parameter:..., baseState:... }
    findHighlightedElements( x_world, y_world ) {
        if ( DispOpt.showFinalHalfMatrix ) {
            let p_pm = this.transformWorldSpaceToPairwiseMatrixSpace( FV_HM_center_x0, FV_HM_center_y0, new Vec2(x_world,y_world) );
            let triangle_cell_i = Math.floor(p_pm.x);
            let triangle_cell_j = Math.floor(p_pm.y);
            if ( 0<=p_pm.x && 0<=p_pm.y && triangle_cell_i+triangle_cell_j<= this.circuit.numWires-2 ) {
                //console.log(`cell ${triangle_cell_i}, ${triangle_cell_j}`);
                return {mode:CVH_FV_HALFMATRIX, wire: triangle_cell_i, stage:-1, circuitPart:null, wire2: this.circuit.numWires-1-triangle_cell_j, circuitPart_parameter:-1, baseState:-1 };
            }
        }
        if (
            DispOpt.showFinalLocalState
            && FV_LS_x0 <= x_world && x_world <= FV_LS_x0+LS_W
            && 0 <= y_world && y_world <= this.circuit.numWires
        ) {
            return {mode:CVH_FV_LOCALSTATE, wire: Math.floor( y_world ), stage:-1, circuitPart:null, wire2:-1, circuitPart_parameter:-1, baseState:-1 };
        }
        if (
            DispOpt.showLocalStatePerLayer
            && PLV_x0 <= x_world && x_world <= PLV_x0+PLV_total_w
            && PLV_y0 <= y_world && y_world <= PLV_y0+this.circuit.numWires
        ) {
            return {mode:CVH_PLV_LOCALSTATE, wire: Math.floor(y_world - PLV_y0), stage:Math.floor((x_world-PLV_x0+PLV_space_w/2)/(PLV_col_w+PLV_space_w)), circuitPart:null, wire2:-1, circuitPart_parameter:-1, baseState:-1 };
        }
        if (
            DispOpt.showStateVectorsPerLayer
            && PLV_x0 <= x_world && x_world <= PLV_x0+PLV_total_w
            && PLV_SV_y0 <= y_world && y_world <= PLV_SV_y0+SV_total_h
        ) {
            let stage = Math.floor((x_world-PLV_x0+PLV_space_w/2)/(PLV_col_w+PLV_space_w));
            let baseState_col = Math.floor( (x_world-(PLV_SV_x0+stage*(PLV_col_w+PLV_space_w)))/SV_cell_w );
            let baseState_row = Math.floor( (y_world-PLV_SV_y0)/SV_cell_h );
            let baseState = -1;
            if (
                0 <= baseState_col && baseState_col < SV_numCols
                && 0 <= baseState_row && baseState_row < SV_numRows
            ) {
                baseState = baseState_row * SV_numCols + baseState_col;
            }
            else {
                // cursor is not on a cell of any state vector, so leave baseState === -1
            }
            return {mode:CVH_PLV_STATEVECTOR, wire:-1, stage:stage, circuitPart:null, wire2:-1, circuitPart_parameter:-1, baseState:baseState };
        }
        let stage = Math.floor( x_world );
        if ( stage < 0 || stage > this.circuit.numStages ) stage = -1;
        let wire = Math.floor( y_world );
        if ( wire < 0 || wire > this.circuit.numWires ) wire = -1;
        if ( stage < 0 && wire < 0 ) {
            return {mode:CVH_NOTHING, wire:-1, stage:-1, circuitPart:null, wire2:-1, circuitPart_parameter:-1, baseState:-1 };
        }

        let circuitPart = this.circuit.getCellContents(wire,stage);
        let circuitPart_parameter = -1;
        if ( circuitPart !== null ) {
            for ( let i = 0; i < circuitPart.getNumParameters(); ++i ) {
                let boundingRect = circuitPart.getBoundingRectOfParameterString( i, new Vec2( stage, wire ) );
                if ( boundingRect.containsPoint( new Vec2( x_world, y_world ) ) ) {
                    circuitPart_parameter = i;
                    break;
                }
            }
        }
        return { mode:CVH_CIRCUIT, wire:wire, stage:stage, circuitPart:circuitPart, wire2:-1, circuitPart_parameter:circuitPart_parameter, baseState:-1 };
    }
    // Useful for completing a drag-and-drop.
    // Returns an object of the form { hasDropCandidate:boolean, wire:...,stage:...,/*boolean*/insertBeforeTheGivenStage }
    findCellForDrop( x_world, y_world, circuitPart_id ) {
        const margin = 0.25;
        let wire = -1;
        let stage = -1;
        let insertBeforeTheGivenStage = false;
        let failureReturnValue = { hasDropCandidate:false, wire:-1, stage:-1, insertBeforeTheGivenStage:false };

        if ( x_world < -1 || this.circuit.numStages+2 < x_world ) { // it's too far outside
            return failureReturnValue;
        }
        else if ( x_world < margin ) { // close to left-most cell
            stage = 0;
            insertBeforeTheGivenStage = true;
        }
        else if ( this.circuit.numStages - margin < x_world ) { // just past right-most cell
            stage = this.circuit.numStages;
            insertBeforeTheGivenStage = true;
        }
        else { // inside the range of cells
            let distanceFromEdge = Math.abs(x_world - Math.round(x_world));
            if ( distanceFromEdge < margin ) {
                stage = Math.round( x_world );
                insertBeforeTheGivenStage = true;
            }
            else {
                stage = Math.floor( x_world );
                insertBeforeTheGivenStage = false;
            }
        }

        if ( y_world < -1 || y_world > this.circuit.numWires+1 ) { // it's too far outside
            return failureReturnValue;
        }
        else {
            wire = Math.floor( y_world );
            if ( wire < 0 ) wire = 0;
            else if ( wire > this.circuit.numWires ) wire = this.circuit.numWires;
        }

        if ( !insertBeforeTheGivenStage ) {
            if (
                ! this.circuit.isCellEmpty(wire,stage)
                || ( circuitPart_id===CP_SWAP && this.circuit.numSwapPartsInStage(stage)>=2 )
            ) {
                // the cell is not empty, or we already have 2 swap parts in the stage, so don't allow the drop
                return failureReturnValue;
            }
        }
        return { hasDropCandidate:true, wire:wire, stage:stage, insertBeforeTheGivenStage:insertBeforeTheGivenStage };
    }
    // returns rectangle in world space
    getBoundingRect() {
        let b = new Box2(
            new Vec2(-1-CV_MARGIN,-CV_MARGIN),
            new Vec2(
                this.circuit.numStages + FV_MARGIN_LEFT + ( DispOpt.showFinalLocalState ? LS_W : 0 ) + CV_MARGIN,
                this.circuit.numWires + CV_MARGIN
            ),
        );
        if ( DispOpt.showFinalHalfMatrix ) {
            b.boundPoint( new Vec2( FV_HM_center_x0 + CV_MARGIN, 0 ) );
        }
        if ( DispOpt.showLocalStatePerLayer ) {
            // account for how low the Local State visualization extends downward
            b.boundPoint( new Vec2( 0, PLV_y0 + this.circuit.numWires + CV_MARGIN ) )
            // account for how far left and right it extends
            let extent = DispOpt.scrollPerLayerVisHorizontally ? ( PLV_col_w + PLV_space_w/2 - 0.5 + CV_MARGIN ) : ((PLV_total_w-this.circuit.numStages)/2+CV_MARGIN);
            b.boundPoint( new Vec2( -extent, 0 ) );
            b.boundPoint( new Vec2( this.circuit.numStages + extent, 0 ) );
        }
        if ( DispOpt.showStateVectorsPerLayer ) {
            // account for how low the State Vector visualization extends downward
            b.boundPoint( new Vec2( 0, PLV_SV_y0 + SV_total_h + CV_MARGIN + ( DispOpt.displayOutsideBitstring&&DispOpt.allowMultipleColumns ? SV_cell_h * DispOpt.OUTSIDE_BITSTRING_ASPECTRATIO : 0 ) ) )
            // account for how far left and right it extends
            let extent = DispOpt.scrollPerLayerVisHorizontally ? ( PLV_col_w + PLV_space_w/2 - 0.5 + CV_MARGIN ) : ((PLV_total_w-this.circuit.numStages)/2+CV_MARGIN);
            b.boundPoint( new Vec2( -extent, 0 ) );
            b.boundPoint( new Vec2( this.circuit.numStages + extent + ( DispOpt.displayOutsideBitstring ? SV_cell_h * DispOpt.OUTSIDE_BITSTRING_ASPECTRATIO : 0 ), 0 ) );
        }
        return b;
    }
    // caller passes in coordinates, in pixels, of the region in the canvas within which we want the viewer to be framed
    frame( draw2, region_x,region_y,region_w,region_h ) {
        draw2.frameWithinCanvasRegion( this.getBoundingRect(), true, region_x,region_y,region_w,region_h );
    }
    transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, point_pm ) {
        const s = Math.SQRT1_2;
        let x = point_pm.x * s;
        let y = point_pm.y * s;
        return new Vec2( -s*x - s*y + halfMatrixCenter_x0, s*x - s*y + halfMatrixCenter_y0 );
    }
    transformWorldSpaceToPairwiseMatrixSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, point_w ) {
        const s = Math.SQRT1_2;
        let x = ( point_w.x - halfMatrixCenter_x0 ) / s;
        let y = ( point_w.y - halfMatrixCenter_y0 ) / s;
        return new Vec2( -s*x + s*y, - s*x - s*y );
    }
    drawLocalState( /*world*/x0, /*world*/y0, /*circuit*/C, /*int*/layer, /*bool*/drawDiffVis/*TODO_diff not yet used*/, alpha ) {
        draw2.setLineWidth(1);
        let partWidth = 0.5;

        for ( let wire = 0; wire < C.numWires; ++wire ) {
            draw2.setFillColor(DC_HM_mixedness[0],DC_HM_mixedness[1],DC_HM_mixedness[2],alpha);
            draw2.setStrokeColor_array(DC_foreground);
            let currentX = x0;
            if ( DispOpt.LS_showPurity ) {
                let h = C.perQubitStats[layer][wire].purity._r;
                draw2.fillRect(currentX+partWidth*BAR_MARGIN,y0+wire+(1-h),partWidth*BAR_WIDTH,h);
                currentX += partWidth;
            }
            if ( DispOpt.LS_showLinearEntropy ) {
                let h = C.perQubitStats[layer][wire].linearEntropy;
                draw2.fillRect(currentX+partWidth*BAR_MARGIN,y0+wire+(1-h),partWidth*BAR_WIDTH,h);
                currentX += partWidth;
            }
            if ( DispOpt.LS_showVonNeumannEntropy ) {
                let h = C.perQubitStats[layer][wire].vonNeumannEntropy;
                draw2.fillRect(currentX+partWidth*BAR_MARGIN,y0+wire+(1-h),partWidth*BAR_WIDTH,h);
                currentX += partWidth;
            }
            draw2.setFillColor(DC_barcolor[0],DC_barcolor[1],DC_barcolor[2],alpha);
            if ( DispOpt.LS_showProbability ) {
                let h = C.perQubitStats[layer][wire].probabilityOfOne;
                draw2.fillRect(currentX+partWidth*BAR_MARGIN,y0+wire+(1-h),partWidth*BAR_WIDTH,h);
                currentX += partWidth;
            }
            if ( DispOpt.LS_showPhase ) {
                let circle_x = currentX + partWidth*0.5;
                let circle_y = y0+wire + 0.5;
                let circle_radius = partWidth * 0.5;
                let circle_hand_angle = - C.perQubitStats[layer][wire].phase;
                let circle_hand_x = circle_x + circle_radius*Math.cos(circle_hand_angle);
                let circle_hand_y = circle_y + circle_radius*Math.sin(circle_hand_angle)
                draw2.fillCircle( circle_x, circle_y, circle_radius );
                draw2.drawCircle( circle_x, circle_y, circle_radius );
                draw2.drawLine( circle_x, circle_y, circle_hand_x, circle_hand_y );
            }
            draw2.drawRect(x0,y0+wire,LS_W,1);
        }
    }
    drawLocalStateTooltip( /*world*/x0, /*world*/y0, /*circuit*/C, /*int*/layer, /*int*/wire, below ) {
        let precision = 3;
        let strings = [];
        let endpoints = [];
        let arrow_foreground_colors = [];
        let arrow_background_colors = [];
        let partWidth = 0.5;

        let currentX = x0;
        if ( DispOpt.LS_showPurity ) {
            strings.push( "Purity=" + StringUtil.numToString(C.perQubitStats[layer][wire].purity._r, precision ) );
            endpoints.push( new Vec2( currentX+0.5*partWidth, y0+(below ? 1 : 0) ) );
            arrow_foreground_colors.push( DC_HM_mixedness_darker );
            arrow_background_colors.push( DC_HM_mixedness );
            currentX += partWidth;
        }
        if ( DispOpt.LS_showLinearEntropy ) {
            strings.push( "Linear Entropy=" + StringUtil.numToString(C.perQubitStats[layer][wire].linearEntropy, precision ) );
            endpoints.push( new Vec2( currentX+0.5*partWidth, y0+(below ? 1 : 0) ) );
            arrow_foreground_colors.push( DC_HM_mixedness_darker );
            arrow_background_colors.push( DC_HM_mixedness );
            currentX += partWidth;
        }
        if ( DispOpt.LS_showVonNeumannEntropy ) {
            strings.push( "Von Neumann Entropy=" + StringUtil.numToString(C.perQubitStats[layer][wire].vonNeumannEntropy, precision ) );
            endpoints.push( new Vec2( currentX+0.5*partWidth, y0+(below ? 1 : 0) ) );
            arrow_foreground_colors.push( DC_HM_mixedness_darker );
            arrow_background_colors.push( DC_HM_mixedness );
            currentX += partWidth;
        }
        if ( DispOpt.LS_showProbability ) {
            strings.push( "Probability(|1>)=" + StringUtil.numToString(C.perQubitStats[layer][wire].probabilityOfOne , precision ) );
            endpoints.push( new Vec2( currentX+0.5*partWidth, y0+(below ? 1 : 0) ) );
            arrow_foreground_colors.push( DC_HM_entanglement_pos );
            arrow_background_colors.push( DC_HM_entanglement_pos );
            currentX += partWidth;
        }
        if ( DispOpt.LS_showPhase ) {
            strings.push( "Phase=" + StringUtil.numToString(C.perQubitStats[layer][wire].phase/Math.PI*180 , precision )+"°" );
            endpoints.push( new Vec2( currentX+0.5*partWidth, y0+(below ? 1 : 0) ) );
            arrow_foreground_colors.push( DC_HM_entanglement_pos );
            arrow_background_colors.push( DC_HM_entanglement_pos );
            currentX += partWidth;
        }

        drawMultilineTextLabelWithOutlineAndArrows(
            endpoints[0].x-(below ? 0.8 : 1.05 ), endpoints[0].y+(below?0.5:-2.25),
            0.6 * TB_ICON_SIZE*0.7 * draw2.scaleFactorInWorldSpaceUnitsPerPixel,
            strings,
            endpoints,
            0.3,
            [ new Vec2(0,below ? 1 : -1) ],
            // [ DC_foreground ]
            arrow_foreground_colors,
            arrow_background_colors
        );
    }
    drawHalfMatrix( halfMatrixCenter_x0, halfMatrixCenter_y0, /*circuit*/C, /*int*/layer/*not used yet*/, /*bool*/drawDiffVis/*TODO_diff not used yet*/ ) {

        const PURITY_MIN = 0;
        const PURITY_MAX = 1;
        const LINEARENTROPY_MIN = 0;
        const LINEARENTROPY_MAX = 1;
        const VONNEUMANENTROPY_MIN = 0;
        const VONNEUMANENTROPY_MAX = 2;
        const CONCURRENCE_MIN =  0;
        const CONCURRENCE_MAX =  1;
        const CORRELATION_MIN = -1;
        const CORRELATION_MAX =  1;

        const alpha = 0.5;
        const min_width = 0.1;

        // draw triangular half of matrix (HalfMatrix) for pairwise qubit stats
        //draw2.setLineWidth(1);
        //draw2.setStrokeColor_array(DC_foreground);
        let halfMatrixCenter_x0_pixels = draw2.convertWorldSpaceUnitsToPixelsX( halfMatrixCenter_x0 );
        let halfMatrixCenter_y0_pixels = draw2.convertWorldSpaceUnitsToPixelsY( halfMatrixCenter_y0 );

        draw2.canvas_context.save();
        draw2.canvas_context.translate( halfMatrixCenter_x0_pixels, halfMatrixCenter_y0_pixels );
        let scaleFactor = Math.SQRT1_2 / draw2.scaleFactorInWorldSpaceUnitsPerPixel;
        draw2.canvas_context.scale( scaleFactor, scaleFactor );
        draw2.canvas_context.rotate(Math.PI*0.75); // 135 degree rotation. Now, instead of (x+ right, y+ down), we have (x+ south west, y+ north west)
        let barWidth = 1/(DispOpt.HM_numMetrics*2+1);
        for ( let wire1 = 0; wire1 < C.numWires-1; wire1++ ) {
            for ( let wire2 = wire1+1; wire2 < C.numWires; wire2++ ) {
                if ( DispOpt.HM_cellContents === DispOpt.HM_RECT_GLYPHS ) {
                    // Reminder: we have (x+ south west, y+ north west)
                    //
                    // We also want to draw the glyphs with their origin in the bottom of each cell,
                    // so we define another coordinate system (a+ north west, b+ north east).
                    // Then, if we want to draw a rectangle with corner at (a,b) with dimensions (delta_a,delta_b),
                    // we can draw it with (x,y,width,height) = (1-b,a,-delta_b,delta_a)


                    // corner of cell within the half matrix, in the rotated local coordinate system of the half matrix
                    let x00 = wire1;
                    let y00 = C.numWires-1-wire2;

                    draw2.setLineWidth( draw2.scaleFactorInWorldSpaceUnitsPerPixel );
                    draw2.setStrokeColor_array(DC_foreground);
                    draw2.canvas_context.strokeRect(
                        x00, y00, 1, 1
                    );

                    // Corner of rectangular glyph, within the normalized local coordinate system of the cell
                    let a0 = 0;
                    let b0 = 0;
                    // dimensions of the rectangle glyph, normalized
                    let delta_a = ( 1-C.pairwisePurities.get(wire1,wire2)._r - LINEARENTROPY_MIN )/( LINEARENTROPY_MAX - LINEARENTROPY_MIN ) - a0;
                    if ( delta_a < min_width ) delta_a = min_width;
                    let delta_b = ( C.pairwiseEntropies.get(wire1,wire2)._r - VONNEUMANENTROPY_MIN )/( VONNEUMANENTROPY_MAX - VONNEUMANENTROPY_MIN ) - b0;
                    if ( delta_b < min_width ) delta_b = min_width;

                    draw2.setFillColor(DC_HM_mixedness[0],DC_HM_mixedness[1],DC_HM_mixedness[2],alpha);
                    draw2.setStrokeColor(DC_HM_mixedness[0],DC_HM_mixedness[1],DC_HM_mixedness[2],1.0);
                    draw2.canvas_context.fillRect( x00+(1-b0), y00+a0, -delta_b, delta_a );
                    draw2.canvas_context.strokeRect( x00+(1-b0), y00+a0, -delta_b, delta_a );

                    C.normalizedPositionsOfGlyphs[wire1][wire2][0] = delta_a + a0;
                    C.normalizedPositionsOfGlyphs[wire1][wire2][1] = delta_b + b0;

                    if ( DispOpt.HM_signedMetricsHaveZeroInCenterOfCell ) {
                        // Draws the glyph with a zero-correlation in the middle of the cell, positive correlations falling on one side of that zero,
                        // and negative correlations falling on the other side

                        a0 = 0;
                        b0 = 0.5;
                        delta_a = ( C.pairwiseConcurrences.get(wire1,wire2)._r - CONCURRENCE_MIN )/( CONCURRENCE_MAX - CONCURRENCE_MIN ) - a0;
                        if ( delta_a < min_width ) delta_a = min_width;
                        delta_b = ( C.pairwiseCorrelations.get(wire1,wire2)._r - CORRELATION_MIN )/( CORRELATION_MAX - CORRELATION_MIN ) - b0;
                        if ( Math.abs(delta_b) < min_width ) delta_b = delta_b < 0 ? -min_width : min_width;
                        if ( delta_b < 0 ) {
                            //draw2.setFillColor(DC_HM_entanglement_neg[0],DC_HM_entanglement_neg[1],DC_HM_entanglement_neg[2],alpha);
                            const gradient = draw2.canvas_context.createLinearGradient( x00+(1-b0), y00+(a0+delta_a), x00+(1-b0-delta_b), y00+(a0)); // (a,b) from (a0+delta_a,b0) to (a0,b0+delta_b)
                            gradient.addColorStop(0,`rgba(${DC_HM_entanglement_pos[0]},${DC_HM_entanglement_pos[1]},${DC_HM_entanglement_pos[2]},${alpha})`);
                            gradient.addColorStop(1,`rgba(${DC_HM_entanglement_neg[0]},${DC_HM_entanglement_neg[1]},${DC_HM_entanglement_neg[2]},${alpha})`);
                            //gradient.addColorStop(0, 'rgba(0, 0, 255, 0.5)');  // 50% transparent blue
                            //gradient.addColorStop(1, 'rgba(255, 0, 0, 0.5)');  // 50% transparent red
                            draw2.canvas_context.fillStyle = gradient;

                            draw2.setStrokeColor(DC_HM_entanglement_neg[0],DC_HM_entanglement_neg[1],DC_HM_entanglement_neg[2],1.0);
                        }
                        else {
                            draw2.setFillColor(DC_HM_entanglement_pos[0],DC_HM_entanglement_pos[1],DC_HM_entanglement_pos[2],alpha);
                            draw2.setStrokeColor(DC_HM_entanglement_pos[0],DC_HM_entanglement_pos[1],DC_HM_entanglement_pos[2],1.0);
                        }
                        draw2.canvas_context.fillRect( x00+(1-b0), y00+a0, -delta_b, delta_a );
                        draw2.canvas_context.strokeRect( x00+(1-b0), y00+a0, -delta_b, delta_a );

                        // draw a line segment to indicate where the 'zero' is for correlation
                        draw2.setStrokeColor_array(DC_foreground);
                        draw2.setLineWidth( 2 * draw2.scaleFactorInWorldSpaceUnitsPerPixel );
                        draw2.canvas_context.beginPath();
                        draw2.canvas_context.moveTo( x00+(1-b0), y00+(a0) );
                        draw2.canvas_context.lineTo( x00+(1-b0), y00+(a0+delta_a) );
                        draw2.canvas_context.stroke();
                    }
                    else {
                        a0 = 0;
                        b0 = 0;
                        delta_a = ( C.pairwiseConcurrences.get(wire1,wire2)._r - CONCURRENCE_MIN )/( CONCURRENCE_MAX - CONCURRENCE_MIN ) - a0;
                        if ( delta_a < min_width ) delta_a = min_width;
                        let absoluteCorrelation = Math.abs( C.pairwiseCorrelations.get(wire1,wire2)._r );
                        delta_b = absoluteCorrelation / CORRELATION_MAX;
                        if ( delta_b < min_width ) delta_b = min_width;
                        if ( C.pairwiseCorrelations.get(wire1,wire2)._r < 0 ) {
                            //draw2.setFillColor(DC_HM_entanglement_neg[0],DC_HM_entanglement_neg[1],DC_HM_entanglement_neg[2],alpha);
                            const gradient = draw2.canvas_context.createLinearGradient( x00+(1-b0), y00+(a0+delta_a), x00+(1-b0-delta_b), y00+(a0)); // (a,b) from (a0+delta_a,b0) to (a0,b0+delta_b)
                            gradient.addColorStop(0,`rgba(${DC_HM_entanglement_pos[0]},${DC_HM_entanglement_pos[1]},${DC_HM_entanglement_pos[2]},${alpha})`);
                            gradient.addColorStop(1,`rgba(${DC_HM_entanglement_neg[0]},${DC_HM_entanglement_neg[1]},${DC_HM_entanglement_neg[2]},${alpha})`);
                            //gradient.addColorStop(0, 'rgba(0, 0, 255, 0.5)');  // 50% transparent blue
                            //gradient.addColorStop(1, 'rgba(255, 0, 0, 0.5)');  // 50% transparent red
                            draw2.canvas_context.fillStyle = gradient;

                            draw2.setStrokeColor(DC_HM_entanglement_neg[0],DC_HM_entanglement_neg[1],DC_HM_entanglement_neg[2],1.0);
                        }
                        else {
                            draw2.setFillColor(DC_HM_entanglement_pos[0],DC_HM_entanglement_pos[1],DC_HM_entanglement_pos[2],alpha);
                            draw2.setStrokeColor(DC_HM_entanglement_pos[0],DC_HM_entanglement_pos[1],DC_HM_entanglement_pos[2],1.0);
                        }
                        draw2.canvas_context.fillRect( x00+(1-b0), y00+a0, -delta_b, delta_a );
                        draw2.canvas_context.strokeRect( x00+(1-b0), y00+a0, -delta_b, delta_a );
                    }
                    C.normalizedPositionsOfGlyphs[wire1][wire2][2] = delta_a + a0;
                    C.normalizedPositionsOfGlyphs[wire1][wire2][3] = delta_b + b0;
                }
                else {
                    // Reminder: we have (x+ south west, y+ north west)
                    let metrics = [];

                    if ( DispOpt.HM_showCorrelation ) metrics.push( { min: CORRELATION_MIN,max: CORRELATION_MAX,value:C.pairwiseCorrelations.get(wire1,wire2)._r, isMixedness:false } );
                    if ( DispOpt.HM_showConcurrence ) metrics.push( { min: CONCURRENCE_MIN,max: CONCURRENCE_MAX,value:C.pairwiseConcurrences.get(wire1,wire2)._r, isMixedness:false } );
                    if ( DispOpt.HM_showVonNeumannEntropy ) metrics.push( { min: VONNEUMANENTROPY_MIN,max: VONNEUMANENTROPY_MAX,value:C.pairwiseEntropies.get(wire1,wire2)._r, isMixedness:true } );
                    if ( DispOpt.HM_showLinearEntropy ) metrics.push( { min: LINEARENTROPY_MIN,max: LINEARENTROPY_MAX,value:1-C.pairwisePurities.get(wire1,wire2)._r, isMixedness:true } );
                    if ( DispOpt.HM_showPurity ) metrics.push( { min: PURITY_MIN,max: PURITY_MAX,value:C.pairwisePurities.get(wire1,wire2)._r, isMixedness:true } );
                    let currentX = wire1;
                    let currentY = C.numWires-1-wire2;

                    draw2.setLineWidth( draw2.scaleFactorInWorldSpaceUnitsPerPixel );
                    draw2.setStrokeColor_array(DC_foreground);
                    draw2.canvas_context.strokeRect(
                        currentX, currentY, 1, 1
                    );
                    currentX += barWidth;
                    for ( let metricIndex = 0; metricIndex < metrics.length; ++metricIndex ) {
                        let metric = metrics[ metricIndex ];
                        if ( DispOpt.HM_signedMetricsHaveZeroInCenterOfCell ) {
                            let y0 = (-metric.min)/(metric.max - metric.min);
                            let y = (metric.value - metric.min)/(metric.max - metric.min);
                            if ( metric.isMixedness ) {
                                draw2.setFillColor_array( DC_HM_mixedness );
                                draw2.canvas_context.fillRect(
                                    currentX, currentY + y, barWidth, y0-y
                                );
                            }
                            else {
                                if ( y >= y0 ) {
                                    draw2.setFillColor_array( DC_barcolor );
                                    draw2.canvas_context.fillRect(
                                        currentX, currentY + y0, barWidth, y-y0
                                    );
                                }
                                else {
                                    draw2.setFillColor_array( DC_barcolor_neg_opaque );
                                    draw2.canvas_context.fillRect(
                                        currentX, currentY + y, barWidth, y0-y
                                    );
                                }
                            }
                            if ( metric.min < 0 ) {
                                draw2.setLineWidth( 2 * draw2.scaleFactorInWorldSpaceUnitsPerPixel );
                                draw2.canvas_context.beginPath();
                                draw2.canvas_context.moveTo( currentX, currentY + y0 );
                                draw2.canvas_context.lineTo( currentX+barWidth, currentY + y0 );
                                draw2.canvas_context.stroke();
                            }
                        }
                        else {
                            let y0 = 0;
                            let absoluteMetric = Math.abs(metric.value);
                            let y = absoluteMetric / metric.max;

                            if ( metric.isMixedness ) {
                                draw2.setFillColor_array( DC_HM_mixedness );
                                draw2.canvas_context.fillRect(
                                    currentX, currentY + y, barWidth, y0-y
                                );
                            }
                            else {
                                if ( metric.value < 0 ) {
                                    draw2.setFillColor_array( DC_barcolor_neg_opaque );
                                }
                                else {
                                    draw2.setFillColor_array( DC_barcolor );
                                }
                                draw2.canvas_context.fillRect(
                                    currentX, currentY + y0, barWidth, y-y0
                                );
                            }
                        }
                        currentX += 2 * barWidth;
                    }
                }
            }
        }
        draw2.canvas_context.restore(); // restores us to (x+ right, y+ down)
    }
    drawHalfMatrixTooltip( halfMatrixCenter_x0, halfMatrixCenter_y0, /*circuit*/C, /*int*/layer/*not used yet*/, /*int*/qubit_i, /*int*/qubit_j ) {

        let row = qubit_i;
        let col = qubit_j;
        let strings = [];
        let endpoints = [];
        let tangents = [];
        let arrow_foreground_colors = [];
        let arrow_background_colors = [];
        let precision = 3;
        let metricCounter = 0;

        if ( DispOpt.HM_cellContents === DispOpt.HM_RECT_GLYPHS ) {
            strings.push( "Mixedness:" );
            endpoints.push( null );
            tangents.push( null );
            arrow_foreground_colors.push( null );
            arrow_background_colors.push( null );

            strings.push( "  Linear Entropy=" + StringUtil.numToString(1-C.pairwisePurities.get(row,col)._r,precision) );
            endpoints.push( this.transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, new Vec2(row+1,C.numWires-col-1+C.normalizedPositionsOfGlyphs[qubit_i][qubit_j][0]) ) );
            tangents.push( new Vec2(-1,1) );
            arrow_foreground_colors.push( DC_HM_mixedness_darker );
            arrow_background_colors.push( DC_HM_mixedness );

            strings.push( "  von Neumann Entropy=" + StringUtil.numToString(C.pairwiseEntropies.get(row,col)._r,precision) );
            endpoints.push( this.transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, new Vec2(row+(1-C.normalizedPositionsOfGlyphs[qubit_i][qubit_j][1]),C.numWires-col-1) ) );
            tangents.push( new Vec2(1,1) );
            arrow_foreground_colors.push( DC_HM_mixedness_darker );
            arrow_background_colors.push( DC_HM_mixedness );

            strings.push( "Intra-pair metrics:" );
            endpoints.push( null );
            tangents.push( null );
            arrow_foreground_colors.push( null );
            arrow_background_colors.push( null );

            strings.push( "  Concurrence=" + StringUtil.numToString(C.pairwiseConcurrences.get(row,col)._r,precision) );
            endpoints.push( this.transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, new Vec2(row+1,C.numWires-col-1+C.normalizedPositionsOfGlyphs[qubit_i][qubit_j][2]) ) );
            tangents.push( new Vec2(-1,1) );
            arrow_foreground_colors.push( DC_HM_entanglement_pos );
            arrow_background_colors.push( DC_HM_entanglement_pos );

            strings.push( "  Correlation=" + StringUtil.numToString(C.pairwiseCorrelations.get(row,col)._r,precision) );
            endpoints.push( this.transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, new Vec2(row+(1-C.normalizedPositionsOfGlyphs[qubit_i][qubit_j][3]),C.numWires-col-1) ) );
            tangents.push( new Vec2(1,1) );
            if ( C.pairwiseCorrelations.get(row,col)._r >= 0 ) {
                arrow_foreground_colors.push( DC_HM_entanglement_pos );
                arrow_background_colors.push( DC_HM_entanglement_pos );
            }
            else {
                arrow_foreground_colors.push( DC_HM_entanglement_neg );
                arrow_background_colors.push( DC_HM_entanglement_neg );
            }

            drawMultilineTextLabelWithOutlineAndArrows(
                endpoints[1].x-0.75, endpoints[1].y+0.5,
                0.6 * TB_ICON_SIZE*0.7 * draw2.scaleFactorInWorldSpaceUnitsPerPixel,
                strings,
                endpoints,
                Math.SQRT1_2 * Math.min( 1 / (DispOpt.HM_numMetrics+0.5), 0.5 ),
                tangents,
                arrow_foreground_colors,
                arrow_background_colors
            );
        }
        else {
            if ( DispOpt.HM_showPurity || DispOpt.HM_showLinearEntropy || DispOpt.HM_showVonNeumannEntropy ) {
                strings.push( "Mixedness:" );
                endpoints.push( null );
                arrow_foreground_colors.push( null );
                arrow_background_colors.push( null );
            }
            if ( DispOpt.HM_showPurity ) {
                strings.push( "  Purity=" + StringUtil.numToString(C.pairwisePurities.get(row,col)._r,precision) );
                endpoints.push( this.transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, new Vec2(row+1-(metricCounter+0.75)/(DispOpt.HM_numMetrics+0.5),C.numWires-col-1) ) );
                arrow_foreground_colors.push( DC_HM_mixedness_darker );
                arrow_background_colors.push( DC_HM_mixedness );
                metricCounter ++;
            }
            if ( DispOpt.HM_showLinearEntropy ) {
                strings.push( "  Linear Entropy=" + StringUtil.numToString(1-C.pairwisePurities.get(row,col)._r,precision) );
                endpoints.push( this.transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, new Vec2(row+1-(metricCounter+0.75)/(DispOpt.HM_numMetrics+0.5),C.numWires-col-1) ) );
                arrow_foreground_colors.push( DC_HM_mixedness_darker );
                arrow_background_colors.push( DC_HM_mixedness );
                metricCounter ++;
            }
            if ( DispOpt.HM_showVonNeumannEntropy ) {
                strings.push( "  von Neumann Entropy=" + StringUtil.numToString(C.pairwiseEntropies.get(row,col)._r,precision) );
                endpoints.push( this.transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, new Vec2(row+1-(metricCounter+0.75)/(DispOpt.HM_numMetrics+0.5),C.numWires-col-1) ) );
                arrow_foreground_colors.push( DC_HM_mixedness_darker );
                arrow_background_colors.push( DC_HM_mixedness );
                metricCounter ++;
            }
            if ( DispOpt.HM_showConcurrence || DispOpt.HM_showCorrelation ) {
                strings.push( "Intra-pair metrics:" );
                endpoints.push( null );
                arrow_foreground_colors.push( null );
                arrow_background_colors.push( null );
            }
            if ( DispOpt.HM_showConcurrence ) {
                strings.push( "  Concurrence=" + StringUtil.numToString(C.pairwiseConcurrences.get(row,col)._r,precision) );
                endpoints.push( this.transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, new Vec2(row+1-(metricCounter+0.75)/(DispOpt.HM_numMetrics+0.5),C.numWires-col-1) ) );
                arrow_foreground_colors.push( DC_HM_entanglement_pos );
                arrow_background_colors.push( DC_HM_entanglement_pos );
                metricCounter ++;
            }
            if ( DispOpt.HM_showCorrelation ) {
                strings.push( "  Correlation=" + StringUtil.numToString(C.pairwiseCorrelations.get(row,col)._r,precision) );
                endpoints.push( this.transformPairwiseMatrixSpaceToWorldSpace( halfMatrixCenter_x0, halfMatrixCenter_y0, new Vec2(row+1-(metricCounter+0.75)/(DispOpt.HM_numMetrics+0.5),C.numWires-col-1) ) );
                if ( C.pairwiseCorrelations.get(row,col)._r >= 0 ) {
                    arrow_foreground_colors.push( DC_HM_entanglement_pos );
                    arrow_background_colors.push( DC_HM_entanglement_pos );
                }
                else {
                    arrow_foreground_colors.push( DC_HM_entanglement_neg );
                    arrow_background_colors.push( DC_HM_entanglement_neg );
                }
                metricCounter ++;
            }

            drawMultilineTextLabelWithOutlineAndArrows(
                endpoints[1].x-0.5, endpoints[1].y+0.5,
                0.6 * TB_ICON_SIZE*0.7 * draw2.scaleFactorInWorldSpaceUnitsPerPixel,
                strings,
                endpoints,
                Math.SQRT1_2 * Math.min( 1 / (DispOpt.HM_numMetrics+0.5), 0.5 ),
                [ new Vec2(1,1) ],
                arrow_foreground_colors,
                arrow_background_colors
            );
        }
    }
    // XXX YYY test that all these new gates are visualized correctly:
    /*
        (done, not tested) CP_ZE, CP_PH
        (done, not tested) CP_YG, similar to Y and Z
        (done, not tested) CP_ZG, similar to Z and Y
        (done, not tested) CP_HG, similar to Y and H
        (done, not tested) CP_GP, similar to ZG (all amplitudes should be green, except when control bits)
        but don't visualize CP_RZ
    */
    drawStateVector(
        /*world*/ _x0, /*world*/ _y0,
        /*circuit*/ C, /*int*/ stage,
        /*bool*/ drawDiffVis,
        /*bool*/ drawTextInsideCells,
        /*bool*/ drawTextOutsideCells,
        /*int, -1 for none*/ highlightedBit,
        /*float*/ alpha
    ) {
        let diffvis_gateWire = -1;
        let diffvis_gateWire2 = -1;
        let show_diffvis_forXGate = false;
        let show_diffvis_forYGate = false;
        let show_diffvis_forRotationGate = false;
        let show_diffvis_forHGate = false;
        let show_diffvis_forSwapGates = false;
        // The "half block" terminology is the same as used in Sim.qubitWiseMultiply()
        let diffvis_showHighlightInHalfBlock0 = false;
        let diffvis_showHighlightInHalfBlock1 = false;
        let diffvis_useSameHighlightColorForBothBlocks = false;
        let diffvis_showSplinesConnectingHalfBlocks = false;
        let diffvis_showArithmeticOperatorsOnSpline = false;
        let diffvis_rotationAngleForHalfBlock0 = 0;
        let diffvis_rotationAngleForHalfBlock1 = 0;
        let diffvis_verticallyCenterRotationAngle = false;
        let diffvis_stateInclusionMask = 0;
        let diffvis_stateDesiredValue = 0;
        let diffvis_swap_mask_i;
        let diffvis_swap_mask_j;
        let diffvis_swap_antimask;

        // used to draw splines to show diffvis for X gate
        let diffvis_listOfCellCenters_earlierCells_inProgress = [];
        let diffvis_listOfCellCenters_laterCells_inProgress = [];
        let diffvis_listOfCellCenters_earlierCells_complete = [];
        let diffvis_listOfCellCenters_laterCells_complete = [];

        if ( drawDiffVis && stage < C.numStages ) {
            // determine what kind of diffvis to show
            let numSupportedGateParts = 0; // not including swap gate parts, control and anti-control bits
            let numSwapParts = 0;
            let numUnsupportedParts = 0;
            for ( let w = 0; w < C.numWires; ++w ) {
                let bit = (1<<w);
                let circuitPart = C.getCellContents(w,stage);
                let circuitPart_id = C.getCircuitPartIDOfCell(w,stage);
                if ( circuitPart_id === CP_X ) {
                    numSupportedGateParts ++;
                    diffvis_gateWire = w;
                    show_diffvis_forXGate = true;
                    diffvis_showHighlightInHalfBlock0 = true;
                    diffvis_showHighlightInHalfBlock1 = true;
                    diffvis_showSplinesConnectingHalfBlocks = true;
                }
                else if ( circuitPart_id === CP_Y ) {
                    numSupportedGateParts ++;
                    diffvis_gateWire = w;
                    show_diffvis_forYGate = true;
                    diffvis_showHighlightInHalfBlock0 = true;
                    diffvis_showHighlightInHalfBlock1 = true;
                    diffvis_showSplinesConnectingHalfBlocks = true;
                    diffvis_rotationAngleForHalfBlock0 = 90;
                    diffvis_rotationAngleForHalfBlock1 = -90;
                    diffvis_verticallyCenterRotationAngle = false;
                }
                else if ( circuitPart_id === CP_YG ) {
                    numSupportedGateParts ++;
                    diffvis_gateWire = w;
                    diffvis_showHighlightInHalfBlock0 = true;
                    diffvis_showHighlightInHalfBlock1 = true;
                    diffvis_showSplinesConnectingHalfBlocks = true;
                    diffvis_rotationAngleForHalfBlock0 = circuitPart.paramValues[0];
                    diffvis_rotationAngleForHalfBlock1 = circuitPart.paramValues[1];
                    diffvis_verticallyCenterRotationAngle = false;
                }
                else if ( circuitPart_id === CP_H ) {
                    numSupportedGateParts ++;
                    diffvis_gateWire = w;
                    show_diffvis_forHGate = true;
                    diffvis_showHighlightInHalfBlock0 = true;
                    diffvis_showHighlightInHalfBlock1 = true;
                    diffvis_showSplinesConnectingHalfBlocks = true;
                    diffvis_showArithmeticOperatorsOnSpline = true;
                }
                else if ( circuitPart_id === CP_HG ) {
                    numSupportedGateParts ++;
                    diffvis_gateWire = w;
                    diffvis_showHighlightInHalfBlock0 = true;
                    diffvis_showHighlightInHalfBlock1 = true;
                    diffvis_showSplinesConnectingHalfBlocks = true;
                    diffvis_showArithmeticOperatorsOnSpline = true;
                    diffvis_rotationAngleForHalfBlock0 = circuitPart.paramValues[0];
                    diffvis_rotationAngleForHalfBlock1 = circuitPart.paramValues[1];
                    diffvis_verticallyCenterRotationAngle = false;
                }
                else if (
                    circuitPart_id === CP_Z
                    || circuitPart_id === CP_SZ
                    || circuitPart_id === CP_SSZ
                    || circuitPart_id === CP_invSZ
                    || circuitPart_id === CP_invSSZ
                    || circuitPart_id === CP_ZE
                    || circuitPart_id === CP_PH
                ) {
                    numSupportedGateParts ++;
                    diffvis_gateWire = w;
                    show_diffvis_forRotationGate = true;
                    diffvis_showHighlightInHalfBlock0 = false;
                    diffvis_showHighlightInHalfBlock1 = true;
                    if ( circuitPart_id === CP_Z )
                        diffvis_rotationAngleForHalfBlock1 = 180;
                    else if ( circuitPart_id === CP_SZ )
                        diffvis_rotationAngleForHalfBlock1 = 90;
                    else if ( circuitPart_id === CP_SSZ )
                        diffvis_rotationAngleForHalfBlock1 = 45;
                    else if ( circuitPart_id === CP_invSZ )
                        diffvis_rotationAngleForHalfBlock1 = -90;
                    else if ( circuitPart_id === CP_invSSZ )
                        diffvis_rotationAngleForHalfBlock1 = -45;
                    else if ( circuitPart_id === CP_ZE )
                        diffvis_rotationAngleForHalfBlock1 = circuitPart.paramValues[0] * 180;
                    else if ( circuitPart_id === CP_PH )
                        diffvis_rotationAngleForHalfBlock1 = circuitPart.paramValues[0];
                    diffvis_verticallyCenterRotationAngle = true;
                }
                else if ( circuitPart_id === CP_ZG ) {
                    numSupportedGateParts ++;
                    diffvis_gateWire = w;
                    diffvis_showHighlightInHalfBlock0 = true;
                    diffvis_showHighlightInHalfBlock1 = true;
                    diffvis_rotationAngleForHalfBlock0 = circuitPart.paramValues[0];
                    diffvis_rotationAngleForHalfBlock1 = circuitPart.paramValues[1];
                    diffvis_verticallyCenterRotationAngle = false;
                }
                else if ( circuitPart_id === CP_GP ) {
                    numSupportedGateParts ++;
                    diffvis_gateWire = w;
                    diffvis_showHighlightInHalfBlock0 = true;
                    diffvis_showHighlightInHalfBlock1 = true;
                    diffvis_useSameHighlightColorForBothBlocks = true;
                    diffvis_rotationAngleForHalfBlock1 = circuitPart.paramValues[0];
                    diffvis_verticallyCenterRotationAngle = true;
                }
                else if ( circuitPart_id === CP_SWAP ) {
                    numSwapParts ++;
                    if ( diffvis_gateWire < 0 )
                        diffvis_gateWire = w;
                    else {
                        diffvis_gateWire2 = w;
                        show_diffvis_forSwapGates = true;
                    }
                }
                else if ( circuitPart_id === CP_CB ) {
                    diffvis_stateInclusionMask |= bit;
                    diffvis_stateDesiredValue |= bit;
                }
                else if ( circuitPart_id === CP_ACB ) {
                    diffvis_stateInclusionMask |= bit;
                }
                else if ( circuitPart_id !== CP_EMPTY && circuitPart_id !== CP_I ) {
                    numUnsupportedParts ++;
                    diffvis_gateWire = w;
                    diffvis_showHighlightInHalfBlock0 = true;
                    diffvis_showHighlightInHalfBlock1 = true;
                }
            }
            let totalNumParts = numSupportedGateParts + numSwapParts + numUnsupportedParts; // not including control and anti-control bits
            if (
                ( totalNumParts===1 && numSupportedGateParts===1 )
                || ( totalNumParts===2 && numSwapParts===2 )
            ) {
                // no problem
            }
            else if ( totalNumParts===1 && numUnsupportedParts===1 ) {
                // also no problem; we will still show highlighting of half blocks
            }
            else {
                // we don't support this case at all, so turn off all diff visual feedback for this layer
                show_diffvis_forXGate = false;
                show_diffvis_forYGate = false;
                show_diffvis_forRotationGate = false;
                show_diffvis_forHGate = false;
                show_diffvis_forSwapGates = false;
                diffvis_showHighlightInHalfBlock0 = false;
                diffvis_showHighlightInHalfBlock1 = false;
                diffvis_showSplinesConnectingHalfBlocks = false;
                diffvis_showArithmeticOperatorsOnSpline = false;
                diffvis_rotationAngleForHalfBlock0 = 0;
                diffvis_rotationAngleForHalfBlock1 = 0;
                diffvis_verticallyCenterRotationAngle = false;
            }

            if ( show_diffvis_forSwapGates ) {
                diffvis_swap_mask_i = 1 << diffvis_gateWire;
                diffvis_swap_mask_j = 1 << diffvis_gateWire2;
                diffvis_swap_antimask = ~( diffvis_swap_mask_i | diffvis_swap_mask_j );
            }
        }

        // draw diffvis for rotations
        if ( diffvis_rotationAngleForHalfBlock0 || diffvis_rotationAngleForHalfBlock1 ) {
            let numAnglesToDraw = ( diffvis_rotationAngleForHalfBlock0!==0 ? 1 : 0 ) + ( diffvis_rotationAngleForHalfBlock1!==0 ? 1 : 0 );
            for ( let block = 0; block <= 1; ++block ) {
                let angleInDegrees = block===0 ? diffvis_rotationAngleForHalfBlock0 : diffvis_rotationAngleForHalfBlock1;
                if ( angleInDegrees === 0 )
                    continue;
                let angle = - angleInDegrees / 180 * Math.PI; // convert to radians
                let radius, x, y;
                if ( Math.abs(angleInDegrees) <= 90 ) {
                    radius = PLV_space_w / 3;
                    x = _x0 + SV_col_w + radius;
                }
                else {
                    radius = PLV_space_w * 0.25;
                    x = _x0 + SV_col_w + PLV_space_w/2;
                }
                if ( diffvis_verticallyCenterRotationAngle ) {
                    y = _y0 + SV_total_h / 2;
                }
                else {
                    y = _y0 + ( (block===0) ? 0 : SV_total_h );
                }
                draw2.setFillColor_array( block===0 ? DC_diffvis_1_background : DC_diffvis_2_background );
                draw2.drawArc( x, y, radius, 0, angle, true );
                draw2.drawArc( x, y, radius, 0, angle, false );
                let cosine = Math.cos( angle );
                let sine = Math.sin( angle );
                let arrow_tip_x = x + radius * cosine;
                let arrow_tip_y = y + radius * sine;
                draw2.setFillColor_array( block===0 ? DC_diffvis_1_foreground : DC_diffvis_2_foreground );
                draw2.drawArrowHead( arrow_tip_x, arrow_tip_y, angleInDegrees < 0 ? - sine : sine, angleInDegrees < 0 ? cosine : - cosine, radius/3 );
            }
        }

        let length_of_substring_in_bitstring_to_highlight = 0; // by default, this highlighting is suppressed by setting this length to zero
        if ( this.highlighted_mode === CVH_CIRCUIT && highlightedBit >= 0 ) {
            length_of_substring_in_bitstring_to_highlight = 1;
        }

        let min_log2_probability = -1;
        let max_minus_min_log2_probability = 1;
        if ( DispOpt.barFunction === DispOpt.BARFUNCTION_LOG_PROBABILITY ) {
            let max_log2_probability = 0;
            let areMinAndMaxInitialized = false;
            let numNonzeroAmplitudes = 0;
            for ( let state = 0; state < C.stateVectors[ stage ]._rows; ++state ) {
                let probability = C.stateVectors[ stage ].get(state,0).magSquared();
                if ( probability > 0 ) {
                    numNonzeroAmplitudes ++;
                    let log2_p = Math.log2( probability );
                    if ( ! areMinAndMaxInitialized ) {
                        min_log2_probability = max_log2_probability = log2_p;
                        areMinAndMaxInitialized = true;
                    }
                    else {
                        if ( log2_p < min_log2_probability ) min_log2_probability = log2_p;
                        else if ( log2_p > max_log2_probability ) max_log2_probability = log2_p;
                    }
                }
            }
            max_minus_min_log2_probability = max_log2_probability - min_log2_probability;
            if ( max_minus_min_log2_probability < 0.001 ) {
                // This can happen if only one value of probability was encountered, maybe multiple times.
                // For example, we may have encountered only 1.0 once (resulting in a min and max of 0);
                // or 0.5 twice (resulting in a min and max of -1);
                // or 0.25 four times (resulting in a min and max of -2).
                // We force there to be a difference between the min and max.
                if ( numNonzeroAmplitudes === 1 ) {
                    // probability is 1.0, and we want log(probability) to be at the top end of the range [min,max]
                    max_log2_probability = 0;
                    min_log2_probability = -1;
                }
                else {
                    // There are multiple non-zero amplitudes, and they all have (nearly) the same magnitude.
                    // This will make it so their log2(probability) is in the center of the range of [min,max]
                    max_log2_probability = 0;
                    min_log2_probability *= 2;
                }
                max_minus_min_log2_probability = max_log2_probability - min_log2_probability;
            }
            else {
                // Make it so the min probability isn't quite mapped to the bottom end of the range [min,max]
                max_minus_min_log2_probability *= 1.2;
                min_log2_probability = max_log2_probability - max_minus_min_log2_probability;
            }
        }

        const margin = 0.1;
        let areCellsRectangular = ( DispOpt.cell_aspectRatio > 1 );
        for ( let state = 0; state < C.stateVectors[ stage ]._rows; ++state ) {
            // used to draw splines to implement diffvis_showSplinesConnectingHalfBlocks
            let diffvis_drawSplineUsingListsOfCellCenters = false;

            let _cell_x0 = _x0 + (state % SV_numCols) * SV_cell_w;
            let _cell_y0 = _y0 + Math.floor(state / SV_numCols) * SV_cell_h;
            let circle_radius = SV_cell_h / 2;
            let circle_x = _cell_x0 + SV_cell_w - circle_radius;
            let circle_y = _cell_y0 + circle_radius;

            let circle_hand_angle = - C.stateVectors[ stage ].get(state,0).arg();
            let circle_hand_x = circle_x + circle_radius*Math.cos(circle_hand_angle);
            let circle_hand_y = circle_y + circle_radius*Math.sin(circle_hand_angle);

            let barcolor = DC_barcolor;


            // draw diffvis between this stage and the next
            if ( (state & diffvis_stateInclusionMask) === diffvis_stateDesiredValue ) {
                if ( diffvis_showHighlightInHalfBlock0 || diffvis_showHighlightInHalfBlock1 || diffvis_showSplinesConnectingHalfBlocks || show_diffvis_forSwapGates ) {
                    if ( diffvis_showHighlightInHalfBlock0 || diffvis_showHighlightInHalfBlock1 ) {
                        if ( diffvis_useSameHighlightColorForBothBlocks ) {
                            draw2.setFillColor_array(DC_diffvis_2_background);
                            barcolor = DC_diffvis_2_foreground;
                            draw2.fillRect( _cell_x0, _cell_y0, SV_cell_w, SV_cell_h );
                        }
                        else if ( (( state >> diffvis_gateWire ) & 1) == 0 ) {
                            if ( diffvis_showHighlightInHalfBlock0 ) {
                                draw2.setFillColor_array(DC_diffvis_1_background);
                                barcolor = DC_diffvis_1_foreground;
                                draw2.fillRect( _cell_x0, _cell_y0, SV_cell_w, SV_cell_h );
                            }
                        }
                        else {
                            if ( diffvis_showHighlightInHalfBlock1 ) {
                                draw2.setFillColor_array(DC_diffvis_2_background);
                                barcolor = DC_diffvis_2_foreground;
                                draw2.fillRect( _cell_x0, _cell_y0, SV_cell_w, SV_cell_h );
                            }
                        }
                    }
                    if ( diffvis_showSplinesConnectingHalfBlocks ) {
                        let cellCenter = new Vec2( _cell_x0+SV_cell_w/2, _cell_y0+SV_cell_h/2 );
                        if ( (( state >> diffvis_gateWire ) & 1) == 0 ) {

                            if ( diffvis_listOfCellCenters_laterCells_inProgress.length > 0 ) {
                                // We have encountered the first of a *new* group of 'earlier' cells
                                // within this stage,
                                // so we need to trigger the drawing of the spline for the previous
                                // groups of 'earlier' and 'later' cells.
                                diffvis_listOfCellCenters_earlierCells_complete = diffvis_listOfCellCenters_earlierCells_inProgress;
                                diffvis_listOfCellCenters_laterCells_complete = diffvis_listOfCellCenters_laterCells_inProgress;
                                diffvis_listOfCellCenters_earlierCells_inProgress = [];
                                diffvis_listOfCellCenters_laterCells_inProgress = [];

                                diffvis_drawSplineUsingListsOfCellCenters = true;
                            }

                            diffvis_listOfCellCenters_earlierCells_inProgress.push( cellCenter );
                        }
                        else {
                            diffvis_listOfCellCenters_laterCells_inProgress.push( cellCenter );
                        }
                    }

                    if ( show_diffvis_forSwapGates ) {
                        let ithBit = (state >> diffvis_gateWire) & 1;
                        let jthBit = (state >> diffvis_gateWire2) & 1;
                        if ( ithBit !== jthBit ) { // this cell's amplitude is swapped with another cell's
                            if ( jthBit===0 ) { // we are encountering the first of the pair of cells
                                draw2.setFillColor_array(DC_diffvis_1_background);
                                barcolor = DC_diffvis_1_foreground;
                            }
                            else {
                                draw2.setFillColor_array(DC_diffvis_2_background);
                                barcolor = DC_diffvis_2_foreground;
                            }
                            draw2.fillRect( _cell_x0, _cell_y0, SV_cell_w, SV_cell_h );
                        }
                    }
                }
            }

            let magnitude = C.stateVectors[ stage ].get(state,0).mag();
            let probability = C.stateVectors[ stage ].get(state,0).magSquared();
            let barLength = probability;
            switch ( DispOpt.barFunction ) {
            case DispOpt.BARFUNCTION_PROBABILITY:
                barLength = probability;
                break;
            case DispOpt.BARFUNCTION_MAGNITUDE:
                barLength = magnitude;
                break;
            case DispOpt.BARFUNCTION_LOG_PROBABILITY:
                barLength = ( Math.log2( probability ) - min_log2_probability ) / max_minus_min_log2_probability;
                break;
            }
            if ( areCellsRectangular ) {
                barLength *= SV_cell_w-SV_cell_h;
            }
            else { // square shaped cell
                barLength *= SV_cell_h;
            }

            // draw bar inside the cell
            if ( barLength > 0 ) {
                draw2.setFillColor(barcolor[0],barcolor[1],barcolor[2],alpha);
                draw2.fillRect( _cell_x0, _cell_y0, barLength, SV_cell_h );
            }
            // draw strings inside the cell
            if ( areCellsRectangular && drawTextInsideCells ) {
                draw2.setFillColor_array(DC_foreground);
                let upperLeft = new Vec2( _cell_x0, _cell_y0 );
                let lowerRight = new Vec2(
                    _cell_x0+SV_cell_w-SV_cell_h,
                    _cell_y0+( (DispOpt.displayInsideBitstring&&DispOpt.displayInsideProbability) ? SV_cell_h/2 : SV_cell_h )
                );
                if ( DispOpt.displayInsideBitstring ) {
                    draw2.drawStringCenteredInRectangle(
                        new Box2(upperLeft,lowerRight),
                        StringUtil.intToBinaryString( state, C.numWires ),
                        margin,
                        TD_HORIZONTALLY_RIGHT
                        //
                        // ,
                        // C.numWires-1 - highlightedBit, // index of char to highlight
                        // length_of_substring_in_bitstring_to_highlight
                    );
                }
                if ( DispOpt.displayInsideBitstring && DispOpt.displayInsideProbability ) {
                    upperLeft.y += SV_cell_h/2;
                    lowerRight.y += SV_cell_h/2;
                }
                if ( DispOpt.displayInsideProbability && probability > 0 ) {
                    draw2.drawStringCenteredInRectangle(
                        new Box2(upperLeft,lowerRight),
                        StringUtil.numToString( probability ),
                        margin,
                        TD_HORIZONTALLY_RIGHT
                    );
                }
            }

            // draw phase glyph inside the cell
            if ( barLength > 0 ) {
                draw2.drawCircle( circle_x, circle_y, circle_radius );
                draw2.drawLine( circle_x, circle_y, circle_hand_x, circle_hand_y );
            }
            // draw rectangle around the cell
            draw2.drawRect( _cell_x0, _cell_y0, SV_cell_w, SV_cell_h );

            if ( (state & diffvis_stateInclusionMask) === diffvis_stateDesiredValue ) {
                if ( show_diffvis_forSwapGates ) {
                    {
                        let ithBit = (state >> diffvis_gateWire) & 1;
                        let jthBit = (state >> diffvis_gateWire2) & 1;
                        if ( ithBit !== jthBit ) { // this cell's amplitude is swapped with another cell's

                            if ( jthBit===1 ) { // we are encountering the second of the pair of cells
                                let otherState = state;
                                otherState &= diffvis_swap_antimask; // turns off bits i and j
                                otherState |= diffvis_swap_mask_i; // turns on bit i
                                Util.assert( otherState < state, "unexpected condition when drawing diffvis for swap" );

                                let cell_center_x = _cell_x0+SV_cell_w/2;
                                let cell_center_y = _cell_y0+SV_cell_h/2;
                                let otherCell_center_x = _x0 + ((otherState % SV_numCols)+0.5) * SV_cell_w;
                                let otherCell_center_y = _y0+(Math.floor(otherState / SV_numCols)+0.5) * SV_cell_h;

                                // draw a spline connecting the two cells
                                if ( state % SV_numCols === otherState % SV_numCols ) {
                                    // the two cells are in the same column

                                    let direction_x
                                        = (((state % SV_numCols)/(SV_numCols-1)) > 0.5)
                                        ? 1 // we are in the right half of the StateVectorVisualization1
                                        : -1; // we are in the left half
                                    draw2.setLineWidth( diffvis_forSwapGates_thickness ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                                    draw2.drawSpline(
                                        otherCell_center_x + direction_x*SV_arrowHeadLength2*SV_cell_h,
                                        otherCell_center_y,
                                        cell_center_x + direction_x*SV_arrowHeadLength2*SV_cell_h,
                                        cell_center_y,
                                        direction_x, 0, direction_x, 0,
                                        SV_splineTangentWeight, SV_splineTangentWeight
                                    );
                                    draw2.setFillColor_array(DC_diffvis_1_foreground);
                                    draw2.drawArrowHead(
                                        otherCell_center_x, otherCell_center_y,
                                        - direction_x, 0,
                                        SV_arrowHeadLength2 * SV_cell_h
                                    );
                                    draw2.setFillColor_array(DC_diffvis_2_foreground);
                                    draw2.drawArrowHead(
                                        cell_center_x, cell_center_y,
                                        - direction_x, 0,
                                        SV_arrowHeadLength2 * SV_cell_h
                                    );
                                    draw2.setLineWidth( 1 ); // TODO_lineWidth
                                }
                                else if ( Math.floor(state / SV_numCols) === Math.floor(otherState / SV_numCols) ) {
                                    // the two cells are in the same row

                                    let direction_y
                                        = ((state / C.stateVectors[ stage ]._rows) > 0.5)
                                        ? 1 // we are in the bottom half of the StateVectorVisualization1
                                        : -1; // we are in the top half
                                    draw2.setLineWidth( diffvis_forSwapGates_thickness ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                                    draw2.drawSpline(
                                        otherCell_center_x,
                                        otherCell_center_y + direction_y*SV_arrowHeadLength2*SV_cell_h,
                                        cell_center_x,
                                        cell_center_y + direction_y*SV_arrowHeadLength2*SV_cell_h,
                                        0, direction_y, 0, direction_y,
                                        SV_splineTangentWeight, SV_splineTangentWeight
                                    );
                                    draw2.setFillColor_array(DC_diffvis_1_foreground);
                                    draw2.drawArrowHead(
                                        otherCell_center_x, otherCell_center_y,
                                        0, - direction_y,
                                        SV_arrowHeadLength2 * SV_cell_h
                                    );
                                    draw2.setFillColor_array(DC_diffvis_2_foreground);
                                    draw2.drawArrowHead(
                                        cell_center_x, cell_center_y,
                                        0, - direction_y,
                                        SV_arrowHeadLength2 * SV_cell_h
                                    );
                                    draw2.setLineWidth( 1 ); // TODO_lineWidth
                                }
                                else if ( otherCell_center_x < cell_center_x ) {
                                    // the other cell is north west of the current cell
                                    // TODO I think this case actually never happens, but I'll leave this code here just in case

                                    Util.assert( otherCell_center_y < cell_center_y, "unexpected condition when drawing diffvis for swap" );

                                    draw2.setLineWidth( diffvis_forSwapGates_thickness ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                                    draw2.drawSpline(
                                        otherCell_center_x, otherCell_center_y, cell_center_x, cell_center_y,
                                        1, 0, -1, 0,
                                        SV_splineTangentWeight, SV_splineTangentWeight
                                    );
                                    draw2.setFillColor_array(DC_diffvis_1_foreground);
                                    draw2.drawArrowHead(
                                        otherCell_center_x, otherCell_center_y,
                                        -1, 0,
                                        SV_arrowHeadLength2 * SV_cell_h
                                    );
                                    draw2.setFillColor_array(DC_diffvis_2_foreground);
                                    draw2.drawArrowHead(
                                        cell_center_x, cell_center_y,
                                        1, 0,
                                        SV_arrowHeadLength2 * SV_cell_h
                                    );
                                    draw2.setLineWidth( 1 ); // TODO_lineWidth
                                }
                                else {
                                    // the other cell is north east of the current cell
                                    Util.assert( otherCell_center_y < cell_center_y, "unexpected condition when drawing diffvis for swap" );

                                    draw2.setLineWidth( diffvis_forSwapGates_thickness ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                                    draw2.drawSpline(
                                        otherCell_center_x, otherCell_center_y, cell_center_x, cell_center_y,
                                        -1, 0, 1, 0,
                                        SV_splineTangentWeight, SV_splineTangentWeight
                                    );
                                    draw2.setFillColor_array(DC_diffvis_1_foreground);
                                    draw2.drawArrowHead(
                                        otherCell_center_x, otherCell_center_y,
                                        1, 0,
                                        SV_arrowHeadLength2 * SV_cell_h
                                    );
                                    draw2.setFillColor_array(DC_diffvis_2_foreground);
                                    draw2.drawArrowHead(
                                        cell_center_x, cell_center_y,
                                        -1, 0,
                                        SV_arrowHeadLength2 * SV_cell_h
                                    );
                                    draw2.setLineWidth( 1 ); // TODO_lineWidth
                                }
                            }
                        }
                    }
                }
            }

            if ( diffvis_showSplinesConnectingHalfBlocks && state === C.stateVectors[ stage ]._rows -1 ) {
                // We have reached the last cell of the stage,
                // so we need to trigger the drawing of the spline for the last
                // groups of 'earlier' and 'later' cells.

                diffvis_listOfCellCenters_earlierCells_complete = diffvis_listOfCellCenters_earlierCells_inProgress;
                diffvis_listOfCellCenters_laterCells_complete = diffvis_listOfCellCenters_laterCells_inProgress;
                diffvis_listOfCellCenters_earlierCells_inProgress = [];
                diffvis_listOfCellCenters_laterCells_inProgress = [];

                diffvis_drawSplineUsingListsOfCellCenters = true;
            }

            // draw spline for diffvis
            if ( diffvis_drawSplineUsingListsOfCellCenters ) {
                const biggerArrowHeadFactor = 1.8;
                let center_earlier = Vec2.centroid( diffvis_listOfCellCenters_earlierCells_complete );
                let center_later = Vec2.centroid( diffvis_listOfCellCenters_laterCells_complete );
                if ( diffvis_gateWire < SV_numColBits ) {
                    // draw spline above the StateVectorVisualization1
                    let y = _y0 - SV_cell_h/2;
                    let delta = Math.abs( center_later.x - center_earlier.x );
                    draw2.drawSpline(
                        center_earlier.x, y,
                        center_later.x, y,
                        1, -2, -1, -2,
                        SV_splineTangentWeight, SV_splineTangentWeight
                    );

                    let arrowHeadLength = biggerArrowHeadFactor * SV_arrowHeadLength * delta;
                    if ( arrowHeadLength < SV_cell_h/2 ) arrowHeadLength = SV_cell_h/2;
                    else if ( arrowHeadLength > SV_cell_h ) arrowHeadLength = SV_cell_h;

                    draw2.setFillColor_array(DC_diffvis_1_foreground);
                    if ( diffvis_showArithmeticOperatorsOnSpline )
                        draw2.drawArithmeticOperator( center_earlier.x, y, arrowHeadLength, "+" );
                    else
                        draw2.drawArrowHead(
                            center_earlier.x, y,
                            -1, 2,
                            arrowHeadLength
                        );
                    draw2.setFillColor_array(DC_diffvis_2_foreground);
                    if ( diffvis_showArithmeticOperatorsOnSpline )
                        draw2.drawArithmeticOperator( center_later.x, y, arrowHeadLength, "-" );
                    else
                        draw2.drawArrowHead(
                            center_later.x, y,
                            1, 2,
                            arrowHeadLength
                        );
                }
                else {
                    // draw spline to the right of the StateVectorVisualization1
                    let margin = SV_cell_h/2;
                    let x = _x0 + SV_col_w + margin;
                    let delta = Math.abs( center_later.y - center_earlier.y );
                    draw2.drawSpline(
                        x, center_earlier.y,
                        x, center_later.y,
                        2, 1, 2, -1,
                        SV_splineTangentWeight, SV_splineTangentWeight,
                        SV_col_w - 2*margin
                    );

                    let arrowHeadLength = biggerArrowHeadFactor * SV_arrowHeadLength * delta;
                    if ( arrowHeadLength < SV_cell_h/3 ) arrowHeadLength = SV_cell_h/3;
                    else if ( arrowHeadLength > SV_cell_h ) arrowHeadLength = SV_cell_h;

                    draw2.setFillColor_array(DC_diffvis_1_foreground);
                    if ( diffvis_showArithmeticOperatorsOnSpline )
                        draw2.drawArithmeticOperator( x, center_earlier.y, arrowHeadLength, "+" );
                    else
                        draw2.drawArrowHead(
                            x, center_earlier.y,
                            -2, -1,
                            arrowHeadLength
                        );
                    draw2.setFillColor_array(DC_diffvis_2_foreground);
                    if ( diffvis_showArithmeticOperatorsOnSpline )
                        draw2.drawArithmeticOperator( x, center_later.y, arrowHeadLength, "-" );
                    else
                        draw2.drawArrowHead(
                            x, center_later.y,
                            -2, 1,
                            arrowHeadLength
                        );
                }
            }

        } // for state

        if ( drawTextOutsideCells ) {
            // draw the bit strings outside the cells
            draw2.setFillColor_array(DC_foreground);
            draw2.setStrokeColor_array(DC_highlight_wire);

            // This is necessary because, without this shift, the bitstrings are sometimes drawn on top of diffvis visual feedback
            let shift_x = ( stage < C.numStages ) ? PLV_space_w : 0;

            if ( true ) {
                if ( SV_numCols===1 ) {
                    for ( let state = 0; state < C.stateVectors[ stage ]._rows; ++state ) {
                        // upper-left corner of the (state)th cell
                        let cell_x0 = _x0;
                        let cell_y0 = _y0 + state * SV_cell_h;

                        draw2.drawStringCenteredInRectangle(
                            new Box2(
                                new Vec2( cell_x0+SV_cell_w+shift_x, cell_y0 ),
                                new Vec2( cell_x0+SV_cell_w+shift_x+SV_cell_h*DispOpt.OUTSIDE_BITSTRING_ASPECTRATIO, cell_y0+SV_cell_h )
                            ),
                            StringUtil.intToBinaryString( state, C.numWires ),
                            margin,
                            TD_HORIZONTALLY_RIGHT,
                            C.numWires-1 - highlightedBit, // index of char to highlight
                            length_of_substring_in_bitstring_to_highlight // this may be zero, which will just suppress the highlighting
                        );
                    }
                }
                else {
                    // labels for rows
                    for ( let r = 0; r < SV_numRows; ++r ) {
                        // upper-left corner of left-most cell within the (r)th row
                        let cell_x0 = _x0;
                        let cell_y0 = _y0 + r * SV_cell_h;

                        draw2.drawStringCenteredInRectangle(
                            new Box2(
                                new Vec2( cell_x0+SV_col_w+shift_x, cell_y0 ),
                                new Vec2( cell_x0+SV_col_w+shift_x+SV_cell_h*DispOpt.OUTSIDE_BITSTRING_ASPECTRATIO, cell_y0+SV_cell_h )
                            ),
                            StringUtil.intToBinaryString( r, SV_numRowBits ) + '…',
                            margin,
                            TD_HORIZONTALLY_RIGHT,
                            C.numWires-1 - highlightedBit, // index of char to highlight. if out of bounds, highlighting is just suppressed.
                            length_of_substring_in_bitstring_to_highlight // this may be zero, which will just suppress the highlighting
                        );
                    }
                    // labels for columns
                    for ( let c = 0; c < SV_numCols; ++c ) {
                        // upper-left corner of top-most cell within the (c)th column
                        let cell_x0 = _x0 + c * SV_cell_w;
                        let cell_y0 = _y0;

                        draw2.drawStringCenteredInRectangle(
                            new Box2(
                                new Vec2( cell_x0, cell_y0 + SV_cell_h * SV_numRows ),
                                new Vec2( cell_x0 + SV_cell_w, cell_y0 + SV_cell_h * (SV_numRows+DispOpt.OUTSIDE_BITSTRING_ASPECTRATIO) )
                            ),
                            '…' + StringUtil.intToBinaryString( c, SV_numColBits ),
                            margin,
                            TD_VERTICALLY_DOWN,
                            SV_numColBits - highlightedBit, // index of char to highlight. if out of bounds, highlighting is just suppressed.
                            length_of_substring_in_bitstring_to_highlight // this may be zero, which will just suppress the highlighting
                        );
                    }
                }
            }
        } // if drawTextOutsideCells
    }
    drawStateVectorTooltip( /*world*/x0, /*world*/y0, /*circuit*/C, /*int*/layer, /*int*/state ) {
        // TODO not implemented
    }
    drawCircuitView( draw2 ) {
        let rect = this.getBoundingRect();
        draw2.setFillColor_array(DC_background2);
        draw2.fillRect(rect.min.x,rect.min.y,rect.width(),rect.height());

        // draw wires
        for ( let w = 0; w < this.circuit.numWires; ++w ) {
            if ( w === this.highlighted_wire || w === this.highlighted_wire2 ) {
                draw2.setLineWidth( 7 ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                draw2.setStrokeColor_array(DC_highlight_wire);
            }
            else {
                draw2.setLineWidth( 5 ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                draw2.setStrokeColor_array(DC_foreground);
            }
            draw2.drawLine( -0.5, w+0.5, this.circuit.numStages+0.5, w+0.5 );
        }

        if (
            ( this.highlighted_mode === CVH_PLV_LOCALSTATE || this.highlighted_mode === CVH_PLV_STATEVECTOR )
            && this.highlighted_stage >= 0
        ) {
            // draw vertical line segment
            draw2.setLineWidth( 3 ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
            draw2.setStrokeColor_array(DC_highlight_wire);
            draw2.drawLine( this.highlighted_stage, 0, this.highlighted_stage, this.circuit.numWires );
        }

        // draw circuit parts
        for ( let s = 0; s < this.circuit.numStages; ++s ) {

            let numCircuitParts = 0;
            let hasControlBits = false;
            let numSwapParts = 0;
            let min_w_of_any_part = -1;
            let max_w_of_any_part = -1;
            let min_w_of_swap_part = -1;
            let max_w_of_swap_part = -1;

            for ( let w = 0; w < this.circuit.numWires; ++w ) {
                let circuitPart_id = this.circuit.getCircuitPartIDOfCell(w,s);
                if ( circuitPart_id >= 0 ) {
                    numCircuitParts ++;
                    if ( numCircuitParts === 1 )
                        min_w_of_any_part = w;
                    max_w_of_any_part = w;
                    if ( circuitPart_id === CP_CB || circuitPart_id === CP_ACB ) {
                        hasControlBits = true;
                    }
                    else if ( circuitPart_id === CP_SWAP ) {
                        numSwapParts ++;
                        if ( numSwapParts === 1 )
                            min_w_of_swap_part = w;
                        max_w_of_swap_part = w;
                    }
                }
            }

            // draw vertical line segment connecting control bits or swap gate parts
            draw2.setLineWidth(3); // TODO_lineWidth should be scale dependent
            draw2.setStrokeColor_array(DC_foreground);
            if ( hasControlBits ) {
                draw2.drawLine( s+0.5, min_w_of_any_part+0.5, s+0.5, max_w_of_any_part+0.5 );
            }
            else if ( numSwapParts === 2 ) {
                draw2.drawLine( s+0.5, min_w_of_swap_part+0.5, s+0.5, max_w_of_swap_part+0.5 );
            }

            // draw circuit part
            for ( let w = 0; w < this.circuit.numWires; ++w ) {
                let circuitPart = this.circuit.getCellContents(w,s);
                let circuitPart_id = this.circuit.getCircuitPartIDOfCell(w,s);
                if ( circuitPart_id >= 0 ) {
                    if ( circuitPart.isParametric() ) {
                        draw2.drawImage(empty_icon_image, s, w, 1, 1 );
                        let margin = circuitPart.getMargin();
                        let x0 = s + margin;
                        let textHeight = circuitPart.getHeightOfParameterString();
                        drawTextLabelWithOutline( x0, w+margin+textHeight, circuitPart.getName(),false,true,false,textHeight);
                        for ( let i = 0; i < circuitPart.getNumParameters(); ++i ) {
                            if (
                                this.highlighted_mode === CVH_CIRCUIT
                                && w === this.highlighted_wire && s === this.highlighted_stage
                            ) {
                                if ( this.highlighted_circuitPart_parameter === i ) {
                                    draw2.setFillColor_array(DC_highlight_icon);
                                    draw2.fillRect( x0, w+margin+(i+1)*textHeight, 1-2*margin, textHeight );
                                }
                            }
                            if (
                                this.selected_circuitPart_isAnythingSelected
                                && w === this.selected_circuitPart_wire && s === this.selected_circuitPart_stage
                            ) {
                                if ( this.selected_circuitPart_parameter === i ) {
                                    draw2.setLineWidth( 2 ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                                    draw2.setStrokeColor_array(DC_highlight_icon);
                                    draw2.drawRect( x0, w+margin+(i+1)*textHeight, 1-2*margin, textHeight );
                                }
                            }
                            drawTextLabelWithOutline( x0, w+margin+(i+2)*textHeight, circuitPart.getParameterAsString(i),false,false,false,textHeight);
                        }
                    }
                    else {
                        draw2.drawImage(circuitPart.getImage(), s, w, 1, 1 );
                    }
                    if (
                        this.highlighted_mode === CVH_CIRCUIT
                        && w === this.highlighted_wire && s === this.highlighted_stage
                    ) {
                        draw2.setLineWidth( 3 ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                        draw2.setStrokeColor_array(DC_highlight_icon);
                        draw2.drawRect(s,w,1,1);
                    }
                    if (
                        this.selected_circuitPart_isAnythingSelected
                        && w === this.selected_circuitPart_wire
                        && s === this.selected_circuitPart_stage
                    ) {
                        draw2.setLineWidth( 5 ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                        draw2.setStrokeColor_array(DC_highlight_icon);
                        let a = 0.3;
                        draw2.drawLine( s, w, s+a, w );
                        draw2.drawLine( s+1-a, w, s+1, w );
                        draw2.drawLine( s, w+1, s+a, w+1 );
                        draw2.drawLine( s+1-a, w+1, s+1, w+1 );

                        draw2.drawLine( s, w, s, w+a );
                        draw2.drawLine( s, w+1-a, s, w+1 );
                        draw2.drawLine( s+1, w, s+1, w+a );
                        draw2.drawLine( s+1, w+1-a, s+1, w+1 );
                    }
                }
            }
            // draw drop candidate
            if ( this.hasDropCandidate ) {
                draw2.setLineWidth( 3 ); // TODO_lineWidth should be scale dependent so it's not super thick when we are zoomed out
                draw2.setStrokeColor_array(DC_highlight_dropSite);
                draw2.drawRect(this.drop_stage - (this.drop_insertBeforeTheGivenStage?0.5:0.0),this.drop_wire,1,1);
            }
        }

        // make sure that all the circuit per-stage state vectors and stats are up-to-date
        this.circuit.runIfNecessary();

        if ( DispOpt.showFinalLocalState ) {
            this.drawLocalState( FV_LS_x0, 0, this.circuit, this.circuit.numStages, false, 1.0 );
        }

        draw2.setStrokeColor_array(DC_foreground);

        if ( DispOpt.showFinalHalfMatrix ) {
            this.drawHalfMatrix( FV_HM_center_x0, FV_HM_center_y0, this.circuit, this.circuit.numStages, false );
        }

        if ( DispOpt.showLocalStatePerLayer || DispOpt.showStateVectorsPerLayer ) {

            // draw visualization of local state and/or state vectors, per layer
            draw2.setLineWidth(1);
            draw2.setStrokeColor_array(DC_foreground);
            if (
                0 <= mouse_x_world && mouse_x_world <= this.circuit.numStages
                && 0 <= mouse_y_world && mouse_y_world <= this.circuit.numWires
            ) {
                PLV_mostRecentForScrolling_mouse_x_world = mouse_x_world;
            }
            if ( true ) {
                // Imagine a linear function y=A*x+B where x is the (clamped) x position of the mouse in world space,
                // and y is the left-most x position of a rectangle encompassing the state vector visualizations for all the stages.
                // We are particularly interested in the values at
                //     x=0.5, where the mouse is in the middle of the 0th stage, and y is at a maximum;
                //     x=(numStages-0.5), where the mouse is in the middle of the last stage, and y is at a minimum.
                // BEGIN: find A and B

                //
                // This is the y value when x=x1=0.5
                let y1 = -( PLV_col_w + PLV_space_w/2 - 0.5 );
                // This is the y value when x=x2=(numStages-0.5)
                let y2 = -(PLV_total_w - PLV_col_w - PLV_space_w/2 - (this.circuit.numStages-0.5));
                // find the slope
                let A = this.circuit.numStages > 1 ? (y2-y1)/(this.circuit.numStages-1) : 0;
                // find the intercept
                let B = y1 - A*0.5;
                //
                // END

                let mxw_clamped = PLV_mostRecentForScrolling_mouse_x_world; // mxw_ means mouse_x_world_
                if ( mxw_clamped < 0.5 ) mxw_clamped = 0.5;
                else if ( mxw_clamped > this.circuit.numStages-0.5 ) mxw_clamped = this.circuit.numStages-0.5;

                if ( DispOpt.scrollPerLayerVisHorizontally ) {
                    // Use the linear function to find the left-most x position of the rectangle containing the state vector vis for all stages
                    PLV_x0 = A*mxw_clamped + B;
                }
                else {
                    PLV_x0 = -( PLV_total_w - this.circuit.numStages )/2;
                }

                PLV_SV_x0 = PLV_x0 + (PLV_col_w - SV_col_w)/2;
                PLV_LS_x0 = PLV_x0 + (PLV_col_w - LS_W)/2;

                PLV_stage = Math.floor(mxw_clamped);
                PLV_stage_fractionalPart = mxw_clamped - PLV_stage;
            }
            // draw2.drawRect( PLV_SV_x0, PLV_SV_y0, PLV_total_w, SV_total_h );
            let minStage = 0;
            let maxStage = this.circuit.numStages;
            if ( ! DispOpt.showVisOfAllLayers ) {
                minStage = Math.max(0,PLV_stage-1);
                maxStage = Math.min(PLV_stage+2,this.circuit.numStages);
            }


            for ( let pass = 1; pass <= 2; ++pass ) {
                for ( let stage = minStage; stage <= maxStage; ++stage ) {

                    let C = this.circuit;
                    let _x0 = PLV_x0 + stage*( PLV_col_w + PLV_space_w );
                    let _y0 = PLV_y0;

                    let alpha = 1;
                    if ( ! DispOpt.showVisOfAllLayers ) {
                        if ( stage === PLV_stage-1 ) {
                            alpha = 2*( 1-PLV_stage_fractionalPart )-1;
                        }
                        else if ( stage === PLV_stage+2 ) {
                            alpha = 2 * PLV_stage_fractionalPart -1;
                        }
                    }
                    draw2.setStrokeColor(DC_foreground[0],DC_foreground[1],DC_foreground[2],alpha);
                    draw2.setFillColor(DC_shadow[0],DC_shadow[1],DC_shadow[2],alpha);

                    if ( pass === 1 ) {
                        // draw triangular shadow
                        let shadow_left_x = ( DispOpt.showLocalStatePerLayer ? PLV_LS_x0 : PLV_SV_x0 ) + stage*( PLV_col_w + PLV_space_w );
                        let shadow_right_x = shadow_left_x + ( DispOpt.showLocalStatePerLayer ? LS_W : SV_col_w );
                        draw2.fillPolygon( [
                            new Vec2(shadow_left_x,_y0), new Vec2(shadow_right_x,_y0), // base of shadow
                            new Vec2(stage,C.numWires) // top of shadow
                        ]);
                    }

                    if ( alpha < 0.7 )
                        // don't bother drawing the rest of the StateVectorVisualization1,
                        // because it ends up interfering with other visual feedback
                        continue; // TODO fading: are we happy with this ? you could also try doing "alpha *= 2;" to make it fade faster, or have a threshold like "if ( alpha < 0.5 )", or increasing the horizontal spacing (PLV_space_w) between state vectors


                    if ( pass === 2 ) {
                        let drawDiffVis = DispOpt.show_diffvis===DispOpt.DIFFVIS_ALL || (DispOpt.show_diffvis===DispOpt.DIFFVIS_ONE && stage === PLV_stage);

                        if ( DispOpt.showLocalStatePerLayer )
                            this.drawLocalState( PLV_LS_x0 + stage*( PLV_col_w + PLV_space_w ), _y0, C, stage, drawDiffVis /*TODO_diff not yet used*/, alpha );

                        if ( DispOpt.showStateVectorsPerLayer ) {
                            let drawTextInsideCells = (DispOpt.showVisOfAllLayers || (stage === PLV_stage || stage === PLV_stage+1)) && (DispOpt.displayInsideBitstring || DispOpt.displayInsideProbability);
                            let drawTextOutsideCells = ((stage === C.numStages) || (! DispOpt.showVisOfAllLayers && (stage === PLV_stage+1))) && DispOpt.displayOutsideBitstring;
                            this.drawStateVector( PLV_SV_x0 + stage*( PLV_col_w + PLV_space_w ), PLV_SV_y0, C, stage, drawDiffVis, drawTextInsideCells, drawTextOutsideCells, this.highlighted_wire, alpha );
                        }
                    }

                } // for stage
            } // for pass
        }

        // draw tooltip for halfmatrix
        if ( DispOpt.showFinalHalfMatrix ) {
            // draw tooltip
            if ( this.highlighted_mode === CVH_FV_HALFMATRIX ) {
                this.drawHalfMatrixTooltip( FV_HM_center_x0, FV_HM_center_y0, this.circuit, this.circuit.numStages, this.highlighted_wire, this.highlighted_wire2 );
            }
        }

        // draw tooltip for Local State (LS)
        if ( this.highlighted_mode === CVH_FV_LOCALSTATE ) {
            this.drawLocalStateTooltip( FV_LS_x0, this.highlighted_wire, this.circuit, this.circuit.numStages, this.highlighted_wire, true );
        }
        else if ( this.highlighted_mode === CVH_PLV_LOCALSTATE ) {
            this.drawLocalStateTooltip( PLV_LS_x0 + this.highlighted_stage*( PLV_col_w + PLV_space_w ), PLV_y0 + this.highlighted_wire, this.circuit, this.highlighted_stage, this.highlighted_wire, false );
        }
    }
    // Only called if nothing is being dragged.
    drawTooltip(
        draw2,
        x_pixels, y_pixels
    ) {
        // XXX
        if ( this.highlighted_mode === CVH_NOTHING )
            return;

        let s = "";
        if ( this.highlighted_mode === CVH_FV_HALFMATRIX ) {
            if ( ! DispOpt.showOriginalHalfmatrixTooltip )
                return;

            let row = this.highlighted_wire;
            let col = this.highlighted_wire2;
            let C = this.circuit;
            let precision = 3;
            let numMetricsLeft = DispOpt.HM_numMetrics;

            if ( DispOpt.HM_showPurity ) { s += "Purity=" + StringUtil.numToString(C.pairwisePurities.get(row,col)._r,precision);                   numMetricsLeft--; if ( numMetricsLeft > 0 ) s += "; "; }
            if ( DispOpt.HM_showLinearEntropy ) { s += "L. Entropy=" + StringUtil.numToString(1-C.pairwisePurities.get(row,col)._r,precision);      numMetricsLeft--; if ( numMetricsLeft > 0 ) s += "; "; }
            if ( DispOpt.HM_showVonNeumannEntropy ) { s += "V.N. Entropy=" + StringUtil.numToString(C.pairwiseEntropies.get(row,col)._r,precision); numMetricsLeft--; if ( numMetricsLeft > 0 ) s += "; "; }
            if ( DispOpt.HM_showConcurrence ) { s += "Concurrence=" + StringUtil.numToString(C.pairwiseConcurrences.get(row,col)._r,precision);     numMetricsLeft--; if ( numMetricsLeft > 0 ) s += "; "; }
            if ( DispOpt.HM_showCorrelation ) { s += "Correlation=" + StringUtil.numToString(C.pairwiseCorrelations.get(row,col)._r,precision);     numMetricsLeft--; }
        }
        else if ( this.highlighted_mode === CVH_FV_LOCALSTATE ) {
            if ( ! DispOpt.showOriginalLSTooltip )
                return;
            s = "Purity=" + StringUtil.numToString( this.circuit.perQubitStats[this.circuit.numStages][this.highlighted_wire].purity._r, 3 );
        }
        else if ( this.highlighted_mode === CVH_PLV_LOCALSTATE ) {
            return;
        }
        else if ( this.highlighted_mode === CVH_PLV_STATEVECTOR ) {
            if ( this.highlighted_baseState < 0 )
                return;
            let amplitude = this.circuit.stateVectors[ this.highlighted_stage ].get(0,this.highlighted_baseState);
            let magnitude = amplitude.mag();
            let probability = magnitude * magnitude;
            let phase = amplitude.arg() / Math.PI * 180;
            if ( phase > 180 ) phase -= 360;
            s = StringUtil.intToBinaryString( this.highlighted_baseState, this.circuit.numWires )
                + " mag:" + StringUtil.numToString( magnitude )
                + " prob:" + StringUtil.numToString( probability )
                + " phase:" + StringUtil.numToString( phase ) + "°";
        }
        else if ( this.highlighted_mode === CVH_CIRCUIT ) {
            if ( this.highlighted_circuitPart !== null ) {
                if ( this.highlighted_circuitPart_parameter >= 0 /* a parameter is highlighted */ )
                    s = (this.dragMode === CV_DM_NOT_DRAGGING) ? "Ctrl+drag left-right to adjust; Shift+drag to snap" : "";
                else
                    s = this.highlighted_circuitPart.getTooltip();
            }
            else if ( this.highlighted_wire >= 0 && this.highlighted_wire < this.circuit.numWires )
                s = "qubit " + this.highlighted_wire;
            else return;
        }

        if ( s.length > 0 )
            drawTextLabelWithOutline( x_pixels, y_pixels, s, true, true, true, TOOLTIP_SIZE );
    }
    // Only called if something is being dragged.
    drawObjectBeingDragged(
        draw2,
        x_pixels, y_pixels,
        infoAboutObjectBeingDragged // an object of the form {obj:reference}
    ) {
    }
    // Returns a boolean
    isUnder( x_pixels, y_pixels, x_world, y_world ) {
        return this.getBoundingRect().containsPoint( new Vec2( x_world, y_world ) );
    }
    // XXX we are in the CircuitViewer class
    // Returns an object of the form { redraw:boolean, initiatesDragAndDrop:boolean, objectBeingDragged:reference }
    widget_mousePress(
        x_pixels, y_pixels, x_world, y_world,
        mouseButton, // one of MW_BUTTON_...
        buttonAndKeyState // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
    ) {
        if ( verboseEvents ) console.log(`entering widget_mousePress with dragMode===${this.dragMode} and mouseButton===${mouseButton}`);
        let ctrlMod = buttonAndKeyState & MW_KEY_CONTROL;
        let shiftMod = buttonAndKeyState & MW_KEY_SHIFT;

        let didUserPressOnACircuitPart = false;
        let didUserPressOnAParameter = false;
        if (
            this.highlighted_circuitPart !== null
            && this.highlighted_wire >= 0 && this.highlighted_stage >= 0
        ) {
            this.selected_circuitPart_isAnythingSelected = true;
            this.selected_circuitPart_wire = this.highlighted_wire;
            this.selected_circuitPart_stage = this.highlighted_stage;
            didUserPressOnACircuitPart = true;
            this.selected_circuitPart_parameter = this.highlighted_circuitPart_parameter;
            if ( this.selected_circuitPart_parameter >= 0 ) {
                didUserPressOnAParameter = true;
            }
        }
        else {
            this.selected_circuitPart_isAnythingSelected = false;
            this.selected_circuitPart_wire = -1;
            this.selected_circuitPart_stage = -1;
            this.selected_circuitPart_parameter = -1;
        }

        this.dragMode = CV_DM_DRAGGING_NOTHING;
        if ( didUserPressOnACircuitPart ) {
            if ( mouseButton === MW_BUTTON_LEFT ) {
                if ( ctrlMod && ! shiftMod && didUserPressOnAParameter )
                    this.dragMode = CV_DM_PARAMETER_DRAG;
                else if ( shiftMod && ! ctrlMod && didUserPressOnAParameter )
                    this.dragMode = CV_DM_PARAMETER_DRAG_WITH_SNAPPING;
                else if ( ! ctrlMod && ! shiftMod )
                    this.dragMode = CV_DM_TENTATIVE_DRAG_AND_DROP;
                this.drag_x0_pixels = x_pixels;
                this.drag_parameterValueAtStart = 0;
                if ( didUserPressOnAParameter && this.highlighted_circuitPart !== null && this.highlighted_circuitPart_parameter >= 0 ) {
                    this.drag_parameterValueAtStart = this.highlighted_circuitPart.paramValues[ this.highlighted_circuitPart_parameter ];
                }
                this.drag_cumulativeDelta_pixels = 0;
            }
            else if ( mouseButton === MW_BUTTON_MIDDLE ) {
                if ( verboseEvents ) console.log("widget_mousePress delete");
                this.dragMode = CV_DM_DELETE_CIRCUITPART;
            }
        }

        return { redraw: true, initiatesDragAndDrop: false,  objectBeingDragged: null };
    }
    // XXX we are in the CircuitViewer class
    // Returns an object of the form { redraw:boolean, acceptsDragAndDrop:boolean }
    widget_mouseRelease(
        x_pixels, y_pixels, x_world, y_world,
        mouseButton, // one of MW_BUTTON_...
        buttonAndKeyState, // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
        isPartOfDragAndDrop, // if true, the caller is managing events; if false, the widget is managing events
        infoAboutObjectBeingDragged // an object of the form {obj:reference}
    ) {
        if ( verboseEvents ) console.log(`entering widget_mouseRelease with dragMode===${this.dragMode}`);
        Util.assert( isPartOfDragAndDrop === (this.dragMode === CV_DM_DRAG_AND_DROP), "unexpected condition in widget_mouseRelease()" );
        if ( verboseEvents ) console.log(`isPartOfDragAndDrop===${isPartOfDragAndDrop}   dragMode===${this.dragMode}`);

        if ( this.dragMode === CV_DM_DRAG_AND_DROP ) {
            let returnValue = { redraw:true, acceptsDragAndDrop:this.hasDropCandidate };
            if ( infoAboutObjectBeingDragged !== null && this.hasDropCandidate ) {
                this.circuit.addCircuitPart(
                    infoAboutObjectBeingDragged.obj,
                    this.drop_wire,
                    this.drop_stage,
                    this.drop_insertBeforeTheGivenStage
                );
                // We will compactify() and startAnimation() later in widget_cleanUpAfterDragAndDrop()
            }
            this.clearDropCandidate();
            this.dragMode = CV_DM_NOT_DRAGGING;
            return returnValue;
        }
        else if ( this.dragMode === CV_DM_DELETE_CIRCUITPART ) {
            deleteCircuitPart( this.highlighted_wire, this.highlighted_stage );
        }

        this.dragMode = CV_DM_NOT_DRAGGING;
        return { redraw:true, acceptsDragAndDrop:false };
    }
    // Returns an object of the form {redraw:boolean}
    widget_mouseHover(
        x_pixels, y_pixels, x_world, y_world
    ) {
        this.clearDropCandidate();
        let returnValue = this.findHighlightedElements( x_world, y_world );
        if (
            this.highlighted_mode !== returnValue.mode
            || this.highlighted_wire !== returnValue.wire
            || this.highlighted_stage !== returnValue.stage
            || this.highlighted_circuitPart !== returnValue.circuitPart
            || this.highlighted_wire2 !== returnValue.wire2
            || this.highlighted_circuitPart_parameter != returnValue.circuitPart_parameter
            || this.highlighted_baseState != returnValue.baseState
        ) {
            this.highlighted_mode = returnValue.mode;
            this.highlighted_wire = returnValue.wire;
            this.highlighted_stage = returnValue.stage;
            this.highlighted_circuitPart = returnValue.circuitPart;
            this.highlighted_wire2 = returnValue.wire2;
            this.highlighted_circuitPart_parameter = returnValue.circuitPart_parameter;
            this.highlighted_baseState = returnValue.baseState;

            return {redraw:true};
        }
        return {redraw:false};
    }
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_mouseHoverLeave() {
        if ( this.highlighted_mode !== CVH_NOTHING ) {
            this.clearHighlighting();
            return {redraw:true};
        }
        return {redraw:false};
    }
    // XXX we are in the CircuitViewer class
    // Returns an object of the form {redraw:boolean, initiatesDragAndDrop:boolean, objectBeingDragged:reference}
    widget_mouseDrag(
        x_pixels, y_pixels, x_world, y_world,
        buttonAndKeyState, // contains MW_BUTTON_... and MW_KEY_... values 'OR'ed together
        isPartOfDragAndDrop, // if true, the caller is managing events; if false, the widget is managing events
        infoAboutObjectBeingDragged // null for none, otherwise an object of the form { obj:reference, source:reference }
    ) {
        if ( verboseEvents ) console.log(`entering widget_mouseDrag with dragMode===${this.dragMode}`);
        // The framework might be in the middle of a drag-and-drop action
        // initiated by another widget, in which case we have to transition ourselves
        // into the corresponding mode.
        if ( isPartOfDragAndDrop ) {
            Util.assert( this.dragMode === CV_DM_NOT_DRAGGING || this.dragMode === CV_DM_DRAG_AND_DROP, "unexpected condition in widget_mouseDrag()" );
            this.dragMode = CV_DM_DRAG_AND_DROP;
        }
        else {
            Util.assert( this.dragMode !== CV_DM_DRAG_AND_DROP, "unexpected condition in widget_mouseDrag()" );
        }

        if ( verboseEvents ) console.log(`isPartOfDragAndDrop===${isPartOfDragAndDrop}   dragMode===${this.dragMode}`);

        if (
            this.dragMode === CV_DM_PARAMETER_DRAG
            || this.dragMode === CV_DM_PARAMETER_DRAG_WITH_SNAPPING
        ) {
            this.drag_cumulativeDelta_pixels = x_pixels - this.drag_x0_pixels;
            let paramInfo = this.highlighted_circuitPart.getParamInfo( this.highlighted_circuitPart_parameter );
            let newParamValue = this.drag_parameterValueAtStart + this.drag_cumulativeDelta_pixels * paramInfo.dragIncrement;
            if ( this.dragMode === CV_DM_PARAMETER_DRAG_WITH_SNAPPING ) {
                newParamValue = Math.round( newParamValue / paramInfo.snapIncrement ) * paramInfo.snapIncrement;
            }
            if ( newParamValue < paramInfo.minValue )
                newParamValue = paramInfo.minValue;
            else if ( newParamValue > paramInfo.maxValue )
                newParamValue = paramInfo.maxValue;
            this.highlighted_circuitPart.paramValues[ this.highlighted_circuitPart_parameter ] = newParamValue;
            this.circuit.stateVectorsAndStatsAreDirty = true;
            this.updateURLIfNecessary( false );

            return {redraw:true, initiatesDragAndDrop:false, objectBeingDragged:null};
        }
        else if ( this.dragMode === CV_DM_TENTATIVE_DRAG_AND_DROP ) {
            if ( verboseEvents ) console.log("widget_mouseDrag tentative");
            if ( this.highlighted_circuitPart !== null ) {
                let objectThatWillBeDragged = this.highlighted_circuitPart;
                //let objectThatWillBeDragged_wire = this.highlighted_wire;
                //let objectThatWillBeDragged_stage = this.highlighted_stage;
                this.circuit.clearCell(this.highlighted_wire,this.highlighted_stage);

                this.clearHighlighting();
                let result = this.findCellForDrop( x_world, y_world, objectThatWillBeDragged.getCircuitPartID() );
                this.hasDropCandidate = result.hasDropCandidate;
                this.drop_wire = result.wire;
                this.drop_stage = result.stage;
                this.drop_insertBeforeTheGivenStage = result.insertBeforeTheGivenStage;

                this.dragMode = CV_DM_DRAG_AND_DROP;

                return {
                    redraw: true,
                    initiatesDragAndDrop: true,
                    objectBeingDragged: objectThatWillBeDragged
                };
            }
            else {
                return {redraw:false, initiatesDragAndDrop:false, objectBeingDragged:null};
            }
        }
        else if ( this.dragMode === CV_DM_DRAG_AND_DROP ) {
            if ( verboseEvents ) console.log("widget_mouseDrag dnd");
            this.clearHighlighting();
            if ( infoAboutObjectBeingDragged !== null ) {
                let result = this.findCellForDrop( x_world, y_world, infoAboutObjectBeingDragged.obj.getCircuitPartID() );
                if (
                    this.hasDropCandidate !== result.hasDropCandidate
                    || this.drop_wire !== result.wire
                    || this.drop_stage !== result.stage
                    || this.drop_insertBeforeTheGivenStage !== result.insertBeforeTheGivenStage
                ) {
                    this.hasDropCandidate = result.hasDropCandidate;
                    this.drop_wire = result.wire;
                    this.drop_stage = result.stage;
                    this.drop_insertBeforeTheGivenStage = result.insertBeforeTheGivenStage;
                    return {redraw:true, initiatesDragAndDrop:false, objectBeingDragged:null};
                }
            }
            return {redraw:false, initiatesDragAndDrop:false, objectBeingDragged:null};
        }

        return {redraw:false, initiatesDragAndDrop:false, objectBeingDragged:null};
    }
    // XXX we are in the CircuitViewer class
    // Only invoked during drag-and-drop.
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean}
    widget_mouseDragLeave() {
        if ( this.hasDropCandidate ) {
            this.clearDropCandidate();
            return {redraw:true};
        }
        return {redraw:false};
    }
    // Called if this object was the source and/or sink of a drag-and-drop.
    // Gives the object a chance to clean up things like removing highlighting.
    // Returns an object of the form {redraw:boolean} XXX we are in the CircuitViewer class
    widget_cleanUpAfterDragAndDrop(wasSource,wasDestination) {
        // We want to do this regardless of whether we were the source or the destination or both.
        this.clearHighlighting();
        this.clearSelection();
        updateAfterChangeToCircuit();
        return {redraw:true};
    }
    recomputeGeometryOfVisualizations() {
        FV_LS_x0 = this.circuit.numStages + FV_MARGIN_LEFT;

        // Count how many metrics are visible.
        DispOpt.LS_numMetrics = 0;

        if ( DispOpt.LS_showPurity ) DispOpt.LS_numMetrics++;
        if ( DispOpt.LS_showLinearEntropy ) DispOpt.LS_numMetrics++;
        if ( DispOpt.LS_showVonNeumannEntropy ) DispOpt.LS_numMetrics++;
        if ( DispOpt.LS_showProbability ) DispOpt.LS_numMetrics++;
        if ( DispOpt.LS_showPhase ) DispOpt.LS_numMetrics++;
        LS_W = DispOpt.LS_numMetrics * 0.5;
        if ( LS_W < 0.5 ) LS_W = 0.5;

        FV_HM_center_x0 = this.circuit.numStages + FV_MARGIN_LEFT + ( DispOpt.showFinalLocalState ? LS_W : 0 ) + this.circuit.numWires / 2;
        FV_HM_center_y0 = this.circuit.numWires / 2;
        // Count how many metrics are visible.
        DispOpt.HM_numMetrics = 0;
        if ( DispOpt.HM_showPurity ) DispOpt.HM_numMetrics ++;
        if ( DispOpt.HM_showLinearEntropy ) DispOpt.HM_numMetrics ++;
        if ( DispOpt.HM_showVonNeumannEntropy ) DispOpt.HM_numMetrics ++;
        if ( DispOpt.HM_showConcurrence ) DispOpt.HM_numMetrics ++;
        if ( DispOpt.HM_showCorrelation ) DispOpt.HM_numMetrics ++;

        // PLV_SV_x0 = ... // this gets recomputed inside drawCircuitView()
        // PLV_stage = ... // this gets recomputed inside drawCircuitView()
        PLV_y0 = this.circuit.numWires + PLV_space_h_top;
        PLV_SV_y0 = this.circuit.numWires + PLV_space_h_top + ( DispOpt.showLocalStatePerLayer ? this.circuit.numWires + PLV_space_h : 0 );
        if ( ! DispOpt.allowMultipleColumns ) {
            SV_numRows = 2**this.circuit.numWires;
            SV_numCols = 1;
        }
        else {
            let N = 2**this.circuit.numWires;
            let ideal_num_cols = Math.sqrt( N / DispOpt.cell_aspectRatio );
            SV_numCols = 2 ** Math.floor(Math.log2( ideal_num_cols ));
            if ( SV_numCols < 1 ) SV_numCols = 1;
            SV_numRows = N / SV_numCols;
        }
        SV_numColBits = Math.round( Math.log2( SV_numCols ) );
        SV_numRowBits = Math.round( Math.log2( SV_numRows ) );
        const maxCellHeight = 1 / 3;
        const maxRatioOfHeightOfStateVectorVisToHeightOfCircuit = 2;
        SV_total_h = maxRatioOfHeightOfStateVectorVisToHeightOfCircuit * this.circuit.numWires;
        SV_cell_h = SV_total_h / SV_numRows;
        if ( SV_cell_h > maxCellHeight ) {
            SV_cell_h = maxCellHeight;
            SV_total_h = SV_numRows * SV_cell_h;
        }
        SV_cell_w = DispOpt.cell_aspectRatio * SV_cell_h;
        PLV_space_w = 3 * SV_cell_h; // SV_numCols * SV_cell_h;
        SV_col_w = SV_numCols * SV_cell_w;
        PLV_col_w = Math.max( DispOpt.showLocalStatePerLayer ? LS_W : 0, DispOpt.showStateVectorsPerLayer ? SV_col_w : 0 );
        PLV_total_w = this.circuit.numStages*( PLV_col_w + PLV_space_w ) + PLV_col_w;
    }
    updateURLIfNecessary( addToBrowsersUndoHistoryToo = true ) {
        let newValue = this.circuit.generateString();
        const urlParams = new URLSearchParams(window.location.search);
        const circuitParamValue = urlParams.get(URL_PARAM_CIRCUIT);
        if ( circuitParamValue === null || circuitParamValue !== newValue ) {
            urlParams.set(URL_PARAM_CIRCUIT, newValue);
            const newUrl = window.location.protocol + "//" + window.location.host + window.location.pathname + '?' + urlParams.toString().replace(/%22/g, '"').replace(/%7B/g, '{').replace(/%7D/g, '}').replace(/%5B/g, '[').replace(/%5D/g, ']').replace(/%3A/g, ':').replace(/%2C/g, ',').replace(/%5E/g, '^');
            if ( addToBrowsersUndoHistoryToo )
                window.history.pushState({path:newUrl},'',newUrl);
            else
                window.history.replaceState({path:newUrl}, '', newUrl);
            // console.log('url updated');

            updateWebpageContent( newValue );
        }
        // else console.log('no update to url necessary');
        return false;
    }
}


const verboseEvents = false; // for debugging


let canvas = document.getElementById("myCanvas");
let canvas_context = canvas.getContext("2d");
let draw2 = new Draw2(canvas);
const FONT_HEIGHT = 20;
draw2.setFontHeight( FONT_HEIGHT );
let toolbar = new Toolbar();
let global_circuit = new Circuit();

// construct a circuit
/*
circuit.addGate(0,CP_H,[]);
circuit.addGate(1,CP_X,[[0,true]]);
circuit.addSwapGate(1,3);
*/

let circuitViewer = new CircuitViewer( global_circuit );
let toolbarHeight_pixels = toolbar.getBoundingRect().height();

let floatingCheckbox1 = new FloatingCheckbox(DispOpt.showStateVectorsPerLayer,"Show state vectors per layer","Hide state vectors per layer",floatingCheckboxCallback,"showStateVectorsPerLayer");
let floatingCheckbox2 = new FloatingCheckbox(DispOpt.showLocalStatePerLayer,"Show local state per layer","Hide local state per layer",floatingCheckboxCallback,"showLocalStatePerLayer");
let floatingCheckbox3 = new FloatingCheckbox(DispOpt.showLocalStatePerLayer,"Show final local state","Hide final local state",floatingCheckboxCallback,"showFinalLocalState");
let floatingCheckbox4 = new FloatingCheckbox(DispOpt.showFinalHalfMatrix,"Show final half matrix","Hide final half matrix",floatingCheckboxCallback,"showFinalHalfMatrix");

function frameCircuit() {
    circuitViewer.frame( draw2, 0, toolbarHeight_pixels, canvas.width, canvas.height-toolbarHeight_pixels );
}

function displayOptionCheckboxCallback( event ) {
    const checkbox = event.target;
    const varName = checkbox.getAttribute('datavar');
    if (typeof DispOpt[varName] === 'boolean') {
        DispOpt[varName] = checkbox.checked;
        // console.log(`${varName} is now ${DispOpt[varName]}`);
        updateAfterChangeToDisplayOptions();
    }
    else console.log( "Unexpected type of datavar " + varName );
}

function displayOptionRadioButtonCallback( event ) {
    const radiobutton = event.target;
    const varName = radiobutton.getAttribute('datavar');
    const varValue = radiobutton.getAttribute('datavarvalue');
    DispOpt[varName] = DispOpt[varValue];
    // console.log(`${varName} is now ${DispOpt[varName]}`);
    updateAfterChangeToDisplayOptions();
}

function floatingCheckboxCallback( state, client_data ) {
    if (typeof DispOpt[client_data] === 'boolean') {
        DispOpt[client_data] = state;
        //console.log(`${client_data} is now ${DispOpt[client_data]}`);
        updateAfterChangeToDisplayOptions();
    }
    else console.log( "Unexpected type of datavar " + varName );
}

function initializeDisplayOptionWidgets() {
    document.querySelectorAll('input[type="checkbox"][datavar]').forEach(checkbox => {
        const varName = checkbox.getAttribute('datavar');
        if (typeof DispOpt[varName] === 'boolean') {
            checkbox.checked = DispOpt[varName];
        }
        else console.log( "Unexpected type of datavar " + varName );
        checkbox.addEventListener('change', displayOptionCheckboxCallback );
    });
    document.querySelectorAll('input[type="radio"][datavar]').forEach(radiobutton => {
        const varName = radiobutton.getAttribute('datavar');
        const varValue = radiobutton.getAttribute('datavarvalue');
        if ( DispOpt[varName] === DispOpt[varValue] ) {
            radiobutton.checked = true;
        }
        radiobutton.addEventListener('change', displayOptionRadioButtonCallback );
    });
}

const QUIRK_LINK_ID = 'quirkLink';
const QUIRK_URL = "https://algassert.com/quirk";
const QUIRK_URL_PREFIX = "https://algassert.com/quirk#circuit=";
const QASM_TEXT_ID = 'qasmText';
const URL_PARAM_CIRCUIT = 'circuit';


function updateWebpageContent( circuitDescribedInString ) {
    // update the quirk link and the OpenQASM text
    let quirkLinkElement = document.getElementById( QUIRK_LINK_ID );
    if (quirkLinkElement)
        quirkLinkElement.href = circuitDescribedInString==="" ? QUIRK_URL : QUIRK_URL_PREFIX + circuitDescribedInString;
    let qasmTextElement = document.getElementById( QASM_TEXT_ID )
    if (qasmTextElement)
        qasmTextElement.textContent = global_circuit.generateQASMString( false );
}

function initializeWithNewCircuit() {
    global_circuit.clear();

    // construct circuit from URL query string
    const urlParams = new URLSearchParams(window.location.search);
    const circuitParamValue = urlParams.get(URL_PARAM_CIRCUIT);
    if ( circuitParamValue !== null ) {
        global_circuit.constructFromString( circuitParamValue );

        updateWebpageContent( circuitParamValue );
    }
    else updateWebpageContent("");

    circuitViewer.recomputeGeometryOfVisualizations();
    frameCircuit();
}
initializeWithNewCircuit();

function clearCircuitButtonHandler() {
    global_circuit.clear();
    circuitViewer.updateURLIfNecessary();
    circuitViewer.recomputeGeometryOfVisualizations();
    frameCircuit();
    draw();
}

function expandCircuitButtonHandler() {
    const checkbox = document.getElementById('useGeneralizedGatesCheckbox');
    const useGeneralizedGates = checkbox.checked;
    //console.log("result: " + useGeneralizedGates );

    saveCurrentZoomAsInitialStateForAnimation();

    global_circuit.expandCircuit( useGeneralizedGates );
    circuitViewer.updateURLIfNecessary();
    circuitViewer.recomputeGeometryOfVisualizations();

    frameCircuit();
    saveCurrentZoomAsFinalStateForAnimation();
    // restoreInitialStateForAnimationAsCurrentZoom();
    startAnimation();
}

const maxQubitsAllowedForComputingSSREMagic = 6;
function printMagicButtonHandler() {
    let n = global_circuit.numWires;
    if ( n <= maxQubitsAllowedForComputingSSREMagic ) {
        let outputStateVector = global_circuit.stateVectors[ global_circuit.numStages ];
        let rho = Sim.computeDensityMatrix( n, outputStateVector );
        let time0 = (new Date()).getTime();
        let magic = Sim.computeSSREMagic( rho, /* useCache? */ n <= 5 );
        let time1 = (new Date()).getTime();
        let timeTaken = time1 - time0; // in milliseconds
        let max_magic = Math.log2(2**n + 1) - 1;
        console.log(`The output state of the circuit has SSRE magic = ${magic}, out of a theoretical max of ${max_magic} for ${n} qubits. Computed in roughly ${timeTaken} milliseconds.`);
    }
    else {
        console.log("Too many qubits to compute magic within a reasonable time. If you think this is too conservative, check the documentation for computeSSREMagic(), and change the constant maxQubitsAllowedForComputingSSREMagic in the source code.");
    }
}

// When the back/forward button is used:
window.addEventListener('popstate', (event) => {
    if ( verboseEvents ) console.log("popstate!!!"); // TODO_loading
    initializeWithNewCircuit();
    draw();
});

function draw() {
    // BEGIN: position the instances of FloatingCheckbox
    //
    let p1_world, p2_world, p3_world, p4_world; // lower right corner, in world space
    if ( DispOpt.showLocalStatePerLayer ) {
        if ( DispOpt.showStateVectorsPerLayer ) {
            p1_world = new Vec2( PLV_x0, PLV_y0+global_circuit.numWires+PLV_space_h+SV_total_h );
        }
        else {
            p1_world = new Vec2( PLV_x0, PLV_y0+global_circuit.numWires );
        }
        p2_world = new Vec2( PLV_x0, PLV_y0+global_circuit.numWires );
    }
    else {
        if ( DispOpt.showStateVectorsPerLayer ) {
            p1_world = new Vec2( PLV_x0, PLV_y0+SV_total_h );
        }
        else {
            p1_world = new Vec2( -0.5, global_circuit.numWires );
        }
        p2_world = new Vec2( -0.5, global_circuit.numWires );
    }
    if ( DispOpt.showFinalLocalState ) {
        if ( DispOpt.showFinalHalfMatrix ) {
            p4_world = new Vec2( FV_HM_center_x0, 0 );
        }
        else {
            p4_world = new Vec2( FV_LS_x0+LS_W, 0 );
        }
        p3_world = new Vec2( FV_LS_x0+LS_W, 0 );
    }
    else {
        if ( DispOpt.showFinalHalfMatrix ) {
            p4_world = new Vec2( FV_HM_center_x0, 0 );
        }
        else {
            p4_world = new Vec2( global_circuit.numStages+0.5, 0 );
        }
        p3_world = new Vec2( global_circuit.numStages+0.5, 0 );
    }
    let m = 5;
    let p_pixels = draw2.convertWorldSpaceUnitsToPixels( p1_world );
    floatingCheckbox1.setPosition( p_pixels.x-FC_SIZE-m, p_pixels.y-FC_SIZE );
    p_pixels = draw2.convertWorldSpaceUnitsToPixels( p2_world );
    floatingCheckbox2.setPosition( p_pixels.x-FC_SIZE-m, p_pixels.y-FC_SIZE );
    if ( floatingCheckbox2.y+FC_SIZE+m > floatingCheckbox1.y )
        floatingCheckbox2.y = floatingCheckbox1.y-FC_SIZE-m;
    p_pixels = draw2.convertWorldSpaceUnitsToPixels( p3_world );
    floatingCheckbox3.setPosition( p_pixels.x-FC_SIZE, p_pixels.y-FC_SIZE-m );
    p_pixels = draw2.convertWorldSpaceUnitsToPixels( p4_world );
    floatingCheckbox4.setPosition( p_pixels.x-FC_SIZE, p_pixels.y-FC_SIZE-m );
    if ( floatingCheckbox3.x+FC_SIZE+m > floatingCheckbox4.x )
        floatingCheckbox3.x = floatingCheckbox4.x-FC_SIZE-m;
    //
    // END

    draw2.clear(DC_background[0],DC_background[1],DC_background[2]);
    draw2.setCoordinateSystemToWorldSpaceUnits();
    circuitViewer.drawCircuitView(draw2);
    draw2.setCoordinateSystemToPixels();
    toolbar.draw(draw2);
    floatingCheckbox1.draw(draw2);
    floatingCheckbox2.draw(draw2);
    floatingCheckbox3.draw(draw2);
    floatingCheckbox4.draw(draw2);
    if ( infoAboutObjectBeingDragged.source === null ) {
        const offset = TOOLTIP_SIZE; // a hack
        toolbar.drawTooltip(draw2,mouse_x,mouse_y+TOOLTIP_SIZE+offset);
        circuitViewer.drawTooltip(draw2,mouse_x,mouse_y-offset);
        floatingCheckbox1.drawTooltip(draw2,mouse_x,mouse_y-offset);
        floatingCheckbox2.drawTooltip(draw2,mouse_x,mouse_y-offset);
        floatingCheckbox3.drawTooltip(draw2,mouse_x,mouse_y-offset);
        floatingCheckbox4.drawTooltip(draw2,mouse_x,mouse_y-offset);
    }
    else {
        // XXX
        infoAboutObjectBeingDragged.source.drawObjectBeingDragged(draw2,mouse_x,mouse_y,infoAboutObjectBeingDragged);
        if ( infoAboutObjectBeingDragged.obj !== null )
            draw2.drawImage( infoAboutObjectBeingDragged.obj.getImage(), mouse_x, mouse_y, TB_ICON_SIZE, TB_ICON_SIZE );
    }
}

// This has been replaced with allImagesLoadedCallback()
//
//// https://stackoverflow.com/questions/951021/what-is-the-javascript-version-of-sleep
//let sleepSetTimeout_id;
//function sleep(ms) {
//    clearTimeout(sleepSetTimeout_id);
//    return new Promise(resolve => sleepSetTimeout_id = setTimeout(resolve, ms));
//}
//async function sleep_then_draw() {
//    await sleep(50); // give time for the icons to "load"
//    draw();
//}
//sleep_then_draw();


function frameButtonHandler() {
    frameCircuit();
    draw();
}

function animatedFrameButtonHandler() {
    saveCurrentZoomAsInitialStateForAnimation();
    frameCircuit();
    saveCurrentZoomAsFinalStateForAnimation();
    startAnimation();
}

function updateAfterChangeToDisplayOptions() {
    saveCurrentZoomAsInitialStateForAnimation();
    circuitViewer.recomputeGeometryOfVisualizations();
    frameCircuit();
    saveCurrentZoomAsFinalStateForAnimation();
    restoreInitialStateForAnimationAsCurrentZoom();
    startAnimation();
}

const ANIMATION_DURATION = 0.5; // in seconds
const ANIMATION_FRAME_RATE = 25; // in frames per second
let animationTimeout_id;
let isAnimationActive = false;
let animationParameter; // varies from 0.0 to 1.0 during animation
let anim_offsetx_initial;
let anim_offsety_initial;
let anim_scalefactor_initial;
let anim_offsetx_final;
let anim_offsety_final;
let anim_scalefactor_final;

function saveCurrentZoomAsInitialStateForAnimation() {
    anim_offsetx_initial = draw2.offsetX_pixels;
    anim_offsety_initial = draw2.offsetY_pixels;
    anim_scalefactor_initial = draw2.scaleFactorInWorldSpaceUnitsPerPixel;
}
function restoreInitialStateForAnimationAsCurrentZoom() {
    draw2.offsetX_pixels = anim_offsetx_initial;
    draw2.offsetY_pixels = anim_offsety_initial;
    draw2.scaleFactorInWorldSpaceUnitsPerPixel = anim_scalefactor_initial;
}
function saveCurrentZoomAsFinalStateForAnimation() {
    anim_offsetx_final = draw2.offsetX_pixels;
    anim_offsety_final = draw2.offsetY_pixels;
    anim_scalefactor_final = draw2.scaleFactorInWorldSpaceUnitsPerPixel;
}

function startAnimation() {
    animationParameter = 0;
    if ( isAnimationActive ) {
        // clear the current animation before starting a new one
        clearInterval( animationTimeout_id );
    }
    animationTimeout_id = setInterval( advanceAnimation, 1000 / ANIMATION_FRAME_RATE );
    isAnimationActive = true;
}
function advanceAnimation() {
    animationParameter += 1.0 / ( ANIMATION_DURATION * ANIMATION_FRAME_RATE );
    if ( animationParameter >= 1.0 ) {
        animationParameter = 1;
        clearInterval( animationTimeout_id );
        isAnimationActive = false;
    }
    //console.log(`advancing ${animationParameter}`);
    let U = animationParameter;
    let oneMinusU = 1-U;
    draw2.offsetX_pixels = oneMinusU*anim_offsetx_initial + U*anim_offsetx_final;
    draw2.offsetY_pixels = oneMinusU*anim_offsety_initial + U*anim_offsety_final;
    draw2.scaleFactorInWorldSpaceUnitsPerPixel = anim_scalefactor_initial * ((anim_scalefactor_final/anim_scalefactor_initial)**U);
    draw();
}

function updateAfterChangeToCircuit() {
    circuitViewer.circuit.compactify();
    saveCurrentZoomAsInitialStateForAnimation();
    circuitViewer.recomputeGeometryOfVisualizations();
    frameCircuit();
    saveCurrentZoomAsFinalStateForAnimation();
    restoreInitialStateForAnimationAsCurrentZoom();
    startAnimation();
    circuitViewer.updateURLIfNecessary();
}

function deleteCircuitPart( wire, stage ) {
    if ( wire >= 0 && stage >= 0 ) {
        circuitViewer.circuit.clearCell( wire, stage );
    }
    circuitViewer.clearHighlighting();
    circuitViewer.clearSelection();

    updateAfterChangeToCircuit();
}

// XXX
const DRAG_MODE_NOT_DRAGGING = 0;
const DRAG_MODE_MANAGED_BY_WIDGET = 1; // the widget interprets the drag as it sees fit
const DRAG_MODE_DRAG_AND_DROP = 2; // the framework implements drag-and-drop between widgets with this
const DRAG_MODE_TRANSLATE = 3;
const DRAG_MODE_ZOOM = 4;
const DRAG_MODE_DRAGGING_NOTHING = 5;
let currentDragMode = DRAG_MODE_NOT_DRAGGING;

// The MEB_ prefix means MouseEvent.button
const MEB_BUTTON_LEFT = 0;
const MEB_BUTTON_MIDDLE = 1;
const MEB_BUTTON_RIGHT = 2;


// This contains an 'OR'ing of MW_BUTTON_... and MW_KEY_... values.
let global_buttonAndKeyState = 0;


let mouse_x=0, mouse_y=0;
let mouse_x_world = 0, mouse_y_world = 0;

let widgetUnderMouse = null; // could be toolbar or circuitViewer or a floatingCheckbox... or null

let infoAboutObjectBeingDragged = { obj: null, source: null /* could be toolbar or circuitViewer or null */ };

// Returns a modified copy of sourceValue where one of the bits is turned on or off.
// The bit to modify is identified by bitMask, which must contain a single 1 bit at the desired location.
// The value to set the bit to is given by the boolean targetBitValue.
// Examples:
//     setBit( sourceValue, 4, true ) returns sourceValue with the 3rd least-significant bit turned on;
//     setBit( sourceValue, 8, false ) returns sourceValue with the 4th least-significant bit turned off
function setBit( sourceValue, bitMask, targetBitValue ) {
    return targetBitValue
        ? ( sourceValue | bitMask ) // turn on the bit
        : ( sourceValue & ~bitMask ); // turn off the bit
}

function mouseDownHandler(e) {
    e.preventDefault();   // disable middle-click auto-scroll

    let canvas_rectangle = canvas.getBoundingClientRect();
    mouse_x = e.clientX - canvas_rectangle.left;
    mouse_y = e.clientY - canvas_rectangle.top;
    let x_world = draw2.convertPixelsToWorldSpaceUnitsX( mouse_x );
    let y_world = draw2.convertPixelsToWorldSpaceUnitsY( mouse_y );

    let mw_buttonThatChanged;

    switch ( e.button ) {
    case MEB_BUTTON_LEFT:
        global_buttonAndKeyState |= MW_BUTTON_LEFT;
        mw_buttonThatChanged = MW_BUTTON_LEFT;
        break;
    case MEB_BUTTON_MIDDLE:
        global_buttonAndKeyState |= MW_BUTTON_MIDDLE;
        mw_buttonThatChanged = MW_BUTTON_MIDDLE;
        break;
    case MEB_BUTTON_RIGHT:
        global_buttonAndKeyState |= MW_BUTTON_RIGHT;
        mw_buttonThatChanged = MW_BUTTON_RIGHT;
        break;
    }
    global_buttonAndKeyState = setBit( global_buttonAndKeyState, MW_KEY_CONTROL, e.ctrlKey );
    global_buttonAndKeyState = setBit( global_buttonAndKeyState, MW_KEY_SHIFT, e.shiftKey );
    if ( verboseEvents ) console.log("buttonAndKeyState === "+global_buttonAndKeyState.toString(2));

    if ( currentDragMode === DRAG_MODE_NOT_DRAGGING ) {
        currentDragMode = DRAG_MODE_DRAGGING_NOTHING;
        if ( e.button === MEB_BUTTON_RIGHT ) {
            if ( e.shiftKey ) {
                currentDragMode = DRAG_MODE_TRANSLATE;
            }
            else if ( e.ctrlKey ) {
                currentDragMode = DRAG_MODE_ZOOM;
            }
        }
        else if ( e.button === MEB_BUTTON_LEFT || e.button === MEB_BUTTON_MIDDLE ) {
            infoAboutObjectBeingDragged.source = null;
            infoAboutObjectBeingDragged.obj = null;
            let returnValue = null;
            if ( widgetUnderMouse!==null ) {
                currentDragMode = DRAG_MODE_MANAGED_BY_WIDGET;
                returnValue = widgetUnderMouse.widget_mousePress( mouse_x, mouse_y, x_world, y_world, mw_buttonThatChanged, global_buttonAndKeyState );
                if ( returnValue.initiatesDragAndDrop ) {
                    infoAboutObjectBeingDragged.source = widgetUnderMouse;
                    infoAboutObjectBeingDragged.obj = returnValue.objectBeingDragged;
                    currentDragMode = DRAG_MODE_DRAG_AND_DROP;
                }
                if ( returnValue.redraw ) draw();
            }
        }
    }
}
function mouseUpHandler(e) {
    let canvas_rectangle = canvas.getBoundingClientRect();
    mouse_x = e.clientX - canvas_rectangle.left;
    mouse_y = e.clientY - canvas_rectangle.top;
    let x_world = draw2.convertPixelsToWorldSpaceUnitsX( mouse_x );
    let y_world = draw2.convertPixelsToWorldSpaceUnitsY( mouse_y );

    let mw_buttonThatChanged;

    switch ( e.button ) {
    case MEB_BUTTON_LEFT:
        global_buttonAndKeyState &= ~MW_BUTTON_LEFT;
        mw_buttonThatChanged = MW_BUTTON_LEFT;
        break;
    case MEB_BUTTON_MIDDLE:
        global_buttonAndKeyState &= ~MW_BUTTON_MIDDLE;
        mw_buttonThatChanged = MW_BUTTON_MIDDLE;
        break;
    case MEB_BUTTON_RIGHT:
        global_buttonAndKeyState &= ~MW_BUTTON_RIGHT;
        mw_buttonThatChanged = MW_BUTTON_RIGHT;
        break;
    }
    global_buttonAndKeyState = setBit( global_buttonAndKeyState, MW_KEY_CONTROL, e.ctrlKey );
    global_buttonAndKeyState = setBit( global_buttonAndKeyState, MW_KEY_SHIFT, e.shiftKey );
    if ( verboseEvents ) console.log("buttonAndKeyState === "+global_buttonAndKeyState.toString(2));

    let areAnyButtonsDown = (global_buttonAndKeyState & (MW_BUTTON_LEFT | MW_BUTTON_MIDDLE | MW_BUTTON_RIGHT)) !== 0;

    if ( ! areAnyButtonsDown ) {
        if ( currentDragMode === DRAG_MODE_TRANSLATE ) {
        }
        else if ( currentDragMode === DRAG_MODE_ZOOM ) {
        }
        else if ( currentDragMode === DRAG_MODE_MANAGED_BY_WIDGET ) {
            // We want the button up event to be sent to the widget that the drag started on,
            // even if the cursor is no longer over that widget.
            if ( widgetUnderMouse !== null ) {
                let returnValue = widgetUnderMouse.widget_mouseRelease(
                    mouse_x, mouse_y, x_world, y_world,
                    mw_buttonThatChanged,
                    global_buttonAndKeyState,
                    false,
                    null
                );
                currentDragMode = DRAG_MODE_NOT_DRAGGING;
                if ( returnValue.redraw ) draw();
            }
        }
        else if ( currentDragMode === DRAG_MODE_DRAG_AND_DROP ) {
            let returnValue = null;
            let dragAndDropSource = infoAboutObjectBeingDragged.source;
            let dragAndDropDestination = widgetUnderMouse;
            if ( widgetUnderMouse !== null ) {
                returnValue = widgetUnderMouse.widget_mouseRelease(
                    mouse_x, mouse_y, x_world, y_world,
                    mw_buttonThatChanged,
                    global_buttonAndKeyState,
                    true,
                    infoAboutObjectBeingDragged.source!==null ? infoAboutObjectBeingDragged : null
                );
            }
            if ( dragAndDropSource!==null && dragAndDropSource===dragAndDropDestination ) {
                dragAndDropSource.widget_cleanUpAfterDragAndDrop(true,true);
            }
            else {
                if ( dragAndDropSource!==null ) {
                    dragAndDropSource.widget_cleanUpAfterDragAndDrop(true,false);
                }
                if ( dragAndDropDestination!==null ) {
                    dragAndDropDestination.widget_cleanUpAfterDragAndDrop(false,true);
                }
            }
            infoAboutObjectBeingDragged.source = null;
            infoAboutObjectBeingDragged.obj = null;
            currentDragMode = DRAG_MODE_NOT_DRAGGING;
            if ( returnValue!==null && returnValue.redraw ) {
                draw();
            }
        }
        currentDragMode = DRAG_MODE_NOT_DRAGGING;
    }
}
function mouseHoverAndDragHandler(e) {
    let previous_mouse_x = mouse_x;
    let previous_mouse_y = mouse_y;
    let canvas_rectangle = canvas.getBoundingClientRect();
    mouse_x = e.clientX - canvas_rectangle.left;
    mouse_y = e.clientY - canvas_rectangle.top;
    let x_world = draw2.convertPixelsToWorldSpaceUnitsX( mouse_x );
    let y_world = draw2.convertPixelsToWorldSpaceUnitsY( mouse_y );
    mouse_x_world = x_world;
    mouse_y_world = y_world;

    let delta_x = mouse_x - previous_mouse_x;
    let delta_y = mouse_y - previous_mouse_y;

    global_buttonAndKeyState = setBit( global_buttonAndKeyState, MW_KEY_CONTROL, e.ctrlKey );
    global_buttonAndKeyState = setBit( global_buttonAndKeyState, MW_KEY_SHIFT, e.shiftKey );
    if ( verboseEvents ) console.log("buttonAndKeyState === "+global_buttonAndKeyState.toString(2));

    if ( currentDragMode === DRAG_MODE_TRANSLATE ) {
        draw2.translate( delta_x, delta_y );
    }
    else if ( currentDragMode === DRAG_MODE_ZOOM ) {
        const zoomFactorPerPixelDragged = 1.005;
        draw2.zoomIn( zoomFactorPerPixelDragged ** delta_x );
    }
    else if ( currentDragMode === DRAG_MODE_MANAGED_BY_WIDGET ) {
        if ( verboseEvents ) console.log("framework drag managed by widget");
        // We want the drag event to be sent to the widget that the drag started on,
        // even if the cursor is no longer over that widget.
        // Hence, we don't generate any leave events.
        // But we do need to be ready to transition to drag-and-drop mode,
        // since some widgets only decide if a drag-and-drop starts after the first drag event.
        if ( widgetUnderMouse !== null ) {
            let returnValue = widgetUnderMouse.widget_mouseDrag(
                mouse_x, mouse_y, x_world, y_world,
                global_buttonAndKeyState,
                false,
                null
            );
            if ( returnValue.initiatesDragAndDrop ) {
                if ( verboseEvents ) console.log("framework drag: dnd initiated");
                infoAboutObjectBeingDragged.source = widgetUnderMouse;
                infoAboutObjectBeingDragged.obj = returnValue.objectBeingDragged;
                currentDragMode = DRAG_MODE_DRAG_AND_DROP;
            }
        }
    }
    else if (
        currentDragMode === DRAG_MODE_NOT_DRAGGING            // hover
        || currentDragMode === DRAG_MODE_DRAG_AND_DROP
    ) {
        if ( verboseEvents && currentDragMode === DRAG_MODE_DRAG_AND_DROP) console.log("framework drag dnd");
        let newObjectUnderMouse = null;
        if ( toolbar.isUnder( mouse_x, mouse_y, x_world, y_world ) )
            newObjectUnderMouse = toolbar;
        else if ( circuitViewer.isUnder( mouse_x, mouse_y, x_world, y_world ) )
            newObjectUnderMouse = circuitViewer;
        if ( floatingCheckbox1.isUnder( mouse_x, mouse_y, x_world, y_world ) )
            newObjectUnderMouse = floatingCheckbox1;
        else if ( floatingCheckbox2.isUnder( mouse_x, mouse_y, x_world, y_world ) )
            newObjectUnderMouse = floatingCheckbox2;
        else if ( floatingCheckbox3.isUnder( mouse_x, mouse_y, x_world, y_world ) )
            newObjectUnderMouse = floatingCheckbox3;
        else if ( floatingCheckbox4.isUnder( mouse_x, mouse_y, x_world, y_world ) )
            newObjectUnderMouse = floatingCheckbox4;
        if ( newObjectUnderMouse !== widgetUnderMouse ) {
            if ( widgetUnderMouse !== null ) {
                // generate leave event
                if ( currentDragMode === DRAG_MODE_NOT_DRAGGING )
                    widgetUnderMouse.widget_mouseHoverLeave();
                else
                    widgetUnderMouse.widget_mouseDragLeave(); // only invoked during drag-and-drop
            }
            widgetUnderMouse = newObjectUnderMouse;
        }
        let returnValue;
        if ( widgetUnderMouse !== null ) {
            if ( currentDragMode === DRAG_MODE_NOT_DRAGGING ) { // hover
                returnValue = widgetUnderMouse.widget_mouseHover( mouse_x, mouse_y, x_world, y_world );
            }
            else if ( currentDragMode === DRAG_MODE_DRAG_AND_DROP ) {
                returnValue = widgetUnderMouse.widget_mouseDrag(
                    mouse_x, mouse_y, x_world, y_world,
                    global_buttonAndKeyState,
                    true,
                    infoAboutObjectBeingDragged.source!==null ? infoAboutObjectBeingDragged : null
                );
            }
        }
    }
    draw();
}

function keyDownHandler(e) {
    const ArrowUp = 38;
    const ArrowDown = 40;
    const ArrowLeft = 37;
    const ArrowRight = 39;

    if ( verboseEvents ) console.log("keyCode: " + e.keyCode + ", " + (e.ctrlKey ? "Ctrl ":"") + (e.shiftKey ? "Shift ":"") );
    if (e.key === 'Delete') {
        if ( verboseEvents ) console.log("delete key was pressed");
        deleteCircuitPart( circuitViewer.selected_circuitPart_wire, circuitViewer.selected_circuitPart_stage );
    }
    else if ( e.keyCode === ArrowUp || e.keyCode === ArrowDown || e.keyCode === ArrowLeft || e.keyCode === ArrowRight ) {
        if ( circuitViewer.selected_circuitPart_isAnythingSelected ) {
            let circuitPart = circuitViewer.circuit.getCellContents( circuitViewer.selected_circuitPart_wire, circuitViewer.selected_circuitPart_stage );
            if ( circuitPart.isParametric() ) {
                if ( circuitViewer.selected_circuitPart_parameter >= 0 ) {
                    if ( e.keyCode === ArrowUp ) {
                        circuitViewer.selected_circuitPart_parameter = ( circuitViewer.selected_circuitPart_parameter - 1 + circuitPart.getNumParameters() ) % circuitPart.getNumParameters();
                    }
                    else if ( e.keyCode === ArrowDown ) {
                        circuitViewer.selected_circuitPart_parameter = ( circuitViewer.selected_circuitPart_parameter + 1 ) % circuitPart.getNumParameters();
                    }
                    else if ( e.keyCode === ArrowLeft || e.keyCode === ArrowRight ) {
                        if ( e.ctrlKey || e.shiftKey ) {
                            let paramInfo = circuitPart.getParamInfo( circuitViewer.selected_circuitPart_parameter );
                            let newParamValue = circuitPart.paramValues[ circuitViewer.selected_circuitPart_parameter ];
                            if ( e.shiftKey /* we are snapping */ ) {
                                let newParamValue2 = Math.round( newParamValue / paramInfo.snapIncrement ) * paramInfo.snapIncrement;
                                if ( newParamValue2 === newParamValue )
                                    newParamValue2 += ( e.keyCode === ArrowRight ? 1 : -1 )*paramInfo.snapIncrement;
                                newParamValue = newParamValue2;
                            }
                            else {
                                newParamValue += ( e.keyCode === ArrowRight ? 1 : -1 )*paramInfo.dragIncrement;
                            }
                            if ( newParamValue < paramInfo.minValue )
                                newParamValue = paramInfo.minValue;
                            else if ( newParamValue > paramInfo.maxValue )
                                newParamValue = paramInfo.maxValue;
                            circuitPart.paramValues[ circuitViewer.selected_circuitPart_parameter ] = newParamValue;
                            circuitViewer.circuit.stateVectorsAndStatsAreDirty = true;
                            circuitViewer.updateURLIfNecessary( false );
                        }
                    }
                }
                else {
                    circuitViewer.selected_circuitPart_parameter = 0;
                }
            }

        }
    }
    draw();
}


function updateSizeOfCanvas() {
    // const myCanvas = document.getElementById("myCanvas");
    // canvas.width = window.innerWidth - 40;
    canvas.width = document.documentElement.clientWidth - 20; // avoids including width of vertical scrollbar
    draw2.resize(canvas.width,canvas.height);
    draw2.setFontHeight( FONT_HEIGHT ); // after resizing the canvas, its context is reset, so we must redo this
    frameCircuit();
}

function respondToResize() {
    updateSizeOfCanvas();
    draw();
}

function initializeStuffInTheDOM() {
    initializeDisplayOptionWidgets();

    canvas.addEventListener('mousedown',mouseDownHandler);
    canvas.addEventListener('mouseup',mouseUpHandler);
    canvas.addEventListener('mousemove',mouseHoverAndDragHandler);
    canvas.oncontextmenu = function(e) { e.preventDefault(); return false; }; // disable the right-click menu
    canvas.addEventListener('auxclick', function(e) { e.preventDefault(); return false; }); // don't know if this is necessary
    document.onkeydown = keyDownHandler;

    document.getElementById('copyQASMButton').addEventListener('click', () => {
      let text = document.getElementById('qasmText').textContent;
      navigator.clipboard.writeText(text);
    });

    updateSizeOfCanvas();
    if ( areAllImagesLoaded )
        draw();
}

window.addEventListener('load', initializeStuffInTheDOM ); // do this on a load event so the widgets have a chance to get created first
window.addEventListener('resize', respondToResize);
if ( verboseEvents ) console.log("We are rerunning!"); // TODO_loading

function allImagesLoadedCallback() {
    areAllImagesLoaded = true;
    draw();
}

</script>
</body>
</html>


